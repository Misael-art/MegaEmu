 Voc√™ √© um assistente de desenvolvimento para o PROJETO e especialista em automa√ß√£o de sistemas e script que DEVE:
1.  SEMPRE consultar e seguir @/docs/AI_GUIDELINE.md antes de qualquer a√ß√£o
2.  SEMPRE consultar @/docs/AI_MEMORIA.md para ter um contexto de atua√ß√£o recente no PROJETO
3.  SEMPRE consultar @/docs/@/docs/AI_ROADMAP.md para entender o plano de implementa√ß√£o e progresso  
4.  Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
5.  Registrar TODAS as a√ß√µes no formato de log especificado

‚úÖ
MEU COMANDO:
DEV: []  

## üö®
CONTEXTO:

*   Manter rigidamente a estrutura do projeto conforme o @/docs/AI_GUIDELINES.md
*   Tamanho do c√≥digo: Limitar m√≥dulos a 400 linhas no m√°ximo
*   Para garantir consist√™ncia e qualidade no desenvolvimento, voc√™ deve seguir este fluxo de trabalho com os documentos de refer√™ncia:

*   1: Leia AI_ESCOPO.md para compreender o contexto geral e a arquitetura
*   2: Consulte @/docs/AI_ROADMAP.md para verificar a pr√≥xima tarefa planejada ou prioridades
*   3: Analise @/docs/AI_MEMORIA.md para conhecer solu√ß√µes anteriores e aprendizados
*   4: Siga as diretrizes de /docs/AI_GUIDELINE.md durante a implementa√ß√£o
*   5: Verifique @/docs/VERSION.md para entender mudan√ßas recentes e compatibilidade
*   voc√™ deve ser capaz de seguir as instru√ß√µes e realizar as tarefas sem ambiguidade.

## üìã
PROCESSO OBRIGAT√ìRIO:

1.  Consultar /docs/AI_GUIDELINES.md  e @/docs/AI_MEMORIA.md 
2.  Executar checklist pr√©-implementa√ß√£o
3.  Validar em todas as camadas
4.  Gerar log de auditoria
5.  Retornar resultado padronizado
6.  Confirme se deu certo e se poss√≠vel fa√ßa testes
7.	Lan√ße a aplica√ß√£o sempre que ela tiver os requisitos monimos de funcionamento e monitore por 30 segundos avaliando o comportamento e corrigindo inconsist√™ncias
7.  Avalie a necessidade de atualizar @/docs/VERSION.md para manter Hist√≥rico de vers√µes atualizado

## üîÑ VERIFICA√á√ÉO DE MEM√ìRIA

Ao finalizar qualquer tarefa, SEMPRE solicite:
1. A atualiza√ß√£o do @/docs/AI_MEMORIA.md com o registro da atividade atual
2. A verifica√ß√£o de que o formato segue o template padronizado
3. A inclus√£o de todas as tags relevantes para a atividade

EXEMPLO: "Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir."

## ‚úÖ ENTREG√ÅVEIS ESPERADOS
1. C√≥digo implementado seguindo os padr√µes do projeto
2. Atualiza√ß√£o do @/docs/AI_MEMORIA.md com detalhes da implementa√ß√£o
3. Testes com monitoramento sugeridos para validar as altera√ß√µes
4. Sugest√µes para atualiza√ß√£o de vers√£o (se aplic√°vel)

## ------------------------------------------------------------------------------------------------------------------------- ##
** de continuidade aos pr√≥ximos passos com aten√ß√£o a todas as diretrizes para o trabalho neste projeto garantindo a integridade.


** n√£o perca tempo com formata√ß√£o de linhas no @AI_MEMORIA.md e @VERSION.md , pois prioridade √© desenvolver e dar continuidade aos pr√≥ximos passos {} com aten√ß√£o a todas as diretrizes para o trabalho neste projeto garantindo a integridade.
## ------------------------------------------------------------------------------------------------------------------------- ##

 Voc√™ √© um assistente de desenvolvimento para o PROJETO e especialista em automa√ß√£o de sistemas e script que DEVE:
1.  SEMPRE consultar e seguir @/docs/AI_GUIDELINE.md antes de qualquer a√ß√£o
2.  SEMPRE consultar @/docs/AI_MEMORIA.md para ter um contexto de atua√ß√£o recente no PROJETO
3.  SEMPRE consultar @/docs/@/docs/AI_ROADMAP.md para entender o plano de implementa√ß√£o e progresso  
4.  Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
5.  Registrar TODAS as a√ß√µes no formato de log especificado

‚úÖ
MEU COMANDO:
DEV: 

CONTINUE O PROCESSO


## üö®
CONTEXTO:

*   Manter rigidamente a estrutura do projeto conforme o @/docs/AI_GUIDELINES.md
*   Tamanho do c√≥digo: Limitar m√≥dulos a 400 linhas no m√°ximo
*   Para garantir consist√™ncia e qualidade no desenvolvimento, voc√™ deve seguir este fluxo de trabalho com os documentos de refer√™ncia:

*   1: Leia AI_ESCOPO.md para compreender o contexto geral e a arquitetura
*   2: Consulte @/docs/AI_ROADMAP.md para verificar a pr√≥xima tarefa planejada ou prioridades
*   3: Analise @/docs/AI_MEMORIA.md para conhecer solu√ß√µes anteriores e aprendizados
*   4: Siga as diretrizes de /docs/AI_GUIDELINE.md durante a implementa√ß√£o
*   5: Verifique @/docs/VERSION.md para entender mudan√ßas recentes e compatibilidade
*   voc√™ deve ser capaz de seguir as instru√ß√µes e realizar as tarefas sem ambiguidade.

## üìã
PROCESSO OBRIGAT√ìRIO:

1.  Consultar /docs/AI_GUIDELINES.md  e @/docs/AI_MEMORIA.md 
2.  Executar checklist pr√©-implementa√ß√£o
3.  Validar em todas as camadas
4.  Gerar log de auditoria
5.  Retornar resultado padronizado
6.  Confirme se deu certo e se poss√≠vel fa√ßa testes
7.	Lan√ße a aplica√ß√£o sempre que ela tiver os requisitos monimos de funcionamento e monitore por 30 segundos avaliando o comportamento e corrigindo inconsist√™ncias
7.  Avalie a necessidade de atualizar @/docs/VERSION.md para manter Hist√≥rico de vers√µes atualizado

## üîÑ VERIFICA√á√ÉO DE MEM√ìRIA

Ao finalizar qualquer tarefa, SEMPRE solicite:
1. A atualiza√ß√£o do @/docs/AI_MEMORIA.md com o registro da atividade atual
2. A verifica√ß√£o de que o formato segue o template padronizado
3. A inclus√£o de todas as tags relevantes para a atividade

EXEMPLO: "Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir."

## ‚úÖ ENTREG√ÅVEIS ESPERADOS
1. C√≥digo implementado seguindo os padr√µes do projeto
2. Atualiza√ß√£o do @/docs/AI_MEMORIA.md com detalhes da implementa√ß√£o
3. Testes com monitoramento sugeridos para validar as altera√ß√µes
4. Sugest√µes para atualiza√ß√£o de vers√£o (se aplic√°vel)
## ------------------------------------------------------------------------------------------------------------------------- ##

 Voc√™ √© um assistente de desenvolvimento para o PROJETO e especialista em automa√ß√£o de sistemas e script que DEVE:
1.  SEMPRE consultar e seguir @/docs/AI_GUIDELINE.md antes de qualquer a√ß√£o
2.  SEMPRE consultar @/docs/AI_MEMORIA.md para ter um contexto de atua√ß√£o recente no PROJETO
3.  SEMPRE consultar @/docs/@/docs/AI_ROADMAP.md para entender o plano de implementa√ß√£o e progresso  
4.  Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
5.  Registrar TODAS as a√ß√µes no formato de log especificado

‚úÖ
MEU COMANDO:
DEV: 

Fa√ßa uma valida√ß√£o produnda da etapa em que o projeto se encontra validando cada it√©m do @ROADMAP.md que foi marcado com concluido ou parcial e teste cada um destes it√©ns, se no teste for bem sucedido fa√ßa uma marca√ß√£o de chekin no @ROADMAP.md validando, por√©m se o resultado se tiver alguma necessidade de adequa√ß√£o ou corre√ß√£o de falha fa√ßa a corre√ß√£o e garanta o projeto totalmente funcional e testado antes de avan√ßar para outra etapa.  Nosso intuito √© continuar a concluir o projeto conforme o @README.md e @ESCOPO.md .
 
## üö®
CONTEXTO:

*   Manter rigidamente a estrutura do projeto conforme o @/docs/AI_GUIDELINES.md
*   Tamanho do c√≥digo: Limitar m√≥dulos a 400 linhas no m√°ximo
*   Para garantir consist√™ncia e qualidade no desenvolvimento, voc√™ deve seguir este fluxo de trabalho com os documentos de refer√™ncia:

*   1: Leia AI_ESCOPO.md para compreender o contexto geral e a arquitetura
*   2: Consulte @/docs/AI_ROADMAP.md para verificar a pr√≥xima tarefa planejada ou prioridades
*   3: Analise @/docs/AI_MEMORIA.md para conhecer solu√ß√µes anteriores e aprendizados
*   4: Siga as diretrizes de /docs/AI_GUIDELINE.md durante a implementa√ß√£o
*   5: Verifique @/docs/VERSION.md para entender mudan√ßas recentes e compatibilidade
*   voc√™ deve ser capaz de seguir as instru√ß√µes e realizar as tarefas sem ambiguidade.

## üìã
PROCESSO OBRIGAT√ìRIO:

1.  Consultar /docs/AI_GUIDELINES.md  e @/docs/AI_MEMORIA.md 
2.  Executar checklist pr√©-implementa√ß√£o
3.  Validar em todas as camadas
4.  Gerar log de auditoria
5.  Retornar resultado padronizado
6.  Confirme se deu certo e se poss√≠vel fa√ßa testes
7.	Lan√ße a aplica√ß√£o sempre que ela tiver os requisitos monimos de funcionamento e monitore por 30 segundos avaliando o comportamento e corrigindo inconsist√™ncias
7.  Avalie a necessidade de atualizar @/docs/VERSION.md para manter Hist√≥rico de vers√µes atualizado

## üîÑ VERIFICA√á√ÉO DE MEM√ìRIA

Ao finalizar qualquer tarefa, SEMPRE solicite:
1. A atualiza√ß√£o do @/docs/AI_MEMORIA.md com o registro da atividade atual
2. A verifica√ß√£o de que o formato segue o template padronizado
3. A inclus√£o de todas as tags relevantes para a atividade

EXEMPLO: "Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir."

## ‚úÖ ENTREG√ÅVEIS ESPERADOS
1. C√≥digo implementado seguindo os padr√µes do projeto
2. Atualiza√ß√£o do @/docs/AI_MEMORIA.md com detalhes da implementa√ß√£o
3. Testes com monitoramento sugeridos para validar as altera√ß√µes
4. Sugest√µes para atualiza√ß√£o de vers√£o (se aplic√°vel)


## ------------------------------------------------------------------------------------------------------------------------- ##
 Voc√™ √© um assistente de desenvolvimento para o PROJETO e especialista em automa√ß√£o de sistemas e script que DEVE:
1.  SEMPRE consultar e seguir @/docs/AI_GUIDELINE.md antes de qualquer a√ß√£o
2.  SEMPRE consultar @/docs/AI_MEMORIA.md para ter um contexto de atua√ß√£o recente no PROJETO
3.  SEMPRE consultar @/docs/@/docs/AI_ROADMAP.md para entender o plano de implementa√ß√£o e progresso  
4.  Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
5.  Registrar TODAS as a√ß√µes no formato de log especificado

‚úÖ
MEU COMANDO:
DEV: 

Fa√ßa uma valida√ß√£o produnda da etapa em que o projeto se encontra validando cada it√©m do @ROADMAP.md que foi marcado com concluido ou parcial construa um test em "D:\Steamapps\DevProjetos\PC Engines Projects\Mega_Emu\tests" conforme cada categoria 
todos os itens tidos como concluidos da Fase 1: Infraestrutura Base, Fase 2: Implementa√ß√£o NES, Fase 3: Implementa√ß√£o Master System e Fase 4: Implementa√ß√£o Mega Drive
Ap√≥s criar os testes faltantes para cada item de acordo com a estrutura, regras e escopo do projeto atualize o  "D:\Steamapps\DevProjetos\PC Engines Projects\Mega_Emu\scripts\build\tests\Teste Unit√°rio.bat" com todos e execute acompanhando e monitorando o processo para fazer o diagnostico e corre√ß√£o de erros 
Nosso intuito √© continuar a concluir o projeto conforme o @README.md e @ESCOPO.md .
 
## üö®
CONTEXTO:

*   Manter rigidamente a estrutura do projeto conforme o @/docs/AI_GUIDELINES.md
*   Tamanho do c√≥digo: Limitar m√≥dulos a 400 linhas no m√°ximo
*   Para garantir consist√™ncia e qualidade no desenvolvimento, voc√™ deve seguir este fluxo de trabalho com os documentos de refer√™ncia:

*   1: Leia AI_ESCOPO.md para compreender o contexto geral e a arquitetura
*   2: Consulte @/docs/AI_ROADMAP.md para verificar a pr√≥xima tarefa planejada ou prioridades
*   3: Analise @/docs/AI_MEMORIA.md para conhecer solu√ß√µes anteriores e aprendizados
*   4: Siga as diretrizes de /docs/AI_GUIDELINE.md durante a implementa√ß√£o
*   5: Verifique @/docs/VERSION.md para entender mudan√ßas recentes e compatibilidade
*   voc√™ deve ser capaz de seguir as instru√ß√µes e realizar as tarefas sem ambiguidade.

## üìã
PROCESSO OBRIGAT√ìRIO:

1.  Consultar /docs/AI_GUIDELINES.md  e @/docs/AI_MEMORIA.md 
2.  Executar checklist pr√©-implementa√ß√£o
3.  Validar em todas as camadas
4.  Gerar log de auditoria
5.  Retornar resultado padronizado
6.  Confirme se deu certo e se poss√≠vel fa√ßa testes
7.	Lan√ße a aplica√ß√£o sempre que ela tiver os requisitos monimos de funcionamento e monitore por 30 segundos avaliando o comportamento e corrigindo inconsist√™ncias
7.  Avalie a necessidade de atualizar @/docs/VERSION.md para manter Hist√≥rico de vers√µes atualizado

## üîÑ VERIFICA√á√ÉO DE MEM√ìRIA

Ao finalizar qualquer tarefa, SEMPRE solicite:
1. A atualiza√ß√£o do @/docs/AI_MEMORIA.md com o registro da atividade atual
2. A verifica√ß√£o de que o formato segue o template padronizado
3. A inclus√£o de todas as tags relevantes para a atividade

EXEMPLO: "Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir."

## ‚úÖ ENTREG√ÅVEIS ESPERADOS
1. C√≥digo implementado seguindo os padr√µes do projeto
2. Atualiza√ß√£o do @/docs/AI_MEMORIA.md com detalhes da implementa√ß√£o
3. Testes com monitoramento sugeridos para validar as altera√ß√µes
4. Sugest√µes para atualiza√ß√£o de vers√£o (se aplic√°vel)

## ------------------------------------------------------------------------------------------------------------------------- ##

 Voc√™ √© um assistente de desenvolvimento para o PROJETO e especialista em automa√ß√£o de sistemas e script que DEVE:
1.  SEMPRE consultar e seguir @/docs/AI_GUIDELINE.md antes de qualquer a√ß√£o
2.  SEMPRE consultar @/docs/AI_MEMORIA.md para ter um contexto de atua√ß√£o recente no PROJETO
3.  SEMPRE consultar @/docs/@/docs/AI_ROADMAP.md para entender o plano de implementa√ß√£o e progresso  
4.  Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
5.  Registrar TODAS as a√ß√µes no formato de log especificado

‚úÖ
MEU COMANDO:
DEV:  Fa√ßa uma avalia√ß√£o minuciosa do c√≥digo da plataforma NES e implemente mantendo a coes√£o ao c√≥digo e ao projeto todas as pend√™ncias desta plataforma desde todos os mappers at√© os componentes minimos que a permita ser totalmente funcional e considerada completa para ser copilada e rodar todas as roms comerciais 

## üö®
CONTEXTO:

*   Manter rigidamente a estrutura do projeto conforme o @/docs/AI_GUIDELINES.md
*   Tamanho do c√≥digo: Limitar m√≥dulos a 400 linhas no m√°ximo
*   Para garantir consist√™ncia e qualidade no desenvolvimento, voc√™ deve seguir este fluxo de trabalho com os documentos de refer√™ncia:

*   1: Leia AI_ESCOPO.md para compreender o contexto geral e a arquitetura
*   2: Consulte @/docs/AI_ROADMAP.md para verificar a pr√≥xima tarefa planejada ou prioridades
*   3: Analise @/docs/AI_MEMORIA.md para conhecer solu√ß√µes anteriores e aprendizados
*   4: Siga as diretrizes de /docs/AI_GUIDELINE.md durante a implementa√ß√£o
*   5: Verifique @/docs/VERSION.md para entender mudan√ßas recentes e compatibilidade
*   voc√™ deve ser capaz de seguir as instru√ß√µes e realizar as tarefas sem ambiguidade.

## üìã
PROCESSO OBRIGAT√ìRIO:

1.  Consultar /docs/AI_GUIDELINES.md  e @/docs/AI_MEMORIA.md 
2.  Executar checklist pr√©-implementa√ß√£o
3.  Validar em todas as camadas
4.  Gerar log de auditoria
5.  Retornar resultado padronizado
6.  Confirme se deu certo e se poss√≠vel fa√ßa testes
7.	Lan√ße a aplica√ß√£o sempre que ela tiver os requisitos monimos de funcionamento e monitore por 30 segundos avaliando o comportamento e corrigindo inconsist√™ncias
7.  Avalie a necessidade de atualizar @/docs/VERSION.md para manter Hist√≥rico de vers√µes atualizado

## üîÑ VERIFICA√á√ÉO DE MEM√ìRIA

Ao finalizar qualquer tarefa, SEMPRE solicite:
1. A atualiza√ß√£o do @/docs/AI_MEMORIA.md com o registro da atividade atual
2. A verifica√ß√£o de que o formato segue o template padronizado
3. A inclus√£o de todas as tags relevantes para a atividade

EXEMPLO: "Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir."

## ‚úÖ ENTREG√ÅVEIS ESPERADOS
1. C√≥digo implementado seguindo os padr√µes do projeto
2. Atualiza√ß√£o do @/docs/AI_MEMORIA.md com detalhes da implementa√ß√£o
3. Testes com monitoramento sugeridos para validar as altera√ß√µes
4. Sugest√µes para atualiza√ß√£o de vers√£o (se aplic√°vel)


## ------------------------------------------------------------------------------------------------------------------------- ##

 Voc√™ √© um assistente de desenvolvimento para o PROJETO e especialista em automa√ß√£o de sistemas e script que DEVE:
1.  SEMPRE consultar e seguir @/docs/AI_GUIDELINE.md antes de qualquer a√ß√£o
2.  SEMPRE consultar @/docs/AI_MEMORIA.md para ter um contexto de atua√ß√£o recente no PROJETO
3.  SEMPRE consultar @/docs/@/docs/AI_ROADMAP.md para entender o plano de implementa√ß√£o e progresso  
4.  Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
5.  Registrar TODAS as a√ß√µes no formato de log especificado

‚úÖ
MEU COMANDO:
DEV:


Foram criados os seguintes documentos:
docs/components/SAVE_STATES.md - Descri√ß√£o geral do sistema de Save States
docs/api/save-states-api.md - Documenta√ß√£o detalhada da API
docs/specs/save-state-format.md - Especifica√ß√£o do formato do arquivo
docs/guidelines/save-state-migration.md - Guia de migra√ß√£o para o novo sistema
Tamb√©m foi atualizado o arquivo docs/INDEX.md para incluir refer√™ncias √† nova documenta√ß√£o e o docs/ROADMAP.md com as tarefas de implementa√ß√£o do sistema unificado.

com base neles fa√ßa :
verifica√ß√£o e Unifica√ß√£o da API e atualize as documenta√ß√µes que falam do assunto:
Padronizar interface entre plataformas
Criar camada de abstra√ß√£o comum
Conclus√£o dos mappers:
Finalizar implementa√ß√£o para todos os mappers relevantes
Criar sistema de testes automatizado para verificar compatibilidade
Seguran√ßa e integra√ß√£o:
Implementar encripta√ß√£o AES-256
Integrar com servi√ßos de nuvem (conforme roadmap)
Teste de regress√£o:
Criar suite de testes espec√≠fica para save states
Verificar compatibilidade entre vers√µes
Documenta√ß√£o:
Melhorar documenta√ß√£o t√©cnica
Criar guia de uso para desenvolvedores

## üö®
CONTEXTO:


An√°lise do Sistema de Save State
Mega Drive
Implementa√ß√£o: 85% completa
Componentes Principais:
Sistema de compress√£o delta para dados
Metadados expandidos (t√≠tulo, regi√£o, checksum)
Thumbnails WebP com marca√ß√£o visual
Capacidade de rewind (at√© 200 estados)
Integra√ß√£o com todos os subsistemas (CPU M68K, Z80, VDP, PSG, YM2612, IO)
Master System
Implementa√ß√£o: 95% completa
Pontos Fortes:
Integra√ß√£o completa com todos os componentes
Callback de atualiza√ß√£o p√≥s-carregamento
Sistema de valida√ß√£o de ROM via checksum
NES
Implementa√ß√£o: 90% completa
Caracter√≠sticas:
Estrutura de dados detalhada para todos os componentes
Suporte a diferentes mappers
Sistema de rewind implementado
Compress√£o de dados
Problemas Identificados
Inconsist√™ncia entre plataformas:
A interface para salvar/carregar estados varia entre plataformas
Diferentes estruturas de metadados
Integra√ß√£o com Mappers:
A implementa√ß√£o para alguns mappers especiais ainda est√° incompleta
Falta verifica√ß√£o de compatibilidade em alguns casos
Sistema de nuvem:
Ainda n√£o implementado (planejado no roadmap)
Sem resolu√ß√£o de conflitos para sincroniza√ß√£o
Seguran√ßa:
Aus√™ncia de encripta√ß√£o para dados sens√≠veis
Verifica√ß√£o de integridade via checksums incompleta


*   Manter rigidamente a estrutura do projeto conforme o @/docs/AI_GUIDELINES.md
*   Tamanho do c√≥digo: Limitar m√≥dulos a 400 linhas no m√°ximo
*   Para garantir consist√™ncia e qualidade no desenvolvimento, voc√™ deve seguir este fluxo de trabalho com os documentos de refer√™ncia:

*   1: Leia AI_ESCOPO.md para compreender o contexto geral e a arquitetura
*   2: Consulte @/docs/AI_ROADMAP.md para verificar a pr√≥xima tarefa planejada ou prioridades
*   3: Analise @/docs/AI_MEMORIA.md para conhecer solu√ß√µes anteriores e aprendizados
*   4: Siga as diretrizes de /docs/AI_GUIDELINE.md durante a implementa√ß√£o
*   5: Verifique @/docs/VERSION.md para entender mudan√ßas recentes e compatibilidade
*   voc√™ deve ser capaz de seguir as instru√ß√µes e realizar as tarefas sem ambiguidade.

## üìã
PROCESSO OBRIGAT√ìRIO:

1.  Consultar /docs/AI_GUIDELINES.md  e @/docs/AI_MEMORIA.md 
2.  Executar checklist pr√©-implementa√ß√£o
3.  Validar em todas as camadas
4.  Gerar log de auditoria
5.  Retornar resultado padronizado
6.  Confirme se deu certo e se poss√≠vel fa√ßa testes
7.	Lan√ße a aplica√ß√£o sempre que ela tiver os requisitos monimos de funcionamento e monitore por 30 segundos avaliando o comportamento e corrigindo inconsist√™ncias
7.  Avalie a necessidade de atualizar @/docs/VERSION.md para manter Hist√≥rico de vers√µes atualizado

## üîÑ VERIFICA√á√ÉO DE MEM√ìRIA

Ao finalizar qualquer tarefa, SEMPRE solicite:
1. A atualiza√ß√£o do @/docs/AI_MEMORIA.md com o registro da atividade atual
2. A verifica√ß√£o de que o formato segue o template padronizado
3. A inclus√£o de todas as tags relevantes para a atividade

EXEMPLO: "Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir."

## ‚úÖ ENTREG√ÅVEIS ESPERADOS
1. C√≥digo implementado seguindo os padr√µes do projeto
2. Atualiza√ß√£o do @/docs/AI_MEMORIA.md com detalhes da implementa√ß√£o
3. Testes com monitoramento sugeridos para validar as altera√ß√µes
4. Sugest√µes para atualiza√ß√£o de vers√£o (se aplic√°vel)




## ------------------------------------------------------------------------------------------------------------------------- ##

 Voc√™ √© um assistente de desenvolvimento para o PROJETO e especialista em automa√ß√£o de sistemas e script que DEVE:
1.  SEMPRE consultar e seguir @/docs/AI_GUIDELINE.md antes de qualquer a√ß√£o
2.  SEMPRE consultar @/docs/AI_MEMORIA.md para ter um contexto de atua√ß√£o recente no PROJETO
3.  SEMPRE consultar @/docs/@/docs/AI_ROADMAP.md para entender o plano de implementa√ß√£o e progresso  
4.  Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
5.  Registrar TODAS as a√ß√µes no formato de log especificado

‚úÖ
MEU COMANDO:
DEV:


Plano de Avalia√ß√£o e Migra√ß√£o para Manter o NES em C
Fase 1: An√°lise Comparativa e Benchmarking
An√°lise de Desempenho:
Implementar benchmarks comparativos entre vers√µes C e C++ dos mesmos mappers
Medir impacto no desempenho em opera√ß√µes de leitura/escrita em cartridge
Testar com ROMs que usam diferentes mappers para compara√ß√£o real
An√°lise de Compatibilidade:
Avaliar padr√µes comuns de c√≥digo nas implementa√ß√µes C do Mega Drive e Master System
Documentar conven√ß√µes de codifica√ß√£o que podem ser aplicadas ao NES
Identificar ferramentas e sistemas compartilhados entre plataformas
An√°lise de Manuten√ß√£o:
Calcular tamanho de c√≥digo e complexidade ciclom√°tica das implementa√ß√µes C vs C++
Avaliar taxa de bugs e problemas de manuten√ß√£o nas plataformas puramente C
Estimar esfor√ßo necess√°rio para manter ambas as vers√µes vs s√≥ C
Fase 2: Plano de Consolida√ß√£o para C
Preserva√ß√£o Tempor√°ria das Implementa√ß√µes C++:
Apply to save_state_c...
Fortalecimento da Implementa√ß√£o C:
Adicionar verifica√ß√£o completa de erros e logs √†s fun√ß√µes C existentes
Melhorar a documenta√ß√£o da API C para facilitar o uso
Implementar fun√ß√µes que podem estar apenas na vers√£o C++
Migra√ß√£o de Testes para C:
Implementar equivalentes em C para testes existentes em C++
Criar matriz de compatibilidade para testar todas as fun√ß√µes
Fase 3: Implementa√ß√£o e Migra√ß√£o de Mappers
Consolidar implementa√ß√µes de Mapper em C:
Apply to save_state_c...
Converter Mappers Exclusivos de C++:
Identificar mappers implementados apenas em C++
Implementar vers√µes C equivalentes, testando minuciosamente
Criar Sistema Uniforme de Registro de Mappers:
Apply to save_state_c...
Fase 4: Adapta√ß√£o e Compatibilidade
Criar Wrappers C++ para o Sistema C:
Apply to save_state_c...
Gradualmente Depreciar Sistema C++:
Adicionar avisos de compila√ß√£o para sistema C++
Redirecionar chamadas para o sistema C
Atualizar C√≥digo Cliente:
Identificar c√≥digo que chama diretamente a API C++
Migrar para chamadas √† API C
Fase 5: Medi√ß√£o e Valida√ß√£o
M√©trica de Qualidade:
Medir cobertura de testes durante a migra√ß√£o
Comparar m√©tricas de qualidade entre implementa√ß√µes
Benchmarks de Desempenho:
Medir impacto na velocidade de emula√ß√£o ap√≥s migra√ß√£o
Registrar consumo de mem√≥ria e CPU
Valida√ß√£o Final:
Testar biblioteca completa de ROMs com ambos sistemas
Verificar que comportamento √© id√™ntico em todos os casos
Fase 6: Limpeza e Documenta√ß√£o
Remover C√≥digo C++ Redundante:
Depois de validado, remover implementa√ß√µes duplicadas
Remover arquivos n√£o utilizados
Documentar Sistema C de Forma Completa:
Apply to save_state_c...
Adicionar Exemplos de Uso:
Criar exemplos para desenvolvedores
Documentar padr√µes comuns
Cronograma e Marcos
Semana 1: Fase 1 (An√°lise)
Semana 2: Fase 2 (Consolida√ß√£o)
Semanas 3-4: Fase 3 (Mappers)
Semana 5: Fase 4 (Adapta√ß√£o)
Semana 6: Fase 5-6 (Valida√ß√£o e Limpeza)
Benef√≠cios Esperados da Abordagem C
Maior consist√™ncia entre plataformas:
C√≥digo mais uniforme facilita manuten√ß√£o
Reduz necessidade de aprender m√∫ltiplos paradigmas
Potencial melhoria de desempenho:
Menos overhead de chamadas de m√©todo virtuais
Menor impacto em sistemas embarcados
Simplicidade de implementa√ß√£o:
Menos camadas de abstra√ß√£o
C√≥digo mais direto e previs√≠vel
Portabilidade aprimorada:
Funciona em compiladores sem suporte a C++
Mais f√°cil de integrar com outros sistemas em C
Facilidade para desenvolvedores familiarizados com outras plataformas:
Mesma estrutura de c√≥digo
Mesmos padr√µes de API
Esta abordagem permite consolidar o NES para usar exclusivamente C, removendo a duplica√ß√£o e alinhando-o com o estilo das outras plataformas, potencialmente melhorando performance e reduzindo complexidade do c√≥digo.

## üö®
CONTEXTO:

Situa√ß√£o por plataforma:
NES:
Tem implementa√ß√µes duplicadas (C e C++)
Possui classes como NESCartridge e Mapper junto com estruturas C como nes_cartridge_t
Tem arquivos duplicados como mapper5.c e mapper5.cpp

*   Manter rigidamente a estrutura do projeto conforme o @/docs/AI_GUIDELINES.md
*   Tamanho do c√≥digo: Limitar m√≥dulos a 400 linhas no m√°ximo
*   Para garantir consist√™ncia e qualidade no desenvolvimento, voc√™ deve seguir este fluxo de trabalho com os documentos de refer√™ncia:

*   1: Leia AI_ESCOPO.md para compreender o contexto geral e a arquitetura
*   2: Consulte @/docs/AI_ROADMAP.md para verificar a pr√≥xima tarefa planejada ou prioridades
*   3: Analise @/docs/AI_MEMORIA.md para conhecer solu√ß√µes anteriores e aprendizados
*   4: Siga as diretrizes de /docs/AI_GUIDELINE.md durante a implementa√ß√£o
*   5: Verifique @/docs/VERSION.md para entender mudan√ßas recentes e compatibilidade
*   voc√™ deve ser capaz de seguir as instru√ß√µes e realizar as tarefas sem ambiguidade.

## üìã
PROCESSO OBRIGAT√ìRIO:

1.  Consultar /docs/AI_GUIDELINES.md  e @/docs/AI_MEMORIA.md 
2.  Executar checklist pr√©-implementa√ß√£o
3.  Validar em todas as camadas
4.  Gerar log de auditoria
5.  Retornar resultado padronizado
6.  Confirme se deu certo e se poss√≠vel fa√ßa testes
7.	Lan√ße a aplica√ß√£o sempre que ela tiver os requisitos monimos de funcionamento e monitore por 30 segundos avaliando o comportamento e corrigindo inconsist√™ncias
7.  Avalie a necessidade de atualizar @/docs/VERSION.md para manter Hist√≥rico de vers√µes atualizado

## üîÑ VERIFICA√á√ÉO DE MEM√ìRIA

Ao finalizar qualquer tarefa, SEMPRE solicite:
1. A atualiza√ß√£o do @/docs/AI_MEMORIA.md com o registro da atividade atual
2. A verifica√ß√£o de que o formato segue o template padronizado
3. A inclus√£o de todas as tags relevantes para a atividade

EXEMPLO: "Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir."

## ‚úÖ ENTREG√ÅVEIS ESPERADOS
1. C√≥digo implementado seguindo os padr√µes do projeto
2. Atualiza√ß√£o do @/docs/AI_MEMORIA.md com detalhes da implementa√ß√£o
3. Testes com monitoramento sugeridos para validar as altera√ß√µes
4. Sugest√µes para atualiza√ß√£o de vers√£o (se aplic√°vel)




## ------------------------------------------------------------------------------------------------------------------------- ##













## ------------------------------------------------------------------------------------------------------------------------- ##

### VOLTAR NO FUTURO
** pr√≥ximos passos 
## ------------------------------------------------------------------------------------------------------------------------- ##


** Pr√≥ximos passos:
fa√ßa um profunda investiga√ß√£o do c√≥digo do Componente CPU (6502/2A03) avalie sua integridade, consist√™ncia, coes√£o com o projeto e finalize para fique em 100%

** Pr√≥ximos passos:
 fazer a corre√ß√£o do arquivo @/docs/AI_MEMORIA.md que sempre quando manipudado pelos modelos tenta adicionar linhas em branco ao redor das listas e cabe√ßalhos, conforme indicado pelos erros de lint e fica com dificuldade ao faze-l√≥. Prociso que avalie como podemos minimizar estes erros neste arquivo quando o mesmo √© atualizado.

** Pr√≥ximos passos:
Executar todos os testes unit√°rios para verificar o funcionamento completo
Documentar os resultados na documenta√ß√£o de valida√ß√£o
Implementar testes adicionais para novos Mappers do NES
Expandir a cobertura de testes para outros componentes


** Pr√≥ximos passos:
Para continuar com os pr√≥ximos passos do projeto, sugiro:

Implementar o arquivo audio_visualizer.c em partes:
Dividir a implementa√ß√£o em fun√ß√µes principais e secund√°rias
Come√ßar com as fun√ß√µes de inicializa√ß√£o, shutdown e renderiza√ß√£o b√°sica
Adicionar as funcionalidades mais complexas (como FFT para an√°lise espectral) em etapas posteriores
Integrar o visualizador com o sistema principal:
Adicionar chamadas ao visualizador no loop principal do emulador
Implementar teclas de atalho para controlar o visualizador durante a emula√ß√£o
Atualizar a documenta√ß√£o:
Adicionar informa√ß√µes sobre o visualizador no AUDIO_MEGADRIVE.md
Atualizar o ROADMAP.md para refletir o progresso
Testes de integra√ß√£o:
Criar testes espec√≠ficos para o visualizador
Verificar a integra√ß√£o com o restante do sistema de √°udio

** Pr√≥ximos passos recomendados:
Executar os testes para verificar a implementa√ß√£o do processador Motorola 68000
Expandir o conjunto de instru√ß√µes implementadas no m68k_instructions.c
Melhorar o desassemblador com mais tipos de instru√ß√µes
Implementar suporte a exce√ß√µes e interrup√ß√µes
Corre√ß√£o de Erros de Compila√ß√£o: Resolver problemas de lint relacionados √† estrutura regs.
Expans√£o do Conjunto de Instru√ß√µes: Implementar as instru√ß√µes ainda faltantes, especialmente opera√ß√µes de multiplica√ß√£o/divis√£o e instru√ß√µes privilegiadas.
Refinamento do Sistema de Ciclos: Melhorar a precis√£o do timing do M68K, essencial para emula√ß√£o fiel do Mega Drive.
Integra√ß√£o com Subsistema de √Åudio: Desenvolver a integra√ß√£o entre o M68K e o subsistema de √°udio conforme detalhado em AUDIO.md.
Testes Mais Abrangentes: Expandir os testes unit√°rios para cobrir mais instru√ß√µes e casos de uso, incluindo integra√ß√£o com o subsistema de √°udio.
Implementa√ß√£o de Debugger: Adicionar recursos de depura√ß√£o mais avan√ßados para facilitar o desenvolvimento e testes.

## ------------------------------------------------------------------------------------------------------------------------- ##
### VOLTAR NO FUTURO
** pr√≥ximos passos 
## ------------------------------------------------------------------------------------------------------------------------- ##


8 bits (d√©cada de 1980)
Consoles:

Nintendo Entertainment System (NES) (1983): CPU 8-bit (MOS 6502).
Sega Master System (1985): CPU 8-bit (Zilog Z80).
Atari 7800 (1986): CPU 8-bit (Atari SALLY).
ColecoVision (1982): CPU 8-bit (Z80A), embora lan√ßado antes da "era 8 bits" cl√°ssica.
Handhelds:

Game Boy (1989): CPU 8-bit (Sharp LR35902).
Atari Lynx (1989): CPU 8-bit (custom), mas com gr√°ficos de 16-bit.
Sega Game Gear (1990): CPU 8-bit (Z80).
16 bits (in√≠cio-meados da d√©cada de 1990)
Consoles:

Sega Genesis/Mega Drive (1988): CPU 16-bit (Motorola 68000).
Super Nintendo (SNES) (1990): CPU 16-bit (Ricoh 5A22, baseado no 65816).
NEC PC Engine/TurboGrafx-16 (1987): CPU 8-bit (HuC6280), mas com gr√°ficos de 16-bit (marketing como 16-bit).
Neo Geo AES (1990): CPU 16-bit (Motorola 68000) + co-processador.
Handhelds:

Game Boy Color (1998): Tecnicamente uma evolu√ß√£o do Game Boy (8-bit), mas com cores e melhorias.
32 bits (meados-fim da d√©cada de 1990)
Consoles:

Sony PlayStation (1994): CPU 32-bit (MIPS R3000).
Sega Saturn (1994): Dois CPUs 32-bit (Hitachi SH-2).
Atari Jaguar (1993): Marketing como "64-bit", mas arquitetura h√≠brida (dois chips 32-bit + GPU 64-bit).
3DO Interactive Multiplayer (1993): CPU 32-bit (ARM60).
Handhelds:

Nenhum handheld de 32-bit relevante nesta √©poca.
64 bits (final da d√©cada de 1990)
Consoles:

Nintendo 64 (1996): CPU 64-bit (NEC VR4300).
Sega Dreamcast (1998): CPU 128-bit (Hitachi SH-4), mas frequentemente associado √† transi√ß√£o para o 128-bit.
Handhelds:

Nenhum handheld de 64-bit nesta √©poca.

8 bits (D√©cada de 1980)
Perif√©ricos:

Famicom Disk System (1986, Jap√£o):
Adicionava suporte a disquetes para o NES/Famicom.
Tecnologia de 8 bits, mas com armazenamento maior que os cartuchos.
16 bits (In√≠cio-meados dos anos 1990)
Perif√©ricos:

Sega CD (Mega-CD) (1991):
Add-on para o Sega Genesis/Mega Drive.
Inclu√≠a um processador 16-bit adicional (Motorola 68000) e suporte a CDs.
Tentativa de competir com o CD-i da Philips.
Sega 32X (1994):
Add-on para o Genesis/Mega Drive, marketado como 32-bit .
Dois processadores SH-2 (32-bit), mas compatibilidade limitada e fracasso comercial.
Super Game Boy (1994):
Permitia jogar games do Game Boy no Super Nintendo.
N√£o alterava a arquitetura do SNES (16-bit), mas adicionava cores aos jogos monocrom√°ticos.
TurboGrafx-CD (1988):
Add-on de CD-ROM para o TurboGrafx-16.
Mantinha a CPU 8-bit do console base, mas ampliava o armazenamento.
32 bits (Meado-fim dos anos 1990)
Perif√©ricos:

Atari Jaguar CD (1995):
Add-on de CD-ROM para o Atari Jaguar (que j√° era marketado como "64-bit").
Ampliava a capacidade de armazenamento, mas o console teve baixa ado√ß√£o.
Nintendo 64DD (1999, Jap√£o):
Drive de disco magn√©tico para o Nintendo 64.
Tecnologia de 64-bit (compat√≠vel com o N64), mas foi um fracasso comercial e restrito ao Jap√£o.
64 bits (Final dos anos 1990)
Perif√©ricos:

Dreamcast (Visual Memory Unit - VMU) :
Embora n√£o seja um add-on de "bits", o VMU era um perif√©rico inovador (mem√≥ria + tela LCD).
O Dreamcast em si usava um CPU 128-bit (SH-4), mas n√£o houve add-ons significativos para ele.
Notas sobre os Perif√©ricos:
Sega 32X :
Tentativa frustrada de modernizar o Genesis, prejudicada por falta de jogos e confus√£o no mercado.
Muitos usu√°rios optaram por migrar direto para o Sega Saturn.
Nintendo 64DD :
Prometia jogos expansivos (como Mother 3 ), mas apenas 9 games foram lan√ßados.
Substitu√≠do pelo sucesso do GameCube.
CD-ROMs :
Perif√©ricos como Sega CD e Atari Jaguar CD tentaram capitalizar a popularidade dos CDs, mas a baixa qualidade dos jogos e os altos custos limitaram seu impacto.

## ------------------------------------------------------------------------------------------------------------------------- ##
### VOLTAR NO FUTURO
** pr√≥ximos passos 
## ------------------------------------------------------------------------------------------------------------------------- ##

quero que fa√ßa um investiga√ß√£o mais minuciosa arquivo por aquivo c√≥digo por c√≥digo a partir do diret√≥irio raiz deste projeto e volte a ver se n√£o tem outros aquivos que precisam de Limpeza e Organiza√ß√£o, a partir do diagnostico fazer 

Remo√ß√£o de Arquivos Incorretos
reavaliar se n√£o temos estruturas quebradas especialmente CMakeLists.txt
verificar integridade do c√≥digo ap√≥s remo√ß√µes usando ferramentas de lint/compila√ß√£o


## ------------------------------------------------------------------------------------------------------------------------- ##
### VOLTAR NO FUTURO
** pr√≥ximos passos 
## ------------------------------------------------------------------------------------------------------------------------- ##


Plano Detalhado para Reestrutura√ß√£o do Projeto Mega_Emu
Fase 1: Limpeza e Organiza√ß√£o
1.1 Remo√ß√£o de Arquivos Incorretos
Remover todos os diret√≥rios e arquivos listados na se√ß√£o "Arquivos a Remover"
Restaurar vers√µes originais de arquivos modificados (especialmente CMakeLists.txt)
Verificar integridade do c√≥digo ap√≥s remo√ß√µes usando ferramentas de lint/compila√ß√£o
1.2 Auditoria da Estrutura Atual
Verificar o estado atual de cada componente (NES, Mega Drive, Master System)
Documentar interfaces existentes entre componentes
Mapear depend√™ncias atuais entre m√≥dulos
Fase 2: Defini√ß√£o da Arquitetura
2.1 Estabelecimento de Princ√≠pios Arquiteturais
Separa√ß√£o Clara de Responsabilidades:
core/: Interfaces gen√©ricas e servi√ßos compartilhados (n√£o espec√≠ficos de plataforma)
platforms/: Implementa√ß√µes espec√≠ficas por console
utils/: Utilit√°rios independentes de plataforma
frontend/: Interface com usu√°rio e renderiza√ß√£o
Princ√≠pios de Design:
Invers√£o de depend√™ncia: Componentes de alto n√≠vel n√£o dependem de implementa√ß√µes
Interface √∫nica: APIs consistentes para funcionalidades similares
Substituibilidade: Componentes devem ser substitu√≠veis sem alterar o sistema
2.2 Documenta√ß√£o da Arquitetura
Criar diagramas de componentes e depend√™ncias
Documentar fluxos de dados e controle
Definir interfaces formais entre subsistemas
Fase 3: Implementa√ß√£o do Z80
3.1 Estrat√©gia para o Z80
Abordagem da Base Comum:
Implementar biblioteca base do Z80 em utils/cpu/z80/
Biblioteca cont√©m funcionalidades compartilhadas:
Decodifica√ß√£o de instru√ß√µes
Emula√ß√£o do conjunto de instru√ß√µes
Gerenciamento de registradores
Fun√ß√µes de timing e ciclos
Adaptadores Espec√≠ficos de Plataforma:
platforms/megadrive/cpu/z80_adapter.c: Interface para Z80 no Mega Drive
platforms/master_system/cpu/z80_adapter.c: Interface para Z80 no Master System
Cada adaptador configura interrup√ß√µes, mapeamento de mem√≥ria e timing espec√≠ficos
3.2 Implementa√ß√£o Detalhada do Z80
Criar conjunto completo de instru√ß√µes Z80 na biblioteca base
Implementar modos de interrup√ß√£o (0, 1, 2)
Adicionar suporte a instru√ß√µes indexadas (IX/IY)
Implementar instru√ß√µes de bit (BIT, SET, RES)
Desenvolver sistema de timing preciso
Fase 4: Arquitetura Dual de CPUs para Mega Drive
4.1 Comunica√ß√£o entre M68K e Z80
Implementar controlador em platforms/megadrive/integration/dual_cpu_controller.c
Fun√ß√µes claras para:
Solicita√ß√£o/libera√ß√£o do barramento Z80
Reset do Z80
Mudan√ßa de bancos de mem√≥ria (bank switching)
Sincroniza√ß√£o entre processadores
4.2 Mapeamento de Mem√≥ria
Definir esquema completo de mapeamento de mem√≥ria em platforms/megadrive/memory/memory_map.c
Implementar espa√ßo compartilhado entre M68K e Z80
Configurar banco de mem√≥ria para Z80 acessar mem√≥ria principal
Fase 5: Implementa√ß√£o do Master System
5.1 Estrutura do Master System
Organizar em:
platforms/master_system/cpu/: Adaptador Z80
platforms/master_system/vdp/: Implementa√ß√£o do TMS9918A
platforms/master_system/psg/: Implementa√ß√£o do SN76489
platforms/master_system/memory/: Controlador de mem√≥ria
platforms/master_system/system/: Integra√ß√£o de componentes
5.2 Implementa√ß√£o do VDP e PSG
Implementar VDP (TMS9918A) com suporte a todos os modos
Criar PSG (SN76489) com emula√ß√£o precisa
Integrar com o Z80 atrav√©s de portas de E/S
Fase 6: Sistema de Testes Unificado
6.1 Estrutura de Testes
Organizar testes em:
tests/utils/: Testes para utilit√°rios compartilhados
tests/platforms/{platform}/: Testes espec√≠ficos por plataforma
tests/integration/: Testes de integra√ß√£o entre componentes
6.2 Implementa√ß√£o de Testes
Criar testes para biblioteca base do Z80
Desenvolver testes espec√≠ficos para adaptadores Z80 (Mega Drive e Master System)
Implementar testes de integra√ß√£o para comunica√ß√£o entre M68K e Z80
Estabelecer testes de regress√£o para ROMs conhecidas
Fase 7: Conven√ß√µes e Padr√µes
7.1 Conven√ß√µes de Nomenclatura
Prefixos de Fun√ß√£o:
core_: Para funcionalidades do n√∫cleo gen√©rico
md_: Para Mega Drive
ms_: Para Master System
nes_: Para NES
z80_: Para CPU Z80 base
m68k_: Para CPU M68000
Nomenclatura de Arquivos:
Subsistema_componente.c (ex: md_vdp.c, z80_instructions.c)
Interfaces em arquivos separados (ex: md_vdp_interface.h)
7.2 Documenta√ß√£o de API
Definir formato Doxygen consistente para todas as fun√ß√µes
Documentar par√¢metros, retornos e efeitos colaterais
Incluir exemplos de uso para APIs complexas
Fase 8: Ferramentas de Desenvolvimento
8.1 Ferramentas de Depura√ß√£o
Implementar visualizadores para:
Registradores de CPU
Estado de mem√≥ria
Padr√µes de v√≠deo
Formas de onda de √°udio
Criar breakpoints e watchpoints configur√°veis
8.2 Ferramentas de Desenvolvimento de Jogos
Desenvolver montadores (assemblers) para Z80 e M68K
Criar ambiente de teste simplificado para ROMs em desenvolvimento
Implementar analisadores de desempenho
Fase 9: Sistema de Expans√£o para Plataformas Futuras
9.1 Frameworks de Extens√£o
Criar sistema de plugins para adi√ß√£o de novas plataformas
Definir interfaces claras para integra√ß√£o:
Interface de CPU (core/cpu_interface.h)
Interface de v√≠deo (core/video_interface.h)
Interface de √°udio (core/audio_interface.h)
Interface de controle (core/input_interface.h)
9.2 Documenta√ß√£o para Expans√£o
Criar guias detalhados para adi√ß√£o de novas plataformas
Documentar processo de integra√ß√£o com o frontend
Estabelecer padr√µes de qualidade e testes necess√°rios
Fase 10: Integra√ß√£o e Valida√ß√£o
10.1 Integra√ß√£o Cont√≠nua
Configurar pipeline de CI/CD para:
Compila√ß√£o em m√∫ltiplas plataformas
Execu√ß√£o autom√°tica de testes
Verifica√ß√£o de cobertura de c√≥digo
An√°lise est√°tica de c√≥digo
10.2 Valida√ß√£o com ROMs Comerciais
Criar suite de testes com ROMs comerciais conhecidas
Implementar testes de compatibilidade automatizados
Documentar n√≠vel de compatibilidade por plataforma
Cronograma de Implementa√ß√£o
Fase 1-2: 2-3 semanas (limpeza e arquitetura)
Fase 3-5: 6-8 semanas (implementa√ß√£o de Z80 e sistemas)
Fase 6-7: 3-4 semanas (testes e padroniza√ß√£o)
Fase 8-10: 5-6 semanas (ferramentas e valida√ß√£o)
Este plano estabelece uma abordagem estruturada para resolver os problemas atuais, mantendo a coer√™ncia e modularidade do projeto, e estabelecendo uma base s√≥lida para expans√µes futuras

Reestrutura√ß√£o do Z80 para uma arquitetura modular:
Cria√ß√£o de uma biblioteca base do Z80 (src/core/cpu/z80/) que cont√©m a implementa√ß√£o principal.
Implementa√ß√£o de adaptadores espec√≠ficos para Mega Drive e Master System.
Arquivos criados:
src/core/cpu/z80/z80.h e z80.c: Implementa√ß√£o base do Z80.
src/core/cpu/z80/z80_instructions.h e z80_instructions.c: Implementa√ß√£o das instru√ß√µes do Z80.
src/platforms/megadrive/cpu/z80_adapter.h e z80_adapter.c: Adaptador para o Mega Drive.
src/platforms/mastersystem/cpu/z80_adapter.h e z80_adapter.c: Adaptador para o Master System.
src/core/cpu/z80/CMakeLists.txt: Configura√ß√£o de compila√ß√£o para a biblioteca base.
Arquivos modificados:
src/platforms/megadrive/megadrive.c: Integra√ß√£o com o novo adaptador Z80.
src/platforms/mastersystem/mastersystem.c: Integra√ß√£o com o novo adaptador Z80.
src/platforms/megadrive/cpu/CMakeLists.txt: Inclus√£o dos novos arquivos.
src/platforms/mastersystem/cpu/CMakeLists.txt: Inclus√£o dos novos arquivos.
docs/Z80.md: Atualiza√ß√£o da documenta√ß√£o para refletir a nova arquitetura.
docs/AI_MEMORIA.md: Adi√ß√£o de um registro sobre a reestrutura√ß√£o.
docs/VERSION.md: Atualiza√ß√£o para vers√£o 1.2.5.
Essa reestrutura√ß√£o fornece v√°rias vantagens:
Reuso de c√≥digo: A implementa√ß√£o base do Z80 √© compartilhada entre Mega Drive e Master System.
Manutenibilidade: Modifica√ß√µes nas instru√ß√µes ou na l√≥gica interna do Z80 s√£o feitas em um √∫nico lugar.
Flexibilidade: Cada plataforma pode implementar seu pr√≥prio adaptador para lidar com suas especificidades.
Extensibilidade: Facilita a adi√ß√£o de suporte a novas plataformas que tamb√©m usam o Z80.
Os pr√≥ximos passos incluem a implementa√ß√£o completa das instru√ß√µes do Z80, cria√ß√£o de testes unit√°rios e melhorias de performance.
Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir.

Plano de reestrutura√ß√£o do Z80 conclu√≠do com sucesso! Agora temos:
Uma biblioteca core Z80 compartilhada em src/core/cpu/z80/
Adaptadores espec√≠ficos para Mega Drive e Master System
Arquivos obsoletos removidos
CMakeLists atualizados em todos os n√≠veis
Testes unit√°rios implementados
Documenta√ß√£o completa com guia de migra√ß√£o
A nova arquitetura modular permite:
Reutiliza√ß√£o de c√≥digo entre plataformas
Manuten√ß√£o simplificada
Extensibilidade para adicionar suporte a novas plataformas
Pr√≥ximos passos incluem completar a implementa√ß√£o das instru√ß√µes, melhorar a cobertura de testes e otimizar o desempenho. A documenta√ß√£o foi atualizada com o registro desta atividade no AI_MEMORIA.md.




Plano de Revis√£o e Organiza√ß√£o do Projeto Mega_Emu
1. Revis√£o do Sistema de Compila√ß√£o
1.1 Estrutura de CMake Principal
Vamos revisar e atualizar o CMakeLists.txt principal para definir corretamente as op√ß√µes de compila√ß√£o:
Apply to ms-vscode.cp...
1.2 Estrutura de CMake para src/
Revis√£o do CMakeLists.txt em src/:
Apply to ms-vscode.cp...
1.3 Estrutura de CMake para src/platforms/
Revis√£o do CMakeLists.txt em src/platforms/:
Apply to ms-vscode.cp...
2. Diretrizes para Componentes Comuns
2.1 Estrutura de Diret√≥rios Padr√£o
Para cada plataforma, estabelecer a seguinte estrutura de diret√≥rios:
Apply to ms-vscode.cp...
2.2 Adaptadores de CPU
Para garantir consist√™ncia em CPUs compartilhadas (como o Z80):
Apply to ms-vscode.cp...
2.3 Componentes de N√∫cleo (Core)
Expandir o diret√≥rio src/core/ para incluir componentes compartilhados:
Apply to ms-vscode.cp...
3. Atualiza√ß√µes na Documenta√ß√£o
3.1 README.md
Atualizar o README.md para incluir:
Lista completa de plataformas suportadas (atuais e planejadas)
Informa√ß√£o sobre perif√©ricos
Instru√ß√µes de compila√ß√£o para diferentes configura√ß√µes
Requisitos de sistema atualizados
3.2 AI_ESCOPO.md
Atualizar para incluir:
Escopo expandido de plataformas
Categoriza√ß√£o por gera√ß√µes (8-bit, 16-bit, 32-bit, etc.)
Cronograma geral de implementa√ß√£o
Requisitos espec√≠ficos para cada plataforma
3.3 AI_GUIDELINE.md
Atualizar para incluir:
Diretrizes para implementa√ß√£o de novas plataformas
Padr√µes para compartilhamento de c√≥digo entre plataformas similares
Regras para implementa√ß√£o de perif√©ricos
Diretrizes de testing para novas plataformas
3.4 ARCHITECTURE.md
Atualizar para incluir:
Diagrama de arquitetura expandido
Descri√ß√µes de todas as CPUs planejadas
Modelos de mem√≥ria para diferentes plataformas
Integra√ß√£o entre core e plataformas espec√≠ficas
3.5 CODING_STANDARDS.md
Atualizar para incluir:
Padr√µes espec√≠ficos para implementa√ß√£o de adaptadores
Regras de nomenclatura para componentes de plataformas
Diretrizes para otimiza√ß√£o
Padr√µes para testes de plataformas espec√≠ficas
3.6 ROADMAP.md
Atualizar para incluir:
Roadmap detalhado por plataforma
Implementa√ß√£o por fases para cada plataforma
Depend√™ncias entre implementa√ß√µes
Marcos e prazos espec√≠ficos para cada plataforma
4. Implementa√ß√£o Pr√°tica
4.1 Prepara√ß√£o do Diret√≥rio SNES
Criar a estrutura inicial para o SNES:
Apply to ms-vscode.cp...
4.2 Estrutura para Perif√©ricos
Criar a estrutura para perif√©ricos principais:
Apply to ms-vscode.cp...
4.3 Cria√ß√£o de Arquivos de Configura√ß√£o Comuns
Criar arquivos de configura√ß√£o gen√©ricos para todas as plataformas:
Apply to ms-vscode.cp...
5. Ferramentas de Verifica√ß√£o
5.1 Scripts de Valida√ß√£o
Criar scripts para validar a estrutura do projeto:
Apply to ms-vscode.cp...
Run
5.2 Script de Compila√ß√£o Condicional
Criar script para testar diferentes configura√ß√µes de compila√ß√£o:
Apply to ms-vscode.cp...
Run
Atualiza√ß√µes Espec√≠ficas para @ROADMAP.md (Detalhado)
Para melhorar o ROADMAP.md e permitir que modelos trabalhem com contextos menores, vou estrutur√°-lo em se√ß√µes claramente definidas:
1. Vis√£o Geral por Gera√ß√£o
Organizar plataformas por gera√ß√£o (8-bit, 16-bit, 32-bit, 64-bit).
2. Cronogramas Independentes
Criar cronogramas separados para cada plataforma, com depend√™ncias expl√≠citas.
3. Metas Espec√≠ficas por Plataforma
Detalhar metas claras e espec√≠ficas para cada plataforma e perif√©rico.
4. Estrutura Modular
Criar uma estrutura que permita a um modelo entender uma se√ß√£o espec√≠fica sem precisar processar todo o documento.
5. Marcos e Checkpoints
Definir marcos claros e verific√°veis para cada implementa√ß√£o.
Seguindo este plano, garantiremos uma estrutura organizada que facilitar√° tanto o desenvolvimento atual quanto a expans√£o futura para novas plataformas.






























 Voc√™ √© um assistente de desenvolvimento para o PROJETO e especialista em automa√ß√£o de sistemas e script que DEVE:
1.  SEMPRE consultar e seguir @/docs/AI_GUIDELINE.md antes de qualquer a√ß√£o
2.  SEMPRE consultar @/docs/AI_MEMORIA.md para ter um contexto de atua√ß√£o recente no PROJETO
3.  SEMPRE consultar @/docs/@/docs/AI_ROADMAP.md para entender o plano de implementa√ß√£o e progresso  
4.  Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
5.  Registrar TODAS as a√ß√µes no formato de log especificado

‚úÖ
MEU COMANDO:
DEV:  avalie se a implementa√ß√£o do Motorola 68000 esta robusto para suportar o projeto como descrito em @ARCHITECTURE.md @M68000.md 

## üö®
CONTEXTO:

*   Manter rigidamente a estrutura do projeto conforme o @/docs/AI_GUIDELINES.md
*   Tamanho do c√≥digo: Limitar m√≥dulos a 400 linhas no m√°ximo
*   Para garantir consist√™ncia e qualidade no desenvolvimento, voc√™ deve seguir este fluxo de trabalho com os documentos de refer√™ncia:

*   1: Leia AI_ESCOPO.md para compreender o contexto geral e a arquitetura
*   2: Consulte @/docs/AI_ROADMAP.md para verificar a pr√≥xima tarefa planejada ou prioridades
*   3: Analise @/docs/AI_MEMORIA.md para conhecer solu√ß√µes anteriores e aprendizados
*   4: Siga as diretrizes de /docs/AI_GUIDELINE.md durante a implementa√ß√£o
*   5: Verifique @/docs/VERSION.md para entender mudan√ßas recentes e compatibilidade
*   voc√™ deve ser capaz de seguir as instru√ß√µes e realizar as tarefas sem ambiguidade.

## üìã
PROCESSO OBRIGAT√ìRIO:

1.  Consultar /docs/AI_GUIDELINES.md  e @/docs/AI_MEMORIA.md 
2.  Executar checklist pr√©-implementa√ß√£o
3.  Validar em todas as camadas
4.  Gerar log de auditoria
5.  Retornar resultado padronizado
6.  Confirme se deu certo e se poss√≠vel fa√ßa testes
7.	Lan√ße a aplica√ß√£o sempre que ela tiver os requisitos monimos de funcionamento e monitore por 30 segundos avaliando o comportamento e corrigindo inconsist√™ncias
7.  Avalie a necessidade de atualizar @/docs/VERSION.md para manter Hist√≥rico de vers√µes atualizado

## üîÑ VERIFICA√á√ÉO DE MEM√ìRIA

Ao finalizar qualquer tarefa, SEMPRE solicite:
1. A atualiza√ß√£o do @/docs/AI_MEMORIA.md com o registro da atividade atual
2. A verifica√ß√£o de que o formato segue o template padronizado
3. A inclus√£o de todas as tags relevantes para a atividade

EXEMPLO: "Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir."

## ‚úÖ ENTREG√ÅVEIS ESPERADOS
1. C√≥digo implementado seguindo os padr√µes do projeto
2. Atualiza√ß√£o do @/docs/AI_MEMORIA.md com detalhes da implementa√ß√£o
3. Testes com monitoramento sugeridos para validar as altera√ß√µes
4. Sugest√µes para atualiza√ß√£o de vers√£o (se aplic√°vel)

An√°lise da Implementa√ß√£o do Motorola 68000
Pontos Fortes
Estrutura modular bem definida seguindo o padr√£o do projeto
Separa√ß√£o clara entre implementa√ß√£o core e adaptadores espec√≠ficos de plataforma
Interface de callbacks para acesso √† mem√≥ria permitindo flexibilidade
Documenta√ß√£o detalhada dos registradores e modos de endere√ßamento
Suporte √†s tr√™s plataformas principais (Mega Drive, Neo Geo, Atari Jaguar)
Pontos de Aten√ß√£o
Estado atual indica que timing preciso por instru√ß√£o ainda est√° "Em Progresso"
Implementa√ß√£o completa de casos especiais para flags tamb√©m est√° pendente
Suporte a exce√ß√µes avan√ßadas ainda n√£o est√° finalizado
Aus√™ncia de desassemblador integrado completo
Recomenda√ß√µes
Priorizar a implementa√ß√£o do timing preciso por instru√ß√£o, cr√≠tico para emula√ß√£o correta
Completar os casos especiais para flags, essenciais para jogos que dependem de comportamento espec√≠fico
Implementar suporte completo a exce√ß√µes para garantir compatibilidade com jogos que as utilizam
Verificar se os m√≥dulos respeitam o limite de 400 linhas conforme guideline do projeto
Desenvolver testes de conformidade para validar comportamento contra hardware real
Conclus√£o
A implementa√ß√£o do M68000 tem base s√≥lida e estrutura bem organizada, mas precisa finalizar alguns componentes cr√≠ticos antes de ser considerada totalmente robusta. Recomendo focar nos itens "Em Progresso" e "Pendentes" listados na documenta√ß√£o antes de avan√ßar para implementa√ß√µes de novas plataformas.
rule_for_IA
SEMPRE consultar e seguir AI_GUIDELINES.md antes de qualquer a√ß√£o
Validar TODAS as solicita√ß√µes usando a matriz de valida√ß√£o definida
Registrar TODAS as a√ß√µes no formato de log especificado
PROCESSO OBRIGAT√ìRIO:
Consultar AI_GUIDELINES.md
Executar checklist pr√©-implementa√ß√£o
Validar em todas as camadas
Gerar log de auditoria
Retornar resultado padronizado
Confirme se deu certo e atualize ROADMAP.md
An√°lise da Implementa√ß√£o do Motorola 68000 no Mega_Emu
Resumo da Avalia√ß√£o
Baseado na documenta√ß√£o dispon√≠vel, a arquitetura proposta para o M68000 apresenta uma estrutura robusta e bem planejada, mas ainda n√£o foi implementada completamente no c√≥digo-fonte atual. Os diret√≥rios do projeto est√£o criados conforme a arquitetura, mas o diret√≥rio espec√≠fico do M68000 (src/core/cpu/m68k/) ainda n√£o existe na base de c√≥digo.
Estado Atual
‚úÖ Arquitetura bem definida na documenta√ß√£o
‚úÖ Estrutura de diret√≥rios principal estabelecida
‚úÖ Interface clara para integra√ß√£o com outras plataformas
‚ùå Implementa√ß√£o real do c√≥digo n√£o encontrada
‚ùå Diret√≥rio src/core/cpu/m68k/ n√£o existe
Pr√≥ximos Passos Recomendados
Criar estrutura de diret√≥rios para o M68000:
src/core/cpu/m68k/
Arquivos b√°sicos conforme documenta√ß√£o
Implementar os componentes na seguinte ordem:
Estrutura base e API (m68k.h, m68k.c)
Decodifica√ß√£o de instru√ß√µes b√°sicas
Modos de endere√ßamento
Instru√ß√µes essenciais
Sistema de interrup√ß√µes
Adaptadores para Mega Drive
Iniciar com um conjunto m√≠nimo de instru√ß√µes que permita executar c√≥digo simples
Realizar testes progressivos durante a implementa√ß√£o
Valida√ß√£o T√©cnica
A arquitetura proposta est√° alinhada com os padr√µes do projeto
O padr√£o de adaptadores permite reutiliza√ß√£o nas diferentes plataformas
O sistema de callbacks para acesso √† mem√≥ria √© flex√≠vel e adequado
O limite de 400 linhas por arquivo dever√° ser respeitado na implementa√ß√£o
Matriz de Valida√ß√£o
| Crit√©rio | Status | Observa√ß√£o |
|----------|--------|------------|
| Ader√™ncia √† Arquitetura | ‚úÖ | Bem definida na documenta√ß√£o |
| Modularidade | ‚úÖ | Separa√ß√£o clara entre core e adaptadores |
| Reutiliza√ß√£o | ‚úÖ | Permite uso em diferentes plataformas |
| Implementa√ß√£o Atual | ‚ùå | N√£o encontrada no c√≥digo fonte |
| Cobertura de recursos | ‚ö†Ô∏è | Completo na documenta√ß√£o, n√£o implementado |
| Limite de 400 linhas | N/A | Ainda n√£o implementado |
Sugiro iniciar a implementa√ß√£o seguindo a documenta√ß√£o existente, com foco inicial no Mega Drive como plataforma priorit√°ria para testes.
Recomendo a implementa√ß√£o seguinte para iniciar o desenvolvimento do M68000, come√ßando pelos arquivos de cabe√ßalho b√°sicos.
Agora vamos criar o arquivo de implementa√ß√£o interna:
Agora, vamos criar um arquivo para a implementa√ß√£o principal do M68000:
Agora, vamos criar o arquivo para declara√ß√µes de instru√ß√µes:
Agora, vamos implementar uma vers√£o b√°sica inicial do arquivo de desassemblagem:
Por fim, vamos criar um arquivo de implementa√ß√£o minimal para o adaptador do Mega Drive:
Relat√≥rio Final da Implementa√ß√£o do Motorola 68000
An√°lise da Implementa√ß√£o
Ap√≥s avaliar o estado inicial do projeto e a documenta√ß√£o dispon√≠vel, foi implementada uma estrutura b√°sica para o processador Motorola 68000 (M68K) que segue a arquitetura descrita na documenta√ß√£o. A implementa√ß√£o inclui:
Arquivos Core do M68000:
m68k.h - API p√∫blica do processador
m68k.c - Implementa√ß√£o principal do processador
m68k_internal.h - Estruturas e defini√ß√µes internas
m68k_instructions.h - Declara√ß√µes de fun√ß√µes para instru√ß√µes
m68k_disasm.h - Interface para desassemblagem
Adaptador para Mega Drive:
m68k_adapter.h - Interface do adaptador para Mega Drive
m68k_adapter.c - Implementa√ß√£o do adaptador para Mega Drive
Caracter√≠sticas Implementadas
Estrutura completa de registradores (D0-D7, A0-A7, PC, SR)
Callbacks para acesso √† mem√≥ria
Sistema de interrup√ß√µes
Fun√ß√µes base para execu√ß√£o de ciclos
Condi√ß√µes de teste para branching
Adaptador para integra√ß√£o com o Mega Drive
Pr√≥ximos Passos
A implementa√ß√£o atual fornece a estrutura b√°sica, mas ainda √© necess√°rio:
Implementar o arquivo m68k_instructions.c com o conjunto completo de instru√ß√µes
Completar o desassemblador no arquivo m68k_disasm.c
Implementar timing preciso por instru√ß√£o
Adicionar casos especiais para flags e exce√ß√µes
Implementar e testar adaptadores para Neo Geo e Atari Jaguar
Avalia√ß√£o de Robustez
A implementa√ß√£o segue os padr√µes do projeto com:
Modularidade claramente definida
Separa√ß√£o entre core e adaptadores espec√≠ficos
Sistema de callbacks flex√≠vel
Documenta√ß√£o completa em coment√°rios
Limite de 400 linhas por arquivo respeitado
No entanto, para ser considerada totalmente robusta para produ√ß√£o, a implementa√ß√£o atual precisaria de:
Conjunto completo de instru√ß√µes
Timing preciso por instru√ß√£o
Testes extensivos contra hardware real
Matriz de Valida√ß√£o Final
| Crit√©rio | Status | Observa√ß√£o |
|----------|--------|------------|
| Ader√™ncia √† Arquitetura | ‚úÖ | Implementa√ß√£o segue documenta√ß√£o |
| Modularidade | ‚úÖ | Separa√ß√£o clara entre core e adaptadores |
| Reutiliza√ß√£o | ‚úÖ | Permite uso em diferentes plataformas |
| Implementa√ß√£o Base | ‚úÖ | Estrutura principal implementada |
| Conjunto de Instru√ß√µes | ‚ùå | Pendente implementa√ß√£o completa |
| Timing Preciso | ‚ùå | Pendente implementa√ß√£o detalhada |
| Limite de 400 linhas | ‚úÖ | Todos os arquivos dentro do limite |
Esta implementa√ß√£o fornece uma base s√≥lida para o desenvolvimento completo do emulador do M68000, seguindo as diretrizes e a arquitetura definidas para o projeto Mega_Emu.
Por favor, registre esta atividade no @/docs/AI_MEMORIA.md seguindo o template padr√£o antes de concluir.








Para iniciar a implementa√ß√£o da plataforma Game Gear, sugiro o seguinte plano, focado em aproveitar a base j√° existente do Master System:

1. An√°lise da Documenta√ß√£o e Estrutura do Master System:

Revisar docs/AI_GUIDELINE.md e docs/AI_MEMORIA.md: J√° fizemos isso, mas √© importante ter as diretrizes e a mem√≥ria do projeto frescas na mente.
Revisar o c√≥digo do Master System: Analisar novamente os arquivos src/platforms/mastersystem/mastersystem.c e mastersystem.h para solidificar o entendimento da estrutura da plataforma e identificar os componentes principais.
2. Identifica√ß√£o das Especificidades do Game Gear:

Pesquisar e documentar as diferen√ßas entre Master System e Game Gear, focando em:
Resolu√ß√£o da tela (Game Gear √© menor: 160x144 vs 256x192).
Paleta de cores (Game Gear tem 4096 cores vs Master System 64).
√Åudio (Game Gear √© est√©reo, Master System mono).
Entrada (Game Gear tem layout de controle e bot√µes diferentes).
Mapa de mem√≥ria (diferen√ßas menores).
BIOS (Game Gear possui BIOS embutida).
3. Cria√ß√£o da Estrutura de Pastas para Game Gear:

Criar diret√≥rio src/platforms/gamegear: Para organizar os arquivos espec√≠ficos do Game Gear.
Reutilizar e adaptar componentes do Master System: Criar subdiret√≥rios dentro de src/platforms/gamegear (como cpu, video, audio, memory, input) e adaptar os componentes do Master System, criando novos arquivos (ex: gg_vdp.c, gg_psg.c, gg_memory.c, gg_input.c) que herdem ou adaptem a l√≥gica de sms_vdp.c, sms_psg.c, sms_memory.c e outros componentes do Master System. A CPU Z80 pode ser reutilizada diretamente.
4. Adapta√ß√£o dos Componentes do Master System:

CPU: Reutilizar o adaptador Z80 do Master System (src/platforms/mastersystem/cpu).
VDP: Adaptar o VDP do Master System (src/platforms/mastersystem/video/sms_vdp.c) para lidar com a resolu√ß√£o e paleta de cores do Game Gear.
PSG: Reutilizar a implementa√ß√£o do PSG SN76489 (src/platforms/mastersystem/audio/sms_psg.c), adaptando para sa√≠da est√©reo no Game Gear.
Mem√≥ria: Adaptar o mapa de mem√≥ria do Master System (src/platforms/mastersystem/memory/sms_memory.c) para o Game Gear.
Entrada: Criar um novo manipulador de entrada (src/platforms/gamegear/input/gg_input.c) para gerenciar as entradas espec√≠ficas do controle do Game Gear.
5. Cria√ß√£o do N√∫cleo da Plataforma Game Gear:

Criar src/platforms/gamegear/gamegear.c e gamegear.h: De forma similar a mastersystem.c e mastersystem.h, integrando os componentes adaptados e definindo a estrutura principal da plataforma Game Gear.
6. Atualiza√ß√£o do Sistema de Build:

Modificar CMakeLists.txt: Para incluir a nova plataforma Game Gear e seus componentes no processo de build.
7. Implementa√ß√£o do Carregamento da BIOS:

Adicionar c√≥digo para carregar e executar a BIOS do Game Gear.
8. Implementa√ß√£o de Save States:

Adaptar o sistema de save states do Master System para o Game Gear, garantindo a compatibilidade e lidando com qualquer estado espec√≠fico do Game Gear.
9. Testes e Valida√ß√£o:

Implementar testes unit√°rios e de integra√ß√£o para validar a implementa√ß√£o do Game Gear, focando nas diferen√ßas em rela√ß√£o ao Master System.
Realizar testes de compatibilidade com ROMs de Game Gear.
10. Documenta√ß√£o:

Documentar a implementa√ß√£o do Game Gear, destacando as diferen√ßas e adapta√ß√µes em rela√ß√£o ao Master System.
Este plano visa uma implementa√ß√£o eficiente do Game Gear, reutilizando ao m√°ximo o c√≥digo do Master System e focando nas diferen√ßas espec√≠ficas da plataforma port√°til.








Vou fazer um resumo das principais a√ß√µes e objetivos que estamos trabalhando:
Implementa√ß√£o do Mapper 1 (MMC1):
Criamos o arquivo mapper1.c com a implementa√ß√£o completa do MMC1
Adicionamos suporte para at√© 512KB de PRG ROM e 256KB de CHR ROM/RAM
Implementamos fun√ß√µes de leitura/escrita para CPU e PPU
Inclu√≠mos gerenciamento do shift register para escritas seriais
Integra√ß√£o do Mapper no Sistema:
Atualizamos o CMakeLists.txt para incluir o mapper1.c
Registramos o Mapper 1 no sistema de mappers do NES
Adicionamos os prot√≥tipos das fun√ß√µes de inicializa√ß√£o
Sistema de Build:
Tornamos o SDL2 opcional para permitir compila√ß√£o sem recursos gr√°ficos/√°udio
Reorganizamos a estrutura do CMake para melhor modularidade
Separamos os testes em um m√≥dulo opcional (BUILD_TESTS)
Pr√≥ximos Passos Sugeridos:
Implementar testes espec√≠ficos para o Mapper 1
Verificar a integra√ß√£o com o sistema de mem√≥ria do NES
Testar com ROMs que utilizam o MMC1
Implementar suporte para save states no Mapper 1
Problemas Pendentes:
Resolver quest√µes com arquivos base da plataforma (platform_base.c)
Finalizar a configura√ß√£o do sistema de build sem depend√™ncias opcionais
Verificar e corrigir problemas com alvos duplicados no CMake
Este resumo pode ser usado como ponto de partida para continuar o desenvolvimento em um novo chat, mantendo o foco nas tarefas principais.





campos x, y, w e h, mas os erros indicam que o c√≥digo est√° tentando acessar width e height.


no processo tivemos alertas de v√°rias vers√µes do arquivos preciso que valide a rota completa de copila√ß√£o e deixe esta estrutrua sem ambiguidades limpando tudo que for obsoleto 

tamb√©m precisamos organiza as estruturas de /build e /deps

em /build veja se √© possivel organizar em test, temp, emulators ( para copila√ß√µes somente de emuladores do projeto ), Mega_tools, ( para copila√ß√µes somente de Tools do projeto Mega_Emu )

