/** * @file platform_compat.h * @brief Definições para compatibilidade entre plataformas * * Este arquivo contém definições, macros e funções utilitárias para * garantir a compatibilidade do código entre diferentes plataformas. */#ifndef EMU_PLATFORM_COMPAT_H#define EMU_PLATFORM_COMPAT_H#include <stdint.h>#include <stdbool.h>#ifdef __cplusplusextern "C"{#endif/* Detecção de plataforma */#if defined(_WIN32) || defined(_WIN64)#define EMU_PLATFORM_WINDOWS 1#elif defined(__linux__)#define EMU_PLATFORM_LINUX 1#elif defined(__APPLE__) && defined(__MACH__)#define EMU_PLATFORM_MACOS 1#else#define EMU_PLATFORM_UNKNOWN 1#endif/* Definições específicas para Windows */#if defined(EMU_PLATFORM_WINDOWS)#include <windows.h>#define EMU_PATH_SEPARATOR '\\'/* Desabilitar avisos de segurança */#ifndef _CRT_SECURE_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#endif/* Definir funções de sleep portáveis */#define emu_sleep_ms(ms) Sleep(ms)/* Definir funções de cópia de string portáveis */#define emu_strcpy(dest, destsize, src) strcpy_s((dest), (destsize), (src))    /* Funções de carregamento dinâmico */    typedef HMODULE emu_module_handle_t;#define emu_load_library(path) LoadLibraryA(path)#define emu_free_library(handle) FreeLibrary(handle)#define emu_get_proc_address(handle, name) GetProcAddress(handle, name)/* Definições específicas para Linux */#elif defined(EMU_PLATFORM_LINUX)#include <unistd.h>#include <dlfcn.h>#define EMU_PATH_SEPARATOR '/'/* Definir funções de sleep portáveis */#define emu_sleep_ms(ms) usleep((ms) * 1000)/* Definir funções de cópia de string portáveis */#define emu_strcpy(dest, destsize, src) strncpy((dest), (src), (destsize))/* Funções de carregamento dinâmico */typedef void *emu_module_handle_t;#define emu_load_library(path) dlopen(path, RTLD_NOW)#define emu_free_library(handle) dlclose(handle)#define emu_get_proc_address(handle, name) dlsym(handle, name)/* Definições específicas para macOS */#elif defined(EMU_PLATFORM_MACOS)#include <unistd.h>#include <dlfcn.h>#define EMU_PATH_SEPARATOR '/'/* Definir funções de sleep portáveis */#define emu_sleep_ms(ms) usleep((ms) * 1000)/* Definir funções de cópia de string portáveis */#define emu_strcpy(dest, destsize, src) strncpy((dest), (src), (destsize))/* Funções de carregamento dinâmico */typedef void *emu_module_handle_t;#define emu_load_library(path) dlopen(path, RTLD_NOW)#define emu_free_library(handle) dlclose(handle)#define emu_get_proc_address(handle, name) dlsym(handle, name)/* Plataforma desconhecida */#else#define EMU_PATH_SEPARATOR '/'#define emu_sleep_ms(ms) /* não implementado */#define emu_strcpy(dest, destsize, src) strncpy((dest), (src), (destsize))typedef void *emu_module_handle_t;#define emu_load_library(path) NULL#define emu_free_library(handle)#define emu_get_proc_address(handle, name) NULL#endif    /* Estrutura de plataforma */    typedef struct    {        bool initialized;        const char *name;        const char *version;        const char *arch;        const char *os;        uint32_t flags;    } emu_platform_t;    /* Funções de plataforma */    bool emu_platform_init(emu_platform_t *platform);    void emu_platform_shutdown(emu_platform_t *platform);    bool emu_platform_is_supported(void);    const char *emu_platform_get_name(void);    const char *emu_platform_get_version(void);    const char *emu_platform_get_arch(void);    const char *emu_platform_get_os(void);    /**     * @brief Verifica se o sistema é little-endian     *     * @return true se o sistema for little-endian, false caso contrário     */    static inline bool emu_is_little_endian(void)    {        uint16_t value = 0x0001;        return *((uint8_t *)&value) == 0x01;    }    /**     * @brief Converte um valor de 16 bits de big-endian para o endianness do sistema     *     * @param value Valor de 16 bits em big-endian     * @return uint16_t Valor convertido para o endianness do sistema     */    static inline uint16_t emu_be16_to_host(uint16_t value)    {        if (emu_is_little_endian())        {            return ((value & 0xFF) << 8) | ((value & 0xFF00) >> 8);        }        return value;    }    /**     * @brief Converte um valor de 32 bits de big-endian para o endianness do sistema     *     * @param value Valor de 32 bits em big-endian     * @return uint32_t Valor convertido para o endianness do sistema     */    static inline uint32_t emu_be32_to_host(uint32_t value)    {        if (emu_is_little_endian())        {            return ((value & 0xFF) << 24) |                   ((value & 0xFF00) << 8) |                   ((value & 0xFF0000) >> 8) |                   ((value & 0xFF000000) >> 24);        }        return value;    }    /**     * @brief Converte um valor de 16 bits do endianness do sistema para big-endian     *     * @param value Valor de 16 bits no endianness do sistema     * @return uint16_t Valor convertido para big-endian     */    static inline uint16_t emu_host_to_be16(uint16_t value)    {        return emu_be16_to_host(value); // A operação é simétrica    }    /**     * @brief Converte um valor de 32 bits do endianness do sistema para big-endian     *     * @param value Valor de 32 bits no endianness do sistema     * @return uint32_t Valor convertido para big-endian     */    static inline uint32_t emu_host_to_be32(uint32_t value)    {        return emu_be32_to_host(value); // A operação é simétrica    }#ifdef __cplusplus}#endif#endif /* EMU_PLATFORM_COMPAT_H */