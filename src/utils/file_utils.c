/** * @file file_utils.c * @brief Implementação das funções utilitárias para manipulação de arquivos * @author Mega_Emu Team * @version 1.0.0 * @date 2024-07-25 */#include <stdio.h>#include <stdlib.h>#include <stdint.h>#include <string.h>#include "file_utils.h"#include "../utils/enhanced_log.h"#ifdef _WIN32#include <direct.h>#include <windows.h>#define mkdir(path, mode) _mkdir(path)#define PATH_SEPARATOR '\\'#else#include <sys/stat.h>#include <unistd.h>#include <dirent.h>#include <libgen.h>#define PATH_SEPARATOR '/'#endif/** * @brief Carrega um arquivo ROM para a memória * * @param filename Caminho do arquivo ROM * @param rom_data Ponteiro para onde o ponteiro do buffer será armazenado * @param rom_size Ponteiro para onde o tamanho do buffer será armazenado * @return 1 em caso de sucesso, 0 em caso de falha */int load_rom_file(const char *filename, uint8_t **rom_data, size_t *rom_size){    if (!filename || !rom_data || !rom_size)    {        printf("File Utils Error: Parâmetros inválidos para load_rom_file\n");        return 0;    }    // Inicializar valores de saída    *rom_data = NULL;    *rom_size = 0;    printf("File Utils: Carregando arquivo ROM: %s\n", filename);    // Abrir arquivo    FILE *file = fopen(filename, "rb");    if (!file)    {        printf("File Utils Error: Erro ao abrir arquivo: %s\n", filename);        return 0;    }    // Obter tamanho do arquivo    fseek(file, 0, SEEK_END);    long file_size = ftell(file);    fseek(file, 0, SEEK_SET);    // Verificar se o tamanho é válido    if (file_size <= 0)    {        printf("File Utils Error: Arquivo vazio ou inválido: %s\n", filename);        fclose(file);        return 0;    }    printf("File Utils: Tamanho do arquivo: %ld bytes\n", file_size);    // Alocar memória para os dados    uint8_t *buffer = (uint8_t *)malloc((size_t)file_size);    if (!buffer)    {        printf("File Utils Error: Erro ao alocar memória para arquivo: %s (Tamanho: %ld bytes)\n",               filename, file_size);        fclose(file);        return 0;    }    // Ler dados do arquivo    size_t bytes_read = fread(buffer, 1, (size_t)file_size, file);    fclose(file);    // Verificar se leitura foi completa    if (bytes_read != (size_t)file_size)    {        printf("File Utils Error: Erro ao ler arquivo: %s (Lidos: %zu de %ld bytes)\n",               filename, bytes_read, file_size);        free(buffer);        return 0;    }    printf("File Utils: Arquivo carregado com sucesso: %zu bytes\n", bytes_read);    // Atribuir valores de saída    *rom_data = buffer;    *rom_size = (size_t)file_size;    return 1;}/** * @brief Carrega um arquivo binário para a memória * * @param filename Nome do arquivo a ser carregado * @param size_out Ponteiro para armazenar o tamanho do arquivo carregado * @return Ponteiro para os dados carregados ou NULL em caso de erro */uint8_t *file_utils_load_binary(const char *filename, size_t *size_out){    EMU_LOG_INFO(EMU_CORE, "Carregando arquivo binário: %s (stub)", filename);    if (!filename || !size_out)    {        EMU_LOG_ERROR(EMU_CORE, "Parâmetros inválidos para carregar arquivo binário");        return NULL;    }    FILE *file = fopen(filename, "rb");    if (!file)    {        EMU_LOG_ERROR(EMU_CORE, "Não foi possível abrir o arquivo: %s", filename);        return NULL;    }    // Obter o tamanho do arquivo    fseek(file, 0, SEEK_END);    size_t file_size = ftell(file);    fseek(file, 0, SEEK_SET);    if (file_size == 0)    {        EMU_LOG_ERROR(EMU_CORE, "Arquivo vazio: %s", filename);        fclose(file);        return NULL;    }    // Alocar memória para os dados    uint8_t *data = (uint8_t *)malloc(file_size);    if (!data)    {        EMU_LOG_ERROR(EMU_CORE, "Falha ao alocar memória para o arquivo: %s", filename);        fclose(file);        return NULL;    }    // Ler os dados do arquivo    size_t bytes_read = fread(data, 1, file_size, file);    fclose(file);    if (bytes_read != file_size)    {        EMU_LOG_ERROR(EMU_CORE, "Erro ao ler o arquivo: %s (lidos %zu de %zu bytes)",                      filename, bytes_read, file_size);        free(data);        return NULL;    }    *size_out = file_size;    EMU_LOG_INFO(EMU_CORE, "ROM carregada: %s (%zu bytes)", filename, file_size);    return data;}bool emu_file_exists(const char *filename){    if (!filename)    {        EMU_LOG_ERROR(EMU_CORE, "Nome de arquivo inválido");        return false;    }    FILE *file = fopen(filename, "rb");    if (file)    {        fclose(file);        EMU_LOG_INFO(EMU_CORE, "Arquivo encontrado: %s", filename);        return true;    }    EMU_LOG_INFO(EMU_CORE, "Arquivo não encontrado: %s", filename);    return false;}size_t emu_file_size(const char *filename){    if (!filename)    {        EMU_LOG_ERROR(EMU_CORE, "Nome de arquivo inválido");        return 0;    }    FILE *file = fopen(filename, "rb");    if (!file)    {        EMU_LOG_ERROR(EMU_CORE, "Não foi possível abrir o arquivo: %s", filename);        return 0;    }    fseek(file, 0, SEEK_END);    size_t size = ftell(file);    fclose(file);    EMU_LOG_INFO(EMU_CORE, "Tamanho do arquivo %s: %zu bytes", filename, size);    return size;}bool emu_file_create_dir(const char *path){    if (!path)    {        EMU_LOG_ERROR(EMU_CORE, "Caminho inválido");        return false;    }    if (mkdir(path, 0755) == 0)    {        EMU_LOG_INFO(EMU_CORE, "Diretório criado: %s", path);        return true;    }    EMU_LOG_ERROR(EMU_CORE, "Erro ao criar diretório: %s", path);    return false;}char *emu_file_read_text(const char *filename){    if (!filename)    {        EMU_LOG_ERROR(EMU_CORE, "Nome de arquivo inválido");        return NULL;    }    FILE *file = fopen(filename, "r");    if (!file)    {        EMU_LOG_ERROR(EMU_CORE, "Não foi possível abrir o arquivo: %s", filename);        return NULL;    }    fseek(file, 0, SEEK_END);    long size = ftell(file);    rewind(file);    char *buffer = (char *)malloc(size + 1);    if (!buffer)    {        EMU_LOG_ERROR(EMU_CORE, "Erro de alocação de memória");        fclose(file);        return NULL;    }    size_t read_size = fread(buffer, 1, size, file);    buffer[read_size] = '\0';    fclose(file);    EMU_LOG_INFO(EMU_CORE, "Arquivo de texto lido: %s (%zu bytes)", filename, read_size);    return buffer;}bool emu_file_write_text(const char *filename, const char *text){    if (!filename || !text)    {        EMU_LOG_ERROR(EMU_CORE, "Parâmetros inválidos para escrita de arquivo");        return false;    }    FILE *file = fopen(filename, "w");    if (!file)    {        EMU_LOG_ERROR(EMU_CORE, "Não foi possível criar o arquivo: %s", filename);        return false;    }    size_t written = fputs(text, file);    fclose(file);    if (written == EOF)    {        EMU_LOG_ERROR(EMU_CORE, "Erro ao escrever no arquivo: %s", filename);        return false;    }    EMU_LOG_INFO(EMU_CORE, "Arquivo de texto escrito: %s (%zu bytes)", filename, written);    return true;}bool emu_file_get_info(const char *path, emu_file_info_t *info){    if (!path || !info)    {        EMU_LOG_ERROR(EMU_CORE, "Parâmetros inválidos para obter informações do arquivo");        return false;    }    FILE *file = fopen(path, "rb");    if (!file)    {        EMU_LOG_ERROR(EMU_CORE, "Não foi possível abrir o arquivo: %s", path);        return false;    }    fseek(file, 0, SEEK_END);    info->size = ftell(file);    fclose(file);    EMU_LOG_INFO(EMU_CORE, "Informações do arquivo %s: %zu bytes", path, info->size);    return true;}uint64_t emu_file_load_binary(const char *path, uint8_t *data, uint64_t size){    if (!path || !data || size == 0)    {        EMU_LOG_ERROR(EMU_CORE, "Parâmetros inválidos para carregar arquivo binário");        return 0;    }    FILE *file = fopen(path, "rb");    if (!file)    {        EMU_LOG_ERROR(EMU_CORE, "Não foi possível abrir o arquivo: %s", path);        return 0;    }    uint64_t bytes_read = fread(data, 1, size, file);    fclose(file);    if (bytes_read == 0)    {        EMU_LOG_ERROR(EMU_CORE, "Erro ao ler o arquivo: %s", path);        return 0;    }    EMU_LOG_INFO(EMU_CORE, "Arquivo binário carregado: %s (%llu bytes)", path, bytes_read);    return bytes_read;}bool emu_file_save_binary(const char *path, const uint8_t *data, uint64_t size){    if (!path || !data || size == 0)    {        EMU_LOG_ERROR(EMU_CORE, "Parâmetros inválidos para salvar arquivo binário");        return false;    }    FILE *file = fopen(path, "wb");    if (!file)    {        EMU_LOG_ERROR(EMU_CORE, "Não foi possível criar o arquivo: %s", path);        return false;    }    uint64_t bytes_written = fwrite(data, 1, size, file);    fclose(file);    if (bytes_written != size)    {        EMU_LOG_ERROR(EMU_CORE, "Erro ao escrever no arquivo: %s", path);        return false;    }    EMU_LOG_INFO(EMU_CORE, "Arquivo binário salvo: %s (%llu bytes)", path, bytes_written);    return true;}/** * @brief Verifica se um arquivo existe */bool file_exists(const char *path){    if (!path || path[0] == '\0')    {        return false;    }    FILE *file = fopen(path, "rb");    if (file)    {        fclose(file);        return true;    }    return false;}/** * @brief Obtém o tamanho de um arquivo */int64_t get_file_size(const char *path){    if (!path || path[0] == '\0')    {        return -1;    }    struct stat st;    if (stat(path, &st) == 0)    {        return (int64_t)st.st_size;    }    return -1;}/** * @brief Obtém a data de modificação de um arquivo */time_t get_file_modification_time(const char *path){    if (!path || path[0] == '\0')    {        return -1;    }    struct stat st;    if (stat(path, &st) == 0)    {        return st.st_mtime;    }    return -1;}/** * @brief Cria um diretório */bool create_directory(const char *path){    if (!path || path[0] == '\0')    {        return false;    }    // Verificar se o diretório já existe    struct stat st;    if (stat(path, &st) == 0)    {        // Já existe        if (S_ISDIR(st.st_mode))        {            return true;        }        // Existe mas não é um diretório        return false;    }    // Tentar criar o diretório#ifdef _WIN32    if (mkdir(path) == 0)    {        return true;    }#else    if (mkdir(path, 0755) == 0)    {        return true;    }#endif    EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao criar diretório: %s", path);    return false;}/** * @brief Cria diretórios recursivamente */bool create_directories(const char *path){    if (!path || path[0] == '\0')    {        return false;    }    char temp[MAX_PATH_LENGTH];    char *p = NULL;    size_t len;    strncpy(temp, path, sizeof(temp) - 1);    temp[sizeof(temp) - 1] = '\0';    len = strlen(temp);    // Remover barra no final, se houver    if (temp[len - 1] == '/' || temp[len - 1] == '\\')    {        temp[len - 1] = '\0';    }    // Tentar criar cada diretório no caminho    for (p = temp + 1; *p; p++)    {        if (*p == '/' || *p == '\\')        {            *p = '\0';            if (!create_directory(temp))            {                return false;            }            *p = PATH_SEPARATOR;        }    }    return create_directory(temp);}/** * @brief Exclui um arquivo */bool delete_file(const char *path){    if (!path || path[0] == '\0')    {        return false;    }    if (remove(path) == 0)    {        return true;    }    EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao excluir arquivo: %s", path);    return false;}/** * @brief Copia um arquivo */bool copy_file(const char *src_path, const char *dst_path){    if (!src_path || !dst_path || src_path[0] == '\0' || dst_path[0] == '\0')    {        return false;    }    FILE *src = fopen(src_path, "rb");    if (!src)    {        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao abrir arquivo fonte para cópia: %s", src_path);        return false;    }    FILE *dst = fopen(dst_path, "wb");    if (!dst)    {        fclose(src);        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao abrir arquivo destino para cópia: %s", dst_path);        return false;    }    // Copiar dados    char buffer[4096];    size_t bytes_read;    bool success = true;    while ((bytes_read = fread(buffer, 1, sizeof(buffer), src)) > 0)    {        if (fwrite(buffer, 1, bytes_read, dst) != bytes_read)        {            EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Erro ao escrever dados durante cópia de arquivo");            success = false;            break;        }    }    fclose(src);    fclose(dst);    return success;}/** * @brief Move um arquivo */bool move_file(const char *src_path, const char *dst_path){    if (!src_path || !dst_path || src_path[0] == '\0' || dst_path[0] == '\0')    {        return false;    }    // Tentar renomear (funciona apenas no mesmo sistema de arquivos)    if (rename(src_path, dst_path) == 0)    {        return true;    }    // Se falhar, tentar copiar e excluir    if (copy_file(src_path, dst_path))    {        if (delete_file(src_path))        {            return true;        }        // Se não conseguir excluir a origem, exclui o destino para evitar duplicatas        delete_file(dst_path);    }    EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao mover arquivo de %s para %s", src_path, dst_path);    return false;}/** * @brief Renomeia um arquivo */bool rename_file(const char *old_path, const char *new_path){    if (!old_path || !new_path || old_path[0] == '\0' || new_path[0] == '\0')    {        return false;    }    if (rename(old_path, new_path) == 0)    {        return true;    }    EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao renomear arquivo de %s para %s", old_path, new_path);    return false;}/** * @brief Lista os arquivos em um diretório */int list_directory_files(const char *dir_path, const char *extension,                         char **files, int max_files){    if (!dir_path || dir_path[0] == '\0' || !files || max_files <= 0)    {        return -1;    }    int count = 0;#ifdef _WIN32    // Implementação para Windows    WIN32_FIND_DATA find_data;    HANDLE find_handle;    char search_path[MAX_PATH_LENGTH];    // Criar caminho de busca    if (extension && extension[0] != '\0')    {        snprintf(search_path, sizeof(search_path), "%s\\*.%s", dir_path, extension);    }    else    {        snprintf(search_path, sizeof(search_path), "%s\\*", dir_path);    }    find_handle = FindFirstFile(search_path, &find_data);    if (find_handle == INVALID_HANDLE_VALUE)    {        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao listar diretório: %s", dir_path);        return -1;    }    do    {        // Ignorar "." e ".."        if (strcmp(find_data.cFileName, ".") == 0 || strcmp(find_data.cFileName, "..") == 0)        {            continue;        }        // Verificar se é um arquivo        if (!(find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))        {            if (count < max_files)            {                files[count] = strdup(find_data.cFileName);                count++;            }            else            {                // Atingiu o limite máximo                break;            }        }    } while (FindNextFile(find_handle, &find_data) != 0);    FindClose(find_handle);#else    // Implementação para POSIX (Linux, macOS, etc.)    DIR *dir;    struct dirent *entry;    dir = opendir(dir_path);    if (!dir)    {        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao abrir diretório: %s", dir_path);        return -1;    }    while ((entry = readdir(dir)) != NULL && count < max_files)    {        // Ignorar "." e ".."        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)        {            continue;        }        // Verificar extensão se especificada        if (extension && extension[0] != '\0')        {            const char *file_ext = strrchr(entry->d_name, '.');            if (!file_ext || strcmp(file_ext + 1, extension) != 0)            {                continue;            }        }        // Verificar se é um arquivo (não um diretório)        char full_path[MAX_PATH_LENGTH];        struct stat st;        snprintf(full_path, sizeof(full_path), "%s/%s", dir_path, entry->d_name);        if (stat(full_path, &st) == 0 && S_ISREG(st.st_mode))        {            files[count] = strdup(entry->d_name);            count++;        }    }    closedir(dir);#endif    return count;}/** * @brief Obtém o diretório base do executável */bool get_executable_directory(char *buffer, size_t buffer_size){    if (!buffer || buffer_size <= 0)    {        return false;    }#ifdef _WIN32    // Implementação para Windows    HMODULE hModule = GetModuleHandle(NULL);    if (hModule)    {        DWORD result = GetModuleFileName(hModule, buffer, (DWORD)buffer_size);        if (result > 0 && result < buffer_size)        {            // Remover o nome do arquivo para obter apenas o diretório            char *last_slash = strrchr(buffer, '\\');            if (last_slash)            {                *last_slash = '\0';                return true;            }        }    }#else    // Implementação para POSIX (Linux, macOS, etc.)    if (readlink("/proc/self/exe", buffer, buffer_size) != -1)    {        // Remover o nome do arquivo para obter apenas o diretório        char *last_slash = strrchr(buffer, '/');        if (last_slash)        {            *last_slash = '\0';            return true;        }    }#endif    EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao obter diretório do executável");    return false;}/** * @brief Obtém o caminho completo de um arquivo */bool get_full_path(const char *relative_path, char *full_path, size_t full_path_size){    if (!relative_path || !full_path || full_path_size <= 0)    {        return false;    }    // Se já for um caminho absoluto, apenas copiar    if (relative_path[0] == '/' ||        (relative_path[0] != '\0' && relative_path[1] == ':'))    {        strncpy(full_path, relative_path, full_path_size - 1);        full_path[full_path_size - 1] = '\0';        return true;    }    // Obter diretório base    if (!get_executable_directory(full_path, full_path_size))    {        return false;    }    // Adicionar barra se necessário    size_t base_len = strlen(full_path);    if (base_len > 0 && full_path[base_len - 1] != '/' && full_path[base_len - 1] != '\\')    {        full_path[base_len] = PATH_SEPARATOR;        full_path[base_len + 1] = '\0';        base_len++;    }    // Verificar espaço suficiente    if (base_len + strlen(relative_path) >= full_path_size)    {        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Buffer insuficiente para caminho completo");        return false;    }    // Concatenar caminho relativo    strcat(full_path, relative_path);    return true;}/** * @brief Lê o conteúdo de um arquivo de texto */bool read_text_file(const char *path, char *buffer, size_t buffer_size){    if (!path || !buffer || buffer_size <= 0)    {        return false;    }    FILE *file = fopen(path, "r");    if (!file)    {        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao abrir arquivo para leitura: %s", path);        return false;    }    size_t bytes_read = fread(buffer, 1, buffer_size - 1, file);    buffer[bytes_read] = '\0';    fclose(file);    return true;}/** * @brief Escreve conteúdo em um arquivo de texto */bool write_text_file(const char *path, const char *content){    if (!path || !content)    {        return false;    }    FILE *file = fopen(path, "w");    if (!file)    {        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao abrir arquivo para escrita: %s", path);        return false;    }    size_t content_length = strlen(content);    size_t bytes_written = fwrite(content, 1, content_length, file);    fclose(file);    return (bytes_written == content_length);}/** * @brief Lê dados binários de um arquivo */bool read_binary_file(const char *path, void *buffer, size_t buffer_size, size_t *bytes_read){    if (!path || !buffer || buffer_size <= 0)    {        return false;    }    FILE *file = fopen(path, "rb");    if (!file)    {        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao abrir arquivo binário para leitura: %s", path);        return false;    }    size_t read_size = fread(buffer, 1, buffer_size, file);    if (bytes_read)    {        *bytes_read = read_size;    }    fclose(file);    return true;}/** * @brief Escreve dados binários em um arquivo */bool write_binary_file(const char *path, const void *data, size_t data_size){    if (!path || !data || data_size <= 0)    {        return false;    }    FILE *file = fopen(path, "wb");    if (!file)    {        EMU_LOG_ERROR(EMU_LOG_CAT_UTILS, "Falha ao abrir arquivo binário para escrita: %s", path);        return false;    }    size_t bytes_written = fwrite(data, 1, data_size, file);    fclose(file);    return (bytes_written == data_size);}