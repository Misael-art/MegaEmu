/** * @file save_state.c * @brief Implementação das funções para salvar e carregar estados de jogo * @author Mega_Emu Team * @version 1.0.0 * @date 2024-07-25 */#include "utils/save_state.h"#include "utils/error_handling.h"#include "utils/enhanced_log.h"#include "utils/log_categories.h"#include "utils/file_utils.h"#include <stdlib.h>#include <string.h>#include <time.h>// Macros de log específicas para save state#define SAVE_LOG_INFO(msg, ...) EMU_LOG_INFO(EMU_LOG_CAT_SAVE_STATE, msg, ##__VA_ARGS__)#define SAVE_LOG_ERROR(msg, ...) EMU_LOG_ERROR(EMU_LOG_CAT_SAVE_STATE, msg, ##__VA_ARGS__)#define SAVE_LOG_TRACE(msg, ...) EMU_LOG_TRACE(EMU_LOG_CAT_SAVE_STATE, msg, ##__VA_ARGS__)#define SAVE_LOG_WARN(msg, ...) EMU_LOG_WARN(EMU_LOG_CAT_SAVE_STATE, msg, ##__VA_ARGS__)#define SAVE_LOG_DEBUG(msg, ...) EMU_LOG_DEBUG(EMU_LOG_CAT_SAVE_STATE, msg, ##__VA_ARGS__)// Tamanho inicial do buffer#define INITIAL_BUFFER_SIZE (1024 * 1024) // 1MB// Assinatura mágica para identificar arquivos de save state#define SAVE_STATE_MAGIC 0x4D454753 // "MEGS"// Versão atual do formato de save state#define SAVE_STATE_VERSION 1// Tamanho máximo para screenshots#define MAX_SCREENSHOT_SIZE (1024 * 1024) // 1MB// Funções estáticas auxiliaresstatic bool write_header(FILE *fp, const save_state_header_t *header);static bool read_header(FILE *fp, save_state_header_t *header);static bool validate_header(const save_state_header_t *header, uint32_t expected_platform);/** * @brief Inicializa um novo save state * @return Ponteiro para o save state, ou NULL em caso de erro */save_state_t *emu_save_state_init(void){    save_state_t *state = (save_state_t *)calloc(1, sizeof(save_state_t));    if (!state)    {        SAVE_LOG_ERROR("Falha ao alocar memória para save state");        return NULL;    }    // Aloca buffer inicial    state->buffer = (uint8_t *)malloc(INITIAL_BUFFER_SIZE);    if (!state->buffer)    {        SAVE_LOG_ERROR("Falha ao alocar buffer para save state");        free(state);        return NULL;    }    // Inicializa campos    state->buffer_size = INITIAL_BUFFER_SIZE;    state->current_pos = 0;    state->name = NULL;    state->description = NULL;    state->timestamp = (uint32_t)time(NULL);    state->version = 1;    state->is_dirty = 0;    state->is_compressed = 0;    SAVE_LOG_INFO("Save state inicializado com sucesso");    return state;}/** * @brief Finaliza e libera recursos do save state * @param state Ponteiro para o save state */void emu_save_state_shutdown(save_state_t *state){    if (!state)    {        SAVE_LOG_WARN("Tentativa de finalizar save state NULL");        return;    }    if (state->buffer)    {        free(state->buffer);    }    if (state->name)    {        free(state->name);    }    if (state->description)    {        free(state->description);    }    free(state);    SAVE_LOG_INFO("Save state finalizado");}/** * @brief Salva o estado atual em um arquivo * @param state Ponteiro para o save state * @param filename Nome do arquivo * @return 0 em caso de sucesso, -1 em caso de erro */int emu_save_state_save(save_state_t *state, const char *filename){    if (!state || !filename)    {        SAVE_LOG_ERROR("Parâmetros inválidos para salvar save state");        return -1;    }    FILE *file = fopen(filename, "wb");    if (!file)    {        SAVE_LOG_ERROR("Falha ao abrir arquivo %s para escrita", filename);        return -1;    }    // Escreve cabeçalho    fwrite(&state->version, sizeof(uint32_t), 1, file);    fwrite(&state->timestamp, sizeof(uint32_t), 1, file);    fwrite(&state->is_compressed, sizeof(uint8_t), 1, file);    // Escreve dados    fwrite(state->buffer, 1, state->current_pos, file);    fclose(file);    state->is_dirty = 0;    SAVE_LOG_INFO("Save state salvo em %s", filename);    return 0;}/** * @brief Carrega um estado de um arquivo * @param state Ponteiro para o save state * @param filename Nome do arquivo * @return 0 em caso de sucesso, -1 em caso de erro */int emu_save_state_load(save_state_t *state, const char *filename){    if (!state || !filename)    {        SAVE_LOG_ERROR("Parâmetros inválidos para carregar save state");        return -1;    }    FILE *file = fopen(filename, "rb");    if (!file)    {        SAVE_LOG_ERROR("Falha ao abrir arquivo %s para leitura", filename);        return -1;    }    // Lê cabeçalho    fread(&state->version, sizeof(uint32_t), 1, file);    fread(&state->timestamp, sizeof(uint32_t), 1, file);    fread(&state->is_compressed, sizeof(uint8_t), 1, file);    // Obtém tamanho do arquivo    fseek(file, 0, SEEK_END);    long file_size = ftell(file) - (sizeof(uint32_t) * 2 + sizeof(uint8_t));    fseek(file, sizeof(uint32_t) * 2 + sizeof(uint8_t), SEEK_SET);    // Realoca buffer se necessário    if (file_size > state->buffer_size)    {        uint8_t *new_buffer = (uint8_t *)realloc(state->buffer, file_size);        if (!new_buffer)        {            SAVE_LOG_ERROR("Falha ao realocar buffer para save state");            fclose(file);            return -1;        }        state->buffer = new_buffer;        state->buffer_size = file_size;    }    // Lê dados    state->current_pos = fread(state->buffer, 1, file_size, file);    fclose(file);    state->is_dirty = 0;    SAVE_LOG_INFO("Save state carregado de %s", filename);    return 0;}// Implementação das funções de save state para NESbool save_state_save_nes(const char *path){    if (!path)        return false;    FILE *fp = fopen(path, "wb");    if (!fp)        return false;    // Prepara o header    save_state_header_t header = {        .magic = SAVE_STATE_MAGIC,        .version = SAVE_STATE_VERSION,        .platform_id = 1, // NES        .timestamp = (uint32_t)time(NULL),        .data_size = 0, // Será atualizado depois        .screenshot_offset = 0,        .screenshot_size = 0,        .emulator_version = 100 // v1.0.0    };    // Escreve o header    if (!write_header(fp, &header))    {        fclose(fp);        return false;    }    // TODO: Implementar salvamento do estado do NES    // Por enquanto apenas fecha o arquivo    fclose(fp);    return true;}bool save_state_load_nes(const char *path){    if (!path)        return false;    FILE *fp = fopen(path, "rb");    if (!fp)        return false;    // Lê o header    save_state_header_t header;    if (!read_header(fp, &header) || !validate_header(&header, 1))    {        fclose(fp);        return false;    }    // TODO: Implementar carregamento do estado do NES    // Por enquanto apenas fecha o arquivo    fclose(fp);    return true;}// Implementação das funções de save state para SNESbool save_state_save_snes(const char *path){    if (!path)        return false;    FILE *fp = fopen(path, "wb");    if (!fp)        return false;    // Prepara o header    save_state_header_t header = {        .magic = SAVE_STATE_MAGIC,        .version = SAVE_STATE_VERSION,        .platform_id = 2, // SNES        .timestamp = (uint32_t)time(NULL),        .data_size = 0,        .screenshot_offset = 0,        .screenshot_size = 0,        .emulator_version = 100};    // Escreve o header    if (!write_header(fp, &header))    {        fclose(fp);        return false;    }    // TODO: Implementar salvamento do estado do SNES    fclose(fp);    return true;}bool save_state_load_snes(const char *path){    if (!path)        return false;    FILE *fp = fopen(path, "rb");    if (!fp)        return false;    // Lê o header    save_state_header_t header;    if (!read_header(fp, &header) || !validate_header(&header, 2))    {        fclose(fp);        return false;    }    // TODO: Implementar carregamento do estado do SNES    fclose(fp);    return true;}// Implementação das funções de save state para Genesisbool save_state_save_genesis(const char *path){    if (!path)        return false;    FILE *fp = fopen(path, "wb");    if (!fp)        return false;    // Prepara o header    save_state_header_t header = {        .magic = SAVE_STATE_MAGIC,        .version = SAVE_STATE_VERSION,        .platform_id = 3, // Genesis        .timestamp = (uint32_t)time(NULL),        .data_size = 0,        .screenshot_offset = 0,        .screenshot_size = 0,        .emulator_version = 100};    // Escreve o header    if (!write_header(fp, &header))    {        fclose(fp);        return false;    }    // TODO: Implementar salvamento do estado do Genesis    fclose(fp);    return true;}bool save_state_load_genesis(const char *path){    if (!path)        return false;    FILE *fp = fopen(path, "rb");    if (!fp)        return false;    // Lê o header    save_state_header_t header;    if (!read_header(fp, &header) || !validate_header(&header, 3))    {        fclose(fp);        return false;    }    // TODO: Implementar carregamento do estado do Genesis    fclose(fp);    return true;}// Funções para obter handlers de save/loadsave_state_save_fn save_state_get_save_fn(uint32_t platform_id){    switch (platform_id)    {    case 1:        return save_state_save_nes;    case 2:        return save_state_save_snes;    case 3:        return save_state_save_genesis;    default:        return NULL;    }}save_state_load_fn save_state_get_load_fn(uint32_t platform_id){    switch (platform_id)    {    case 1:        return save_state_load_nes;    case 2:        return save_state_load_snes;    case 3:        return save_state_load_genesis;    default:        return NULL;    }}// Função para validar save statesbool save_state_is_valid(const char *path, uint32_t *platform_id){    if (!path)        return false;    FILE *fp = fopen(path, "rb");    if (!fp)        return false;    save_state_header_t header;    bool valid = read_header(fp, &header);    fclose(fp);    if (valid && platform_id)    {        *platform_id = header.platform_id;    }    return valid;}// Funções para screenshotsbool save_state_capture_screenshot(SDL_Renderer *renderer, SDL_Texture *texture,                                   uint8_t *buffer, size_t buffer_size,                                   size_t *bytes_written){    if (!renderer || !texture || !buffer || !bytes_written)        return false;    int width, height;    SDL_QueryTexture(texture, NULL, NULL, &width, &height);    // Cria uma superfície temporária para capturar a screenshot    SDL_Surface *surface = SDL_CreateRGBSurface(0, width, height, 32,                                                0x00FF0000,                                                0x0000FF00,                                                0x000000FF,                                                0xFF000000);    if (!surface)        return false;    // Renderiza a textura na superfície    SDL_RenderReadPixels(renderer, NULL, SDL_PIXELFORMAT_ARGB8888,                         surface->pixels, surface->pitch);    // Salva a superfície em formato PNG no buffer    // TODO: Implementar salvamento em PNG    *bytes_written = 0;    SDL_FreeSurface(surface);    return true;}bool save_state_read_screenshot(const char *path, SDL_Renderer *renderer,                                SDL_Texture **texture){    if (!path || !renderer || !texture)        return false;    FILE *fp = fopen(path, "rb");    if (!fp)        return false;    save_state_header_t header;    if (!read_header(fp, &header) || header.screenshot_size == 0)    {        fclose(fp);        return false;    }    // Posiciona no início da screenshot    if (fseek(fp, header.screenshot_offset, SEEK_SET) != 0)    {        fclose(fp);        return false;    }    // Aloca buffer para a screenshot    uint8_t *buffer = malloc(header.screenshot_size);    if (!buffer)    {        fclose(fp);        return false;    }    // Lê a screenshot    if (fread(buffer, 1, header.screenshot_size, fp) != header.screenshot_size)    {        free(buffer);        fclose(fp);        return false;    }    // TODO: Implementar carregamento da screenshot do buffer PNG    free(buffer);    fclose(fp);    return false;}// Funções auxiliares estáticasstatic bool write_header(FILE *fp, const save_state_header_t *header){    if (!fp || !header)        return false;    return fwrite(header, sizeof(save_state_header_t), 1, fp) == 1;}static bool read_header(FILE *fp, save_state_header_t *header){    if (!fp || !header)        return false;    if (fread(header, sizeof(save_state_header_t), 1, fp) != 1)        return false;    return header->magic == SAVE_STATE_MAGIC;}static bool validate_header(const save_state_header_t *header, uint32_t expected_platform){    if (!header)        return false;    return header->magic == SAVE_STATE_MAGIC &&           header->version <= SAVE_STATE_VERSION &&           header->platform_id == expected_platform;}