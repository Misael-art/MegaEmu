/** * @file enhanced_log.c * @brief Implementação do sistema de logging aprimorado */#include "enhanced_log.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Tamanho máximo da mensagem de log */#define MAX_LOG_MESSAGE 1024/* Estrutura de configuração */typedef struct{    FILE *file;    emu_log_level_t global_level;    emu_log_level_t module_levels[10]; /* Tamanho arbitrário maior que o número de módulos */    bool initialized;} log_config_t;/* Variáveis estáticas */static log_config_t g_config = {    .file = NULL,    .global_level = EMU_LOG_LEVEL_INFO,    .module_levels = {EMU_LOG_LEVEL_INFO},    .initialized = false};/* Strings dos níveis de log */static const char *g_level_strings[] = {    [EMU_LOG_LEVEL_ERROR] = "ERRO",    [EMU_LOG_LEVEL_WARNING] = "AVISO",    [EMU_LOG_LEVEL_INFO] = "INFO",    [EMU_LOG_LEVEL_DEBUG] = "DEBUG",    [EMU_LOG_LEVEL_TRACE] = "TRACE"};/* Função auxiliar para obter string do módulo */static const char *get_module_string(emu_log_module_t module){    switch (module)    {    case EMU_LOG_MODULE_CORE:        return "CORE";    case EMU_LOG_MODULE_CPU:        return "CPU";    case EMU_LOG_MODULE_MEMORY:        return "MEMORY";    case EMU_LOG_MODULE_VIDEO:        return "VIDEO";    case EMU_LOG_MODULE_AUDIO:        return "AUDIO";    case EMU_LOG_MODULE_INPUT:        return "INPUT";    case EMU_LOG_MODULE_SAVE:        return "SAVE";    case EMU_LOG_MODULE_PERF:        return "PERF";    default:        return "UNKNOWN";    }}/* Função auxiliar para obter nível do módulo */static emu_log_level_t get_module_level(emu_log_module_t module){    /* Converter ID do módulo para índice do array */    int index = 0;    switch (module)    {    case EMU_LOG_MODULE_CORE:        index = 0;        break;    case EMU_LOG_MODULE_CPU:        index = 1;        break;    case EMU_LOG_MODULE_MEMORY:        index = 2;        break;    case EMU_LOG_MODULE_VIDEO:        index = 3;        break;    case EMU_LOG_MODULE_AUDIO:        index = 4;        break;    case EMU_LOG_MODULE_INPUT:        index = 5;        break;    case EMU_LOG_MODULE_SAVE:        index = 6;        break;    case EMU_LOG_MODULE_PERF:        index = 7;        break;    default:        index = 0;        break;    }    return g_config.module_levels[index];}/* Função auxiliar para definir nível do módulo */static void set_module_level(emu_log_module_t module, emu_log_level_t level){    /* Converter ID do módulo para índice do array */    int index = 0;    switch (module)    {    case EMU_LOG_MODULE_CORE:        index = 0;        break;    case EMU_LOG_MODULE_CPU:        index = 1;        break;    case EMU_LOG_MODULE_MEMORY:        index = 2;        break;    case EMU_LOG_MODULE_VIDEO:        index = 3;        break;    case EMU_LOG_MODULE_AUDIO:        index = 4;        break;    case EMU_LOG_MODULE_INPUT:        index = 5;        break;    case EMU_LOG_MODULE_SAVE:        index = 6;        break;    case EMU_LOG_MODULE_PERF:        index = 7;        break;    default:        index = 0;        break;    }    g_config.module_levels[index] = level;}bool emu_log_init(const emu_log_config_t *config){    if (g_config.initialized)    {        fprintf(stderr, "ERRO: Sistema de log já inicializado\n");        return false;    }    if (!config)    {        fprintf(stderr, "ERRO: Configuração de log inválida\n");        return false;    }    // Inicializar níveis de log para todos os módulos    for (int i = 0; i < 10; i++)    {        g_config.module_levels[i] = config->level;    }    g_config.global_level = config->level;    g_config.file = config->output;    g_config.initialized = true;    fprintf(stderr, "INFO: Sistema de log inicializado com sucesso\n");    return true;}void emu_log_shutdown(void){    if (!g_config.initialized)    {        return;    }    if (g_config.file)    {        fclose(g_config.file);        g_config.file = NULL;    }    g_config.initialized = false;    EMU_LOG_INFO(EMU_LOG_CAT_CORE, "Sistema de log finalizado");}void emu_log_set_level(emu_log_level_t level){    if (!g_config.initialized || level >= EMU_LOG_LEVEL_MAX)    {        return;    }    g_config.global_level = level;}void emu_log_set_module_level(emu_log_module_t module, emu_log_level_t level){    if (!g_config.initialized || level >= EMU_LOG_LEVEL_MAX)    {        return;    }    set_module_level(module, level);}void emu_log_set_file(const char *filename){    if (!g_config.initialized || !filename)    {        return;    }    if (g_config.file)    {        fclose(g_config.file);    }    g_config.file = fopen(filename, "a");    if (!g_config.file)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Falha ao abrir arquivo de log: %s", filename);    }}void emu_log_message(emu_log_level_t level, emu_log_category_t category, const char *file, int line, const char *fmt, ...){    if (!g_config.initialized || level >= EMU_LOG_LEVEL_MAX)    {        return;    }    /* Obter nível do módulo de forma segura */    emu_log_level_t module_level = get_module_level((emu_log_module_t)category);    if (level > g_config.global_level || level > module_level)    {        return;    }    char message[MAX_LOG_MESSAGE];    va_list args;    va_start(args, fmt);    vsnprintf(message, sizeof(message), fmt, args);    va_end(args);    time_t now = time(NULL);    struct tm *timeinfo = localtime(&now);    char timestamp[32];    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", timeinfo);    /* Formatar mensagem de log */    char log_message[MAX_LOG_MESSAGE];    snprintf(log_message, sizeof(log_message), "[%s] [%s] [%s:%d] %s\n",             timestamp,             g_level_strings[level],             file,             line,             message);    /* Escrever no arquivo de log */    if (g_config.file)    {        fprintf(g_config.file, "%s", log_message);        fflush(g_config.file);    }    /* Escrever no stderr se não for o mesmo arquivo */    if (g_config.file != stderr)    {        fprintf(stderr, "%s", log_message);    }}/* Função para verificar se um nível de log está habilitado */bool emu_enhanced_log_is_enabled(emu_log_level_t level){    if (!g_config.initialized)        return false;    return level <= g_config.global_level;}