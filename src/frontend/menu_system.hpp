#include <stdint.h>/** * @file menu_system.hpp * @brief Define a classe base para o sistema de menu * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-10 */#pragma once#include <SDL.h>#include <string>#include <vector>#include <memory>#include <functional>#include "window.hpp"#include "../input/input_system.hpp"namespace MegaEmu{    namespace UI    {        /**         * @brief Classe que representa um item de menu         */        class MenuItem        {        public:            /**             * @brief Construtor             * @param text Texto do item             * @param action Ação a ser executada quando o item for selecionado             */            MenuItem(const std::string &text, std::function<void()> action)                : text(text), action(action), enabled(true)            {            }            std::string text;             ///< Texto do item            std::function<void()> action; ///< Ação do item            bool enabled;                 ///< Flag de habilitado        };        /**         * @brief Classe que representa um menu         */        class Menu        {        public:            /**             * @brief Construtor             * @param title Título do menu             */            Menu(const std::string &title)                : title(title), selectedIndex(0)            {            }            /**             * @brief Adiciona um item ao menu             * @param text Texto do item             * @param action Ação do item             */            void addItem(const std::string &text, std::function<void()> action)            {                items.emplace_back(text, action);            }            /**             * @brief Remove um item do menu             * @param index Índice do item             */            void removeItem(size_t index)            {                if (index < items.size())                {                    items.erase(items.begin() + index);                    if (selectedIndex >= items.size())                    {                        selectedIndex = items.size() - 1;                    }                }            }            /**             * @brief Habilita ou desabilita um item             * @param index Índice do item             * @param enabled true para habilitar, false para desabilitar             */            void setItemEnabled(size_t index, bool enabled)            {                if (index < items.size())                {                    items[index].enabled = enabled;                }            }            std::string title;           ///< Título do menu            std::vector<MenuItem> items; ///< Itens do menu            size_t selectedIndex;        ///< Índice do item selecionado        };        /**         * @brief Classe que gerencia o sistema de menu         */        class MenuSystem        {        public:            /**             * @brief Construtor             * @param window Janela do emulador             */            MenuSystem(Window &window)                : window(window), currentMenu(nullptr), font(nullptr), visible(false)            {                // Carregar fonte                font = SDL_CreateRGBSurface(0, 8, 8, 32, 0, 0, 0, 0);                if (!font)                {                    throw std::runtime_error("Erro ao criar superfície da fonte: " + std::string(SDL_GetError()));                }            }            /**             * @brief Destrutor             */            ~MenuSystem()            {                if (font)                {                    SDL_FreeSurface(font);                }            }            /**             * @brief Cria um novo menu             * @param title Título do menu             * @return Ponteiro para o menu criado             */            std::shared_ptr<Menu> createMenu(const std::string &title)            {                auto menu = std::make_shared<Menu>(title);                menus.push_back(menu);                if (!currentMenu)                {                    currentMenu = menu;                }                return menu;            }            /**             * @brief Define o menu atual             * @param menu Menu a ser definido como atual             */            void setCurrentMenu(std::shared_ptr<Menu> menu)            {                currentMenu = menu;            }            /**             * @brief Mostra ou esconde o menu             * @param show true para mostrar, false para esconder             */            void show(bool show)            {                visible = show;            }            /**             * @brief Atualiza o menu             * @param input Sistema de entrada             */            void update(const Input::InputSystem &input)            {                if (!visible || !currentMenu)                {                    return;                }                auto state = input.getControllerState(0);                // Navegar pelo menu                if (state.buttons[static_cast<int32_t>(Core::ButtonState::Up)])                {                    if (currentMenu->selectedIndex > 0)                    {                        currentMenu->selectedIndex--;                    }                }                else if (state.buttons[static_cast<int32_t>(Core::ButtonState::Down)])                {                    if (currentMenu->selectedIndex < currentMenu->items.size() - 1)                    {                        currentMenu->selectedIndex++;                    }                }                // Selecionar item                if (state.buttons[static_cast<int32_t>(Core::ButtonState::A)])                {                    auto &item = currentMenu->items[currentMenu->selectedIndex];                    if (item.enabled && item.action)                    {                        item.action();                    }                }            }            /**             * @brief Renderiza o menu             */            void render()            {                if (!visible || !currentMenu)                {                    return;                }                SDL_Renderer *renderer = window.getRenderer();                // Desenhar fundo semi-transparente                SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);                SDL_SetRenderDrawColor(renderer, 0, 0, 0, 192);                SDL_RenderFillRect(renderer, nullptr);                // Desenhar título                renderText(currentMenu->title, 10, 10, {255, 255, 255, 255});                // Desenhar itens                int32_t y = 40;                for (size_t i = 0; i < currentMenu->items.size(); i++)                {                    const auto &item = currentMenu->items[i];                    SDL_Color color = item.enabled ? (i == currentMenu->selectedIndex ? SDL_Color{255, 255, 0, 255} : SDL_Color{255, 255, 255, 255}) : SDL_Color{128, 128, 128, 255};                    renderText(item.text, 20, y, color);                    y += 20;                }            }        private:            /**             * @brief Renderiza texto na tela             * @param text Texto a ser renderizado             * @param x Posição X             * @param y Posição Y             * @param color Cor do texto             */            void renderText(const std::string &text, int32_t x, int32_t y, SDL_Color color)            {                SDL_Renderer *renderer = window.getRenderer();                // Desenhar cada caractere                for (size_t i = 0; i < text.length(); i++)                {                    SDL_Rect src = {0, 0, 8, 8};                    SDL_Rect dst = {x + static_cast<int32_t>(i * 8), y, 8, 8};                    // Definir cor do caractere                    SDL_FillRect(font, nullptr, SDL_MapRGBA(font->format, color.r, color.g, color.b, color.a));                    // Criar textura temporária                    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, font);                    if (texture)                    {                        SDL_RenderCopy(renderer, texture, &src, &dst);                        SDL_DestroyTexture(texture);                    }                }            }            Window &window;                           ///< Referência para a janela            std::vector<std::shared_ptr<Menu>> menus; ///< Lista de menus            std::shared_ptr<Menu> currentMenu;        ///< Menu atual            SDL_Surface *font;                        ///< Superfície da fonte            bool visible;                             ///< Flag de visibilidade        };    } // namespace UI} // namespace MegaEmu