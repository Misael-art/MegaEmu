#include "shaders.h"#include <SDL2/SDL.h>#include <stdlib.h>#include <string.h>// SDL2 não suporta shaders GLSL diretamente, então precisamos implementar um wrapper// Aqui estamos usando uma abordagem simplificada baseada em rendering em textura// Inicialização do sistema de shadersgui_result_t gui_shaders_init(gui_shader_system_t *system, gui_sdl2_backend_t *backend){    if (!system || !backend)        return GUI_ERROR_INVALID_PARAM;    system->shaders = NULL;    system->shader_count = 0;    system->renderer = backend->renderer;    system->initialized = GUI_TRUE;    // Criar texture buffer para processamento    int width, height;    SDL_GetRendererOutputSize(backend->renderer, &width, &height);    system->buffer_texture = SDL_CreateTexture(backend->renderer,                                               SDL_PIXELFORMAT_RGBA8888,                                               SDL_TEXTUREACCESS_TARGET,                                               width, height);    if (!system->buffer_texture)    {        gui_shaders_shutdown(system);        return GUI_ERROR_INIT_FAILED;    }    return GUI_SUCCESS;}// Finalização do sistema de shadersvoid gui_shaders_shutdown(gui_shader_system_t *system){    if (!system)        return;    // Liberar shaders    for (size_t i = 0; i < system->shader_count; i++)    {        free(system->shaders[i].vertex_shader);        free(system->shaders[i].fragment_shader);        // Note: shader_program não é alocado nesta implementação    }    free(system->shaders);    // Liberar buffer    if (system->buffer_texture)    {        SDL_DestroyTexture(system->buffer_texture);    }    system->shaders = NULL;    system->shader_count = 0;    system->initialized = GUI_FALSE;}// Adicionar shadergui_result_t gui_shaders_add(gui_shader_system_t *system,                             gui_shader_type_t type,                             const char *vertex_src,                             const char *fragment_src,                             gui_shader_params_t params){    if (!system)        return GUI_ERROR_INVALID_PARAM;    // Verificar se já existe um shader deste tipo    for (size_t i = 0; i < system->shader_count; i++)    {        if (system->shaders[i].type == type)        {            // Atualizar parâmetros            system->shaders[i].params = params;            return GUI_SUCCESS;        }    }    // Criar novo shader    gui_shader_t *new_shaders = realloc(system->shaders,                                        (system->shader_count + 1) * sizeof(gui_shader_t));    if (!new_shaders)        return GUI_ERROR_MEMORY;    system->shaders = new_shaders;    gui_shader_t *shader = &system->shaders[system->shader_count++];    // Inicializar shader    shader->type = type;    shader->params = params;    shader->shader_program = NULL; // Não utilizado nesta implementação    shader->compiled = GUI_FALSE;    // Copiar código fonte    if (vertex_src)    {        shader->vertex_shader = strdup(vertex_src);        if (!shader->vertex_shader)            return GUI_ERROR_MEMORY;    }    else    {        shader->vertex_shader = NULL;    }    if (fragment_src)    {        shader->fragment_shader = strdup(fragment_src);        if (!shader->fragment_shader)        {            free(shader->vertex_shader);            return GUI_ERROR_MEMORY;        }    }    else    {        shader->fragment_shader = NULL;    }    return GUI_SUCCESS;}// Remover shadervoid gui_shaders_remove(gui_shader_system_t *system, gui_shader_type_t type){    if (!system)        return;    for (size_t i = 0; i < system->shader_count; i++)    {        if (system->shaders[i].type == type)        {            // Liberar recursos            free(system->shaders[i].vertex_shader);            free(system->shaders[i].fragment_shader);            // Remover do array            memmove(&system->shaders[i],                    &system->shaders[i + 1],                    (system->shader_count - i - 1) * sizeof(gui_shader_t));            system->shader_count--;            break;        }    }}// Configurar parâmetros do shadervoid gui_shaders_set_params(gui_shader_system_t *system,                            gui_shader_type_t type,                            gui_shader_params_t params){    if (!system)        return;    for (size_t i = 0; i < system->shader_count; i++)    {        if (system->shaders[i].type == type)        {            system->shaders[i].params = params;            break;        }    }}// Iniciar aplicação de shadersgui_result_t gui_shaders_begin(gui_shader_system_t *system, SDL_Texture *target){    if (!system || !system->initialized || !target)        return GUI_ERROR_INVALID_PARAM;    // Configurar renderer para desenhar no texture buffer    SDL_SetRenderTarget(system->renderer, system->buffer_texture);    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    return GUI_SUCCESS;}// Finalizar aplicação de shadersgui_result_t gui_shaders_end(gui_shader_system_t *system){    if (!system || !system->initialized)        return GUI_ERROR_INVALID_PARAM;    // Resetar renderer para o destino padrão    SDL_SetRenderTarget(system->renderer, NULL);    return GUI_SUCCESS;}// Aplicar shader específicogui_result_t gui_shaders_apply(gui_shader_system_t *system,                               gui_shader_type_t type,                               SDL_Texture *source,                               SDL_Texture *target){    if (!system || !system->initialized || !source || !target)    {        return GUI_ERROR_INVALID_PARAM;    }    // Encontrar shader    gui_shader_t *shader = NULL;    for (size_t i = 0; i < system->shader_count; i++)    {        if (system->shaders[i].type == type)        {            shader = &system->shaders[i];            break;        }    }    if (!shader)        return GUI_ERROR_NOT_FOUND;    // Configurar renderização para o destino    SDL_SetRenderTarget(system->renderer, target);    // Aplicar efeito    switch (type)    {    case GUI_SHADER_BLUR:        apply_blur_effect(system, shader, source, target);        break;    case GUI_SHADER_CRT:        apply_crt_effect(system, shader, source, target);        break;    case GUI_SHADER_WAVE:        apply_wave_effect(system, shader, source, target);        break;    case GUI_SHADER_COLOR_CORRECTION:        apply_color_correction_effect(system, shader, source, target);        break;    case GUI_SHADER_CHROMATIC_ABERRATION:        apply_chromatic_aberration_effect(system, shader, source, target);        break;    case GUI_SHADER_MOTION_BLUR:        apply_motion_blur_effect(system, shader, source, target);        break;    case GUI_SHADER_BLOOM:        apply_bloom_effect(system, shader, source, target);        break;    case GUI_SHADER_HDR:        apply_hdr_effect(system, shader, source, target);        break;    default:        // Caso não tenha shader específico, apenas copiar a textura        SDL_RenderCopy(system->renderer, source, NULL, NULL);        break;    }    return GUI_SUCCESS;}// Implementação dos efeitosstatic void apply_blur_effect(gui_shader_system_t *system,                              gui_shader_t *shader,                              SDL_Texture *source,                              SDL_Texture *target){    // Em SDL2 puro, implementamos blur por múltiplos passes    float radius = shader->params.values[0];    // Configurar destino    SDL_SetRenderTarget(system->renderer, target);    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    // Aplicar blur horizontal e vertical com várias passagens    // (simplificado, não é um verdadeiro blur gaussiano)    SDL_Rect dest;    SDL_QueryTexture(source, NULL, NULL, &dest.w, &dest.h);    dest.x = 0;    dest.y = 0;    // Renderizar textura original    SDL_RenderCopy(system->renderer, source, NULL, &dest);    // Aplicar blur com alpha blending    SDL_SetTextureBlendMode(source, SDL_BLENDMODE_BLEND);    SDL_SetTextureAlphaMod(source, 128); // 50% alpha    // Passadas horizontais    for (int i = -radius; i <= radius; i += 2)    {        if (i == 0)            continue;        dest.x = i;        dest.y = 0;        SDL_RenderCopy(system->renderer, source, NULL, &dest);    }    // Passadas verticais    for (int i = -radius; i <= radius; i += 2)    {        if (i == 0)            continue;        dest.x = 0;        dest.y = i;        SDL_RenderCopy(system->renderer, source, NULL, &dest);    }    // Restaurar blend mode    SDL_SetTextureAlphaMod(source, 255);    SDL_SetTextureBlendMode(source, SDL_BLENDMODE_NONE);}static void apply_crt_effect(gui_shader_system_t *system,                             gui_shader_t *shader,                             SDL_Texture *source,                             SDL_Texture *target){    // Parâmetros    float scanline_intensity = shader->params.values[2];    // Configurar destino    SDL_SetRenderTarget(system->renderer, target);    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    // Renderizar textura original    SDL_RenderCopy(system->renderer, source, NULL, NULL);    // Aplicar scanlines    if (scanline_intensity > 0.0f)    {        int w, h;        SDL_QueryTexture(source, NULL, NULL, &w, &h);        SDL_SetRenderDrawBlendMode(system->renderer, SDL_BLENDMODE_BLEND);        SDL_SetRenderDrawColor(system->renderer, 0, 0, 0,                               (Uint8)(scanline_intensity * 128.0f));        for (int y = 1; y < h; y += 2)        {            SDL_RenderDrawLine(system->renderer, 0, y, w, y);        }    }}static void apply_wave_effect(gui_shader_system_t *system,                              gui_shader_t *shader,                              SDL_Texture *source,                              SDL_Texture *target){    // Em SDL2 puro, o efeito de onda é simplificado    // Para uma implementação completa, seria necessário usar OpenGL/shaders    // Parâmetros    float amplitude = shader->params.values[0];    float time = shader->params.time;    // Configurar destino    SDL_SetRenderTarget(system->renderer, target);    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    // Renderizar textura com distorção simples    int w, h;    SDL_QueryTexture(source, NULL, NULL, &w, &h);    SDL_Rect src = {0, 0, 1, h};    SDL_Rect dst = {0, 0, 1, h};    for (int x = 0; x < w; x++)    {        src.x = x;        dst.x = x;        // Aplicar offset senoidal        int offset = (int)(amplitude * sin(x * 0.05f + time));        dst.y = offset;        SDL_RenderCopy(system->renderer, source, &src, &dst);    }}static void apply_color_correction_effect(gui_shader_system_t *system,                                          gui_shader_t *shader,                                          SDL_Texture *source,                                          SDL_Texture *target){    // Em SDL2 puro, podemos aplicar correções básicas com modulação de cor    float brightness = shader->params.values[0];    float contrast = shader->params.values[1];    // Configurar destino    SDL_SetRenderTarget(system->renderer, target);    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    // Aplicar brilho e contraste básicos via modulação de cor    Uint8 r = 255, g = 255, b = 255;    // Brilho: valores > 1.0 aumentam, < 1.0 diminuem    if (brightness != 1.0f)    {        r = (Uint8)(255 * brightness);        g = (Uint8)(255 * brightness);        b = (Uint8)(255 * brightness);    }    // Aplicar modulação de cor    SDL_SetTextureColorMod(source, r, g, b);    // Renderizar com a modulação    SDL_RenderCopy(system->renderer, source, NULL, NULL);    // Restaurar modulação    SDL_SetTextureColorMod(source, 255, 255, 255);}static void apply_chromatic_aberration_effect(gui_shader_system_t *system,                                              gui_shader_t *shader,                                              SDL_Texture *source,                                              SDL_Texture *target){    // Parâmetros    float intensity = shader->params.values[0];    // Configurar destino    SDL_SetRenderTarget(system->renderer, target);    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    // Em SDL2 puro, simulamos aberração cromática renderizando    // os canais RGB separadamente com deslocamentos    int w, h;    SDL_QueryTexture(source, NULL, NULL, &w, &h);    // Deslocamento para cada canal    int r_offset = (int)(intensity * 5.0f);    int g_offset = (int)(intensity * 2.0f);    int b_offset = (int)(intensity * 7.0f);    // Canal vermelho    SDL_SetTextureColorMod(source, 255, 0, 0);    SDL_Rect dst = {r_offset, 0, w, h};    SDL_RenderCopy(system->renderer, source, NULL, &dst);    // Canal verde    SDL_SetTextureColorMod(source, 0, 255, 0);    dst.x = g_offset;    SDL_RenderCopy(system->renderer, source, NULL, &dst);    // Canal azul    SDL_SetTextureColorMod(source, 0, 0, 255);    dst.x = b_offset;    SDL_RenderCopy(system->renderer, source, NULL, &dst);    // Restaurar modulação    SDL_SetTextureColorMod(source, 255, 255, 255);}static void apply_motion_blur_effect(gui_shader_system_t *system,                                     gui_shader_t *shader,                                     SDL_Texture *source,                                     SDL_Texture *target){    // Parâmetros    float intensity = shader->params.values[0];    // Configurar destino    SDL_SetRenderTarget(system->renderer, target);    // Renderizar textura anterior com alpha    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    // Renderizar a textura original    SDL_RenderCopy(system->renderer, source, NULL, NULL);    // Renderizar a textura anterior (simulada pelo buffer atual) com alpha    SDL_SetTextureAlphaMod(system->buffer_texture, (Uint8)(intensity * 255.0f));    SDL_SetTextureBlendMode(system->buffer_texture, SDL_BLENDMODE_BLEND);    SDL_RenderCopy(system->renderer, system->buffer_texture, NULL, NULL);    // Restaurar alpha    SDL_SetTextureAlphaMod(system->buffer_texture, 255);    SDL_SetTextureBlendMode(system->buffer_texture, SDL_BLENDMODE_NONE);}static void apply_bloom_effect(gui_shader_system_t *system,                               gui_shader_t *shader,                               SDL_Texture *source,                               SDL_Texture *target){    // Parâmetros    float threshold = shader->params.values[0];    float intensity = shader->params.values[1];    // Configurar destino    SDL_SetRenderTarget(system->renderer, target);    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    // Renderizar textura original    SDL_RenderCopy(system->renderer, source, NULL, NULL);    // Aplicar bloom (simplificado)    SDL_SetTextureBlendMode(source, SDL_BLENDMODE_ADD);    SDL_SetTextureColorMod(source,                           (Uint8)(255 * intensity),                           (Uint8)(255 * intensity),                           (Uint8)(255 * intensity));    // Renderizar novamente com blend add para simular bloom    SDL_RenderCopy(system->renderer, source, NULL, NULL);    // Restaurar    SDL_SetTextureBlendMode(source, SDL_BLENDMODE_NONE);    SDL_SetTextureColorMod(source, 255, 255, 255);}static void apply_hdr_effect(gui_shader_system_t *system,                             gui_shader_t *shader,                             SDL_Texture *source,                             SDL_Texture *target){    // Parâmetros    float exposure = shader->params.values[0];    // Configurar destino    SDL_SetRenderTarget(system->renderer, target);    SDL_SetRenderDrawColor(system->renderer, 0, 0, 0, 0);    SDL_RenderClear(system->renderer);    // Aplicar exposição via modulação de cor (simplificado)    Uint8 value = (Uint8)(255 * exposure);    SDL_SetTextureColorMod(source, value, value, value);    // Renderizar    SDL_RenderCopy(system->renderer, source, NULL, NULL);    // Restaurar    SDL_SetTextureColorMod(source, 255, 255, 255);}// Função auxiliar para criar shaders comunsgui_result_t gui_shader_create_blur(gui_shader_system_t *system, float radius){    gui_shader_params_t params = {0};    params.values[0] = radius;    return gui_shaders_add(system, GUI_SHADER_BLUR,                           GUI_VERTEX_SHADER_BASIC,                           GUI_FRAGMENT_SHADER_BLUR,                           params);}gui_result_t gui_shader_create_crt(gui_shader_system_t *system,                                   float curvature,                                   float vignette,                                   float scanline_intensity){    gui_shader_params_t params = {0};    params.values[0] = curvature;    params.values[1] = vignette;    params.values[2] = scanline_intensity;    return gui_shaders_add(system, GUI_SHADER_CRT,                           GUI_VERTEX_SHADER_BASIC,                           GUI_FRAGMENT_SHADER_CRT,                           params);}gui_result_t gui_shader_create_wave(gui_shader_system_t *system,                                    float amplitude,                                    float frequency){    gui_shader_params_t params = {0};    params.values[0] = amplitude;    params.values[1] = frequency;    params.time = 0.0f;    return gui_shaders_add(system, GUI_SHADER_WAVE,                           GUI_VERTEX_SHADER_BASIC,                           GUI_FRAGMENT_SHADER_WAVE,                           params);}gui_result_t gui_shader_create_color_correction(gui_shader_system_t *system,                                                float brightness,                                                float contrast,                                                float saturation,                                                float gamma){    gui_shader_params_t params = {0};    params.values[0] = brightness;    params.values[1] = contrast;    params.values[2] = saturation;    params.values[3] = gamma;    return gui_shaders_add(system, GUI_SHADER_COLOR_CORRECTION,                           GUI_VERTEX_SHADER_BASIC,                           GUI_FRAGMENT_SHADER_COLOR_CORRECTION,                           params);}gui_result_t gui_shader_create_chromatic_aberration(gui_shader_system_t *system,                                                    float intensity,                                                    float angle){    gui_shader_params_t params = {0};    params.values[0] = intensity;    params.values[1] = angle;    return gui_shaders_add(system, GUI_SHADER_CHROMATIC_ABERRATION,                           GUI_VERTEX_SHADER_BASIC,                           GUI_FRAGMENT_SHADER_CHROMATIC_ABERRATION,                           params);}gui_result_t gui_shader_create_motion_blur(gui_shader_system_t *system,                                           float intensity,                                           float angle){    gui_shader_params_t params = {0};    params.values[0] = intensity;    params.values[1] = angle;    return gui_shaders_add(system, GUI_SHADER_MOTION_BLUR,                           GUI_VERTEX_SHADER_BASIC,                           GUI_FRAGMENT_SHADER_MOTION_BLUR,                           params);}gui_result_t gui_shader_create_bloom(gui_shader_system_t *system,                                     float threshold,                                     float intensity){    gui_shader_params_t params = {0};    params.values[0] = threshold;    params.values[1] = intensity;    return gui_shaders_add(system, GUI_SHADER_BLOOM,                           GUI_VERTEX_SHADER_BASIC,                           GUI_FRAGMENT_SHADER_BLOOM,                           params);}gui_result_t gui_shader_create_hdr(gui_shader_system_t *system,                                   float exposure,                                   float gamma){    gui_shader_params_t params = {0};    params.values[0] = exposure;    params.values[1] = gamma;    return gui_shaders_add(system, GUI_SHADER_HDR,                           GUI_VERTEX_SHADER_BASIC,                           GUI_FRAGMENT_SHADER_HDR,                           params);}