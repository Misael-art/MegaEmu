#include "anime_effects.h"#include <stdlib.h>#include <string.h>#include <stdio.h>#include <math.h>// Inicialização do sistema de efeitos animegui_result_t anime_effects_init(anime_effect_system_t *system, gui_shader_system_t *shaders){    if (!system || !shaders)        return GUI_ERROR_INVALID_PARAM;    system->presets = NULL;    system->preset_count = 0;    system->shader_system = shaders;    system->buffer_texture = NULL;    system->depth_texture = NULL;    system->initialized = GUI_TRUE;    system->is_3d_mode = GUI_FALSE;    // Inicializar com preset padrão    system->current_preset = anime_preset_default();    return GUI_SUCCESS;}// Finalização do sistemavoid anime_effects_shutdown(anime_effect_system_t *system){    if (!system)        return;    // Liberar presets    free(system->presets);    // Liberar texturas    if (system->buffer_texture)    {        SDL_DestroyTexture(system->buffer_texture);    }    if (system->depth_texture)    {        SDL_DestroyTexture(system->depth_texture);    }    system->presets = NULL;    system->preset_count = 0;    system->initialized = GUI_FALSE;}// Adicionar preset ao sistemagui_result_t anime_effects_add_preset(anime_effect_system_t *system, const anime_preset_t *preset){    if (!system || !preset)        return GUI_ERROR_INVALID_PARAM;    // Verificar se já existe um preset com este nome    for (size_t i = 0; i < system->preset_count; i++)    {        if (strcmp(system->presets[i].name, preset->name) == 0)        {            // Atualizar preset existente            system->presets[i] = *preset;            return GUI_SUCCESS;        }    }    // Criar novo preset    anime_preset_t *new_presets = realloc(system->presets,                                          (system->preset_count + 1) * sizeof(anime_preset_t));    if (!new_presets)        return GUI_ERROR_MEMORY;    system->presets = new_presets;    system->presets[system->preset_count++] = *preset;    return GUI_SUCCESS;}// Carregar preset por nomegui_result_t anime_effects_load_preset(anime_effect_system_t *system, const char *name){    if (!system || !name)        return GUI_ERROR_INVALID_PARAM;    // Buscar preset pelo nome    for (size_t i = 0; i < system->preset_count; i++)    {        if (strcmp(system->presets[i].name, name) == 0)        {            system->current_preset = system->presets[i];            return GUI_SUCCESS;        }    }    return GUI_ERROR_NOT_FOUND;}// Configurar estilogui_result_t anime_effects_set_style(anime_effect_system_t *system, anime_style_t style){    if (!system)        return GUI_ERROR_INVALID_PARAM;    // Configurar preset baseado no estilo    anime_preset_t preset;    switch (style)    {    case ANIME_STYLE_MODERN:        preset = anime_preset_modern();        break;    case ANIME_STYLE_CLASSIC:        preset = anime_preset_classic();        break;    case ANIME_STYLE_SHONEN:        preset = anime_preset_shonen();        break;    case ANIME_STYLE_SHOJO:        preset = anime_preset_shojo();        break;    case ANIME_STYLE_SEINEN:        preset = anime_preset_seinen();        break;    case ANIME_STYLE_CHIBI:        preset = anime_preset_chibi();        break;    case ANIME_STYLE_CYBERPUNK:        preset = anime_preset_cyberpunk();        break;    case ANIME_STYLE_WATERCOLOR:        preset = anime_preset_watercolor();        break;    default:        preset = anime_preset_default();        break;    }    system->current_preset = preset;    return GUI_SUCCESS;}// Personalizar parâmetrosgui_result_t anime_effects_customize(anime_effect_system_t *system, anime_effect_params_t params){    if (!system)        return GUI_ERROR_INVALID_PARAM;    // Manter o nome e estilo, mas atualizar os parâmetros    system->current_preset.params = params;    return GUI_SUCCESS;}// Início de framegui_result_t anime_effects_begin_frame(anime_effect_system_t *system, SDL_Texture *target){    if (!system || !system->initialized || !target)        return GUI_ERROR_INVALID_PARAM;    // Criar/redimensionar buffers se necessário    int target_w, target_h;    SDL_QueryTexture(target, NULL, NULL, &target_w, &target_h);    if (!system->buffer_texture ||        system->buffer_texture->w != target_w ||        system->buffer_texture->h != target_h)    {        if (system->buffer_texture)        {            SDL_DestroyTexture(system->buffer_texture);        }        system->buffer_texture = SDL_CreateTexture(            system->shader_system->renderer,            SDL_PIXELFORMAT_RGBA8888,            SDL_TEXTUREACCESS_TARGET,            target_w, target_h);        if (!system->buffer_texture)        {            return GUI_ERROR_INIT_FAILED;        }    }    // Criar/redimensionar buffer de profundidade se 3D estiver ativo    if (system->is_3d_mode)    {        if (!system->depth_texture ||            system->depth_texture->w != target_w ||            system->depth_texture->h != target_h)        {            if (system->depth_texture)            {                SDL_DestroyTexture(system->depth_texture);            }            system->depth_texture = SDL_CreateTexture(                system->shader_system->renderer,                SDL_PIXELFORMAT_RGBA8888,                SDL_TEXTUREACCESS_TARGET,                target_w, target_h);            if (!system->depth_texture)            {                return GUI_ERROR_INIT_FAILED;            }        }    }    // Iniciar o sistema de shaders    return gui_shaders_begin(system->shader_system, target);}// Aplicar efeitosgui_result_t anime_effects_apply(anime_effect_system_t *system,                                 SDL_Texture *source,                                 SDL_Texture *target,                                 SDL_Texture *depth_buffer){    if (!system || !system->initialized || !source || !target)    {        return GUI_ERROR_INVALID_PARAM;    }    // Aplicar efeitos na ordem correta baseado no preset atual    anime_effect_params_t params = system->current_preset.params;    // 1. Cel-shading (se 3D estiver ativo)    if (system->is_3d_mode && params.enable_3d)    {        anime_effect_apply_cel_shading(system, source, system->buffer_texture,                                       depth_buffer, &params.cel);        source = system->buffer_texture;    }    // 2. Contornos    anime_effect_apply_outline(system, source, system->buffer_texture,                               depth_buffer, &params.outline);    source = system->buffer_texture;    // 3. Quantização de cores    anime_effect_apply_color_quantize(system, source, system->buffer_texture,                                      &params.color);    source = system->buffer_texture;    // 4. Mapeamento de tons    anime_effect_apply_tone_mapping(system, source, system->buffer_texture,                                    &params.tone);    source = system->buffer_texture;    // 5. Bloom estilizado    anime_effect_apply_bloom_stylized(system, source, system->buffer_texture,                                      &params.bloom);    source = system->buffer_texture;    // 6. Linhas de velocidade (se ativas)    if (params.speed_lines.intensity > 0.0f)    {        anime_effect_apply_speed_lines(system, source, system->buffer_texture,                                       &params.speed_lines);        source = system->buffer_texture;    }    // 7. Painéis de quadrinhos (se ativos)    if (params.panel.layout > 0)    {        anime_effect_apply_comic_panel(system, source, system->buffer_texture,                                       &params.panel);        source = system->buffer_texture;    }    // Renderizar resultado final para o destino    SDL_SetRenderTarget(system->shader_system->renderer, target);    SDL_RenderCopy(system->shader_system->renderer, source, NULL, NULL);    return GUI_SUCCESS;}// Fim do framegui_result_t anime_effects_end_frame(anime_effect_system_t *system){    if (!system || !system->initialized)        return GUI_ERROR_INVALID_PARAM;    // Finalizar o sistema de shaders    return gui_shaders_end(system->shader_system);}// Implementação dos efeitos específicosgui_result_t anime_effect_apply_cel_shading(anime_effect_system_t *system,                                            SDL_Texture *source,                                            SDL_Texture *target,                                            SDL_Texture *depth_buffer,                                            const anime_cel_params_t *params){    if (!system || !source || !target || !params)        return GUI_ERROR_INVALID_PARAM;    // Configurar shader de cel-shading    gui_shader_t *shader = gui_shaders_get(system->shader_system, GUI_SHADER_CEL);    if (!shader)        return GUI_ERROR_NOT_FOUND;    // Configurar uniforms    gui_shader_set_int(shader, "u_shade_levels", params->shade_levels);    gui_shader_set_float_array(shader, "u_shade_thresholds", params->shade_threshold, 4);    gui_shader_set_float(shader, "u_smoothness", params->smoothness);    gui_shader_set_int(shader, "u_specular", params->specular);    // Aplicar shader    SDL_SetRenderTarget(system->shader_system->renderer, target);    gui_shaders_bind(system->shader_system, shader);    SDL_RenderCopy(system->shader_system->renderer, source, NULL, NULL);    return GUI_SUCCESS;}// Implementação dos outros efeitos seguiria o mesmo padrão...// Por brevidade, não incluí todas as implementações aqui// Presets padrãoanime_preset_t anime_preset_default(void){    anime_preset_t preset = {0};    preset.name = "Default";    preset.style = ANIME_STYLE_MODERN;    // Configurações padrão para cada efeito    preset.params.outline.thickness = 1.0f;    preset.params.outline.edge_threshold = 0.5f;    preset.params.outline.color = (gui_color_t){0, 0, 0, 255};    preset.params.cel.shade_levels = 3;    preset.params.cel.smoothness = 0.2f;    preset.params.color.color_levels = 8;    preset.params.color.saturation = 1.2f;    preset.params.color.contrast = 1.1f;    preset.params.global_intensity = 1.0f;    return preset;}// Os outros presets seguiriam o mesmo padrão...// Por brevidade, não incluí todas as implementações aqui// Gerenciamento de presets para jogos específicosgui_result_t anime_effects_save_game_preset(const char *rom_path, const anime_preset_t *preset){    if (!rom_path || !preset)        return GUI_ERROR_INVALID_PARAM;    char config_file[512];    snprintf(config_file, sizeof(config_file), "presets/anime_%s.cfg",             strrchr(rom_path, '/') ? strrchr(rom_path, '/') + 1 : rom_path);// Criar diretório se não existir#ifdef _WIN32    _mkdir("presets");#else    mkdir("presets", 0777);#endif    FILE *file = fopen(config_file, "wb");    if (!file)        return GUI_ERROR_FILE_WRITE;    fwrite(preset, sizeof(anime_preset_t), 1, file);    fclose(file);    return GUI_SUCCESS;}gui_result_t anime_effects_load_game_preset(anime_effect_system_t *system, const char *rom_path){    if (!system || !rom_path)        return GUI_ERROR_INVALID_PARAM;    char config_file[512];    snprintf(config_file, sizeof(config_file), "presets/anime_%s.cfg",             strrchr(rom_path, '/') ? strrchr(rom_path, '/') + 1 : rom_path);    FILE *file = fopen(config_file, "rb");    if (!file)        return GUI_ERROR_FILE_READ;    anime_preset_t preset;    size_t read = fread(&preset, sizeof(anime_preset_t), 1, file);    fclose(file);    if (read != 1)        return GUI_ERROR_FILE_READ;    system->current_preset = preset;    return GUI_SUCCESS;}