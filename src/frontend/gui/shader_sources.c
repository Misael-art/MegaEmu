#include "shaders.h"// Shader básico (vertex shader)const char *GUI_VERTEX_SHADER_BASIC =    "#version 330 core\n"    "layout (location = 0) in vec2 aPos;\n"    "layout (location = 1) in vec2 aTexCoord;\n"    "out vec2 TexCoord;\n"    "void main()\n"    "{\n"    "    gl_Position = vec4(aPos, 0.0, 1.0);\n"    "    TexCoord = aTexCoord;\n"    "}\n";// Shader básico (fragment shader)const char *GUI_FRAGMENT_SHADER_BASIC =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "void main()\n"    "{\n"    "    FragColor = texture(texture0, TexCoord);\n"    "}\n";// Shader de blur gaussianoconst char *GUI_FRAGMENT_SHADER_BLUR =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "uniform float radius;\n"    "uniform vec2 resolution;\n"    // Função para aplicar o blur    "void main()\n"    "{\n"    "    vec2 texelSize = 1.0 / resolution;\n"    "    float r = radius;\n"    "    vec4 result = vec4(0.0);\n"    "    float total = 0.0;\n"    "    \n"    "    // Aplicar aproximação de blur gaussiano\n"    "    for(float x = -r; x <= r; x += 1.0) {\n"    "        for(float y = -r; y <= r; y += 1.0) {\n"    "            vec2 offset = vec2(x, y) * texelSize;\n"    "            float weight = exp(-(x*x + y*y) / (2.0 * r * r));\n"    "            result += texture(texture0, TexCoord + offset) * weight;\n"    "            total += weight;\n"    "        }\n"    "    }\n"    "    \n"    "    FragColor = result / total;\n"    "}\n";// Shader de efeito CRTconst char *GUI_FRAGMENT_SHADER_CRT =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "uniform float curvature;\n"    "uniform float vignette;\n"    "uniform float scanline_intensity;\n"    "uniform vec2 resolution;\n"    "\n"    "vec2 curve(vec2 uv) {\n"    "    uv = uv * 2.0 - 1.0;\n"    "    vec2 offset = abs(uv.yx) / vec2(curvature, curvature);\n"    "    uv = uv + uv * offset * offset;\n"    "    uv = uv * 0.5 + 0.5;\n"    "    return uv;\n"    "}\n"    "\n"    "void main() {\n"    "    vec2 uv = TexCoord;\n"    "    \n"    "    // Aplicar curvatura\n"    "    uv = curve(uv);\n"    "    \n"    "    // Verificar limites\n"    "    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n"    "        FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"    "        return;\n"    "    }\n"    "    \n"    "    // Aplicar textura\n"    "    vec4 texColor = texture(texture0, uv);\n"    "    \n"    "    // Aplicar scanlines\n"    "    float scanline = sin(uv.y * resolution.y * 1.0) * 0.5 + 0.5;\n"    "    texColor.rgb *= 1.0 - (scanline * scanline_intensity);\n"    "    \n"    "    // Aplicar vignette\n"    "    float vig = (1.0 - vignette * length(uv - 0.5));\n"    "    vig = pow(vig, 1.5);\n"    "    texColor.rgb *= vig;\n"    "    \n"    "    FragColor = texColor;\n"    "}\n";// Shader de efeito Waveconst char *GUI_FRAGMENT_SHADER_WAVE =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "uniform float time;\n"    "uniform float amplitude;\n"    "uniform float frequency;\n"    "\n"    "void main() {\n"    "    vec2 uv = TexCoord;\n"    "    \n"    "    // Aplicar distorção de onda\n"    "    uv.x += sin(uv.y * frequency + time) * amplitude;\n"    "    uv.y += sin(uv.x * frequency * 0.5 + time * 0.7) * amplitude * 0.5;\n"    "    \n"    "    // Verificar limites\n"    "    vec4 texColor;\n"    "    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n"    "        texColor = vec4(0.0, 0.0, 0.0, 0.0);\n"    "    } else {\n"    "        texColor = texture(texture0, uv);\n"    "    }\n"    "    \n"    "    FragColor = texColor;\n"    "}\n";// Shader de correção de corconst char *GUI_FRAGMENT_SHADER_COLOR_CORRECTION =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "uniform float brightness;\n"    "uniform float contrast;\n"    "uniform float saturation;\n"    "uniform float gamma;\n"    "\n"    "void main() {\n"    "    vec4 color = texture(texture0, TexCoord);\n"    "    \n"    "    // Aplicar brilho\n"    "    color.rgb += brightness;\n"    "    \n"    "    // Aplicar contraste\n"    "    color.rgb = (color.rgb - 0.5) * contrast + 0.5;\n"    "    \n"    "    // Aplicar saturação\n"    "    float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n"    "    color.rgb = mix(vec3(luminance), color.rgb, saturation);\n"    "    \n"    "    // Aplicar gamma\n"    "    color.rgb = pow(color.rgb, vec3(1.0 / gamma));\n"    "    \n"    "    FragColor = color;\n"    "}\n";// Shader de aberração cromáticaconst char *GUI_FRAGMENT_SHADER_CHROMATIC_ABERRATION =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "uniform float intensity;\n"    "uniform float angle;\n"    "\n"    "void main() {\n"    "    vec2 center = vec2(0.5, 0.5);\n"    "    vec2 dir = normalize(TexCoord - center);\n"    "    float dist = distance(TexCoord, center);\n"    "    \n"    "    float r_offset = dist * intensity;\n"    "    float g_offset = dist * intensity * 0.6;\n"    "    float b_offset = dist * intensity * 0.3;\n"    "    \n"    "    float r = texture(texture0, TexCoord - dir * r_offset).r;\n"    "    float g = texture(texture0, TexCoord - dir * g_offset).g;\n"    "    float b = texture(texture0, TexCoord - dir * b_offset).b;\n"    "    float a = texture(texture0, TexCoord).a;\n"    "    \n"    "    FragColor = vec4(r, g, b, a);\n"    "}\n";// Shader de motion blurconst char *GUI_FRAGMENT_SHADER_MOTION_BLUR =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "uniform sampler2D texture_prev;\n"    "uniform float intensity;\n"    "uniform float angle;\n"    "\n"    "void main() {\n"    "    vec4 current = texture(texture0, TexCoord);\n"    "    vec4 previous = texture(texture_prev, TexCoord);\n"    "    \n"    "    FragColor = mix(current, previous, intensity);\n"    "}\n";// Shader de bloomconst char *GUI_FRAGMENT_SHADER_BLOOM =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "uniform sampler2D bloom_texture;\n"    "uniform float threshold;\n"    "uniform float intensity;\n"    "\n"    "void main() {\n"    "    vec4 color = texture(texture0, TexCoord);\n"    "    vec4 bloom = texture(bloom_texture, TexCoord);\n"    "    \n"    "    // Extrair brilho\n"    "    float brightness = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n"    "    vec4 bright_color = brightness > threshold ? color : vec4(0.0);\n"    "    \n"    "    // Combinar com bloom\n"    "    FragColor = color + bloom * intensity;\n"    "}\n";// Shader de HDRconst char *GUI_FRAGMENT_SHADER_HDR =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D texture0;\n"    "uniform float exposure;\n"    "uniform float gamma;\n"    "\n"    "void main() {\n"    "    vec4 color = texture(texture0, TexCoord);\n"    "    \n"    "    // Tone mapping HDR -> LDR\n"    "    vec3 mapped = vec3(1.0) - exp(-color.rgb * exposure);\n"    "    \n"    "    // Gamma correction\n"    "    mapped = pow(mapped, vec3(1.0 / gamma));\n"    "    \n"    "    FragColor = vec4(mapped, color.a);\n"    "}\n";