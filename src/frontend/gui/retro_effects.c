#include "retro_effects.h"#include <stdlib.h>#include <string.h>#include <math.h>// Inicialização do sistemagui_result_t retro_effects_init(retro_effect_system_t *system,                                gui_shader_system_t *shaders,                                int source_width,                                int source_height){    if (!system || !shaders || source_width <= 0 || source_height <= 0)        return GUI_ERROR_INVALID_PARAM;    system->shader_system = shaders;    system->source_width = source_width;    system->source_height = source_height;    system->target_width = source_width;    system->target_height = source_height;    system->buffer_texture = NULL;    system->lut_texture = NULL;    system->initialized = GUI_TRUE;    // Configurar parâmetros padrão    memset(&system->params, 0, sizeof(retro_effect_params_t));    // Escala    system->params.scale.mode = RETRO_SCALE_INTEGER;    system->params.scale.scale_factor = 1.0f;    system->params.scale.letterbox = GUI_TRUE;    system->params.scale.integer_only = GUI_TRUE;    system->params.scale.sharpness = 1.0f;    // CRT    system->params.crt.curvature = 0.1f;    system->params.crt.scanline_intensity = 0.3f;    system->params.crt.mask_intensity = 0.2f;    system->params.crt.bleed = 0.1f;    system->params.crt.brightness = 1.1f;    system->params.crt.contrast = 1.2f;    system->params.crt.saturation = 1.1f;    system->params.crt.vignette = 0.2f;    system->params.crt.phosphor = GUI_TRUE;    // Dithering    system->params.dither.type = RETRO_DITHER_ORDERED;    system->params.dither.strength = 0.5f;    system->params.dither.pattern_size = 8;    system->params.dither.threshold = 0.5f;    system->params.dither.color_dither = GUI_TRUE;    // Cor    system->params.color.color_depth = 32;    system->params.color.gamma = 2.2f;    system->params.color.palette_size = 0;    system->params.color.use_lut = GUI_FALSE;    system->params.color.lut_path = NULL;    // Bloom    system->params.bloom.intensity = 0.3f;    system->params.bloom.threshold = 0.7f;    system->params.bloom.radius = 5.0f;    system->params.bloom.tint = (gui_color_t){255, 255, 255, 255};    system->params.global_intensity = 1.0f;    return GUI_SUCCESS;}// Finalização do sistemavoid retro_effects_shutdown(retro_effect_system_t *system){    if (!system)        return;    if (system->buffer_texture)    {        SDL_DestroyTexture(system->buffer_texture);        system->buffer_texture = NULL;    }    if (system->lut_texture)    {        SDL_DestroyTexture(system->lut_texture);        system->lut_texture = NULL;    }    system->initialized = GUI_FALSE;}// Configurar tamanho do alvogui_result_t retro_effects_set_target_size(retro_effect_system_t *system,                                           int width,                                           int height){    if (!system || width <= 0 || height <= 0)        return GUI_ERROR_INVALID_PARAM;    system->target_width = width;    system->target_height = height;    // Recriar buffer se necessário    if (system->buffer_texture)    {        SDL_DestroyTexture(system->buffer_texture);        system->buffer_texture = NULL;    }    system->buffer_texture = SDL_CreateTexture(        system->shader_system->renderer,        SDL_PIXELFORMAT_RGBA8888,        SDL_TEXTUREACCESS_TARGET,        width, height);    if (!system->buffer_texture)        return GUI_ERROR_INIT_FAILED;    return GUI_SUCCESS;}// Configurar parâmetrosgui_result_t retro_effects_set_params(retro_effect_system_t *system,                                      const retro_effect_params_t *params){    if (!system || !params)        return GUI_ERROR_INVALID_PARAM;    system->params = *params;    return GUI_SUCCESS;}// Carregar LUTgui_result_t retro_effects_load_lut(retro_effect_system_t *system,                                    const char *lut_path){    if (!system || !lut_path)        return GUI_ERROR_INVALID_PARAM;    // Limpar LUT anterior    if (system->lut_texture)    {        SDL_DestroyTexture(system->lut_texture);        system->lut_texture = NULL;    }    // Carregar nova LUT    SDL_Surface *surface = SDL_LoadBMP(lut_path);    if (!surface)        return GUI_ERROR_FILE_READ;    system->lut_texture = SDL_CreateTextureFromSurface(        system->shader_system->renderer,        surface);    SDL_FreeSurface(surface);    if (!system->lut_texture)        return GUI_ERROR_INIT_FAILED;    system->params.color.use_lut = GUI_TRUE;    system->params.color.lut_path = lut_path;    return GUI_SUCCESS;}// Início de framegui_result_t retro_effects_begin_frame(retro_effect_system_t *system,                                       SDL_Texture *target){    if (!system || !system->initialized || !target)        return GUI_ERROR_INVALID_PARAM;    // Iniciar sistema de shaders    return gui_shaders_begin(system->shader_system, target);}// Aplicar efeitosgui_result_t retro_effects_apply(retro_effect_system_t *system,                                 SDL_Texture *source,                                 SDL_Texture *target){    if (!system || !system->initialized || !source || !target)        return GUI_ERROR_INVALID_PARAM;    // Aplicar efeitos na ordem correta    SDL_Texture *current = source;    // 1. Pixel Perfect Scaling    if (system->params.scale.mode != RETRO_SCALE_AUTO)    {        retro_effect_apply_pixel_perfect(system, current, system->buffer_texture,                                         &system->params.scale);        current = system->buffer_texture;    }    // 2. Dithering    if (system->params.dither.type != RETRO_DITHER_NONE)    {        retro_effect_apply_dithering(system, current, system->buffer_texture,                                     &system->params.dither);        current = system->buffer_texture;    }    // 3. Color Grading    if (system->params.color.use_lut || system->params.color.color_depth < 32)    {        retro_effect_apply_color_grading(system, current, system->buffer_texture,                                         &system->params.color);        current = system->buffer_texture;    }    // 4. CRT Effect    retro_effect_apply_crt(system, current, system->buffer_texture,                           &system->params.crt);    current = system->buffer_texture;    // 5. Bloom    if (system->params.bloom.intensity > 0.0f)    {        retro_effect_apply_bloom(system, current, system->buffer_texture,                                 &system->params.bloom);        current = system->buffer_texture;    }    // Renderizar resultado final    SDL_SetRenderTarget(system->shader_system->renderer, target);    SDL_RenderCopy(system->shader_system->renderer, current, NULL, NULL);    return GUI_SUCCESS;}// Fim de framegui_result_t retro_effects_end_frame(retro_effect_system_t *system){    if (!system || !system->initialized)        return GUI_ERROR_INVALID_PARAM;    return gui_shaders_end(system->shader_system);}// Calcular viewportgui_result_t retro_effects_calculate_viewport(retro_effect_system_t *system,                                              SDL_Rect *viewport){    if (!system || !viewport)        return GUI_ERROR_INVALID_PARAM;    float src_aspect = (float)system->source_width / system->source_height;    float dst_aspect = (float)system->target_width / system->target_height;    if (system->params.scale.letterbox)    {        // Calcular viewport com letterboxing        if (src_aspect > dst_aspect)        {            viewport->w = system->target_width;            viewport->h = (int)(system->target_width / src_aspect);            viewport->x = 0;            viewport->y = (system->target_height - viewport->h) / 2;        }        else        {            viewport->h = system->target_height;            viewport->w = (int)(system->target_height * src_aspect);            viewport->x = (system->target_width - viewport->w) / 2;            viewport->y = 0;        }    }    else    {        // Viewport em tela cheia        viewport->x = 0;        viewport->y = 0;        viewport->w = system->target_width;        viewport->h = system->target_height;    }    return GUI_SUCCESS;}// Gerar paleta de coresgui_result_t retro_effects_generate_palette(retro_effect_system_t *system,                                            int num_colors){    if (!system || num_colors <= 0 || num_colors > 256)        return GUI_ERROR_INVALID_PARAM;    // Gerar paleta usando algoritmo de quantização de cores    // Por simplicidade, vamos usar uma paleta uniforme    int r_levels = (int)cbrt(num_colors);    int g_levels = r_levels;    int b_levels = num_colors / (r_levels * g_levels);    system->params.color.palette_size = 0;    for (int r = 0; r < r_levels; r++)    {        for (int g = 0; g < g_levels; g++)        {            for (int b = 0; b < b_levels; b++)            {                if (system->params.color.palette_size >= 256)                    break;                gui_color_t color;                color.r = (uint8_t)((r * 255) / (r_levels - 1));                color.g = (uint8_t)((g * 255) / (g_levels - 1));                color.b = (uint8_t)((b * 255) / (b_levels - 1));                color.a = 255;                system->params.color.palette[system->params.color.palette_size++] = color;            }        }    }    return GUI_SUCCESS;}// As implementações dos efeitos específicos (retro_effect_apply_*) serão feitas// nos respectivos arquivos de shader GLSL