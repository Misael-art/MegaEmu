#include "vol_effects_integration.h"#include "volumetric_effects.h"#include "sdl2_backend.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <SDL2/SDL.h>#include <SDL2/SDL_opengl.h>#include <GL/glew.h>#include "utils/log.h"#include <math.h>#define MAX_PARTICLES 10000#define PARTICLE_BATCH_SIZE 100#define PARTICLE_LIFE 2.0f// Estrutura para dados específicos do backend SDL2typedef struct{    SDL_GLContext gl_context;    SDL_Texture *mask_texture;    SDL_Texture *temp_texture;    SDL_Renderer *renderer;    // Informações da GPU    const char *gpu_name;    int max_texture_size;    // Dados de performance    float last_render_time;    int frame_count;} vol_sdl2_data_t;// Estrutura para uma partícula individualtypedef struct{    float pos[3];   // Posição x, y, z    float vel[3];   // Velocidade x, y, z    float color[4]; // Cor RGBA    float life;     // Tempo de vida restante    float size;     // Tamanho da partícula    bool active;    // Se a partícula está ativa} particle_t;// Estrutura para o sistema de partículastypedef struct{    particle_t *particles;    int max_particles;    GLuint vao;    GLuint vbo;    GLuint shader_program;    float spawn_rate;    float particle_life;} particle_system_t;static particle_system_t *particle_system = NULL;// Vertex shader para partículasstatic const char *particle_vertex_shader =    "#version 330 core\n"    "layout (location = 0) in vec3 aPos;\n"    "layout (location = 1) in vec4 aColor;\n"    "layout (location = 2) in float aSize;\n"    "uniform mat4 projection;\n"    "uniform mat4 view;\n"    "out vec4 Color;\n"    "void main() {\n"    "    gl_Position = projection * view * vec4(aPos, 1.0);\n"    "    gl_PointSize = aSize;\n"    "    Color = aColor;\n"    "}\n";// Fragment shader para partículasstatic const char *particle_fragment_shader =    "#version 330 core\n"    "in vec4 Color;\n"    "out vec4 FragColor;\n"    "void main() {\n"    "    vec2 coord = gl_PointCoord - vec2(0.5);\n"    "    float r = length(coord) * 2.0;\n"    "    float a = 1.0 - smoothstep(0.0, 1.0, r);\n"    "    FragColor = Color;\n"    "    FragColor.a *= a;\n"    "}\n";static GLuint compile_shader(const char *source, GLenum type){    GLuint shader = glCreateShader(type);    glShaderSource(shader, 1, &source, NULL);    glCompileShader(shader);    GLint success;    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);    if (!success)    {        char info_log[512];        glGetShaderInfoLog(shader, sizeof(info_log), NULL, info_log);        LOG_ERROR("Falha ao compilar shader: %s", info_log);        return 0;    }    return shader;}static GLuint create_particle_shader_program(){    GLuint vertex_shader = compile_shader(particle_vertex_shader, GL_VERTEX_SHADER);    GLuint fragment_shader = compile_shader(particle_fragment_shader, GL_FRAGMENT_SHADER);    GLuint program = glCreateProgram();    glAttachShader(program, vertex_shader);    glAttachShader(program, fragment_shader);    glLinkProgram(program);    GLint success;    glGetProgramiv(program, GL_LINK_STATUS, &success);    if (!success)    {        char info_log[512];        glGetProgramInfoLog(program, sizeof(info_log), NULL, info_log);        LOG_ERROR("Falha ao linkar programa: %s", info_log);        return 0;    }    glDeleteShader(vertex_shader);    glDeleteShader(fragment_shader);    return program;}particle_system_t *particle_system_create(int max_particles){    particle_system_t *system = malloc(sizeof(particle_system_t));    if (!system)    {        LOG_ERROR("Falha ao alocar sistema de partículas");        return NULL;    }    system->particles = malloc(sizeof(particle_t) * max_particles);    if (!system->particles)    {        LOG_ERROR("Falha ao alocar partículas");        free(system);        return NULL;    }    system->max_particles = max_particles;    system->spawn_rate = 50.0f;    system->particle_life = 2.0f;    // Inicializar partículas    for (int i = 0; i < max_particles; i++)    {        system->particles[i].active = false;    }    // Criar VAO e VBO    glGenVertexArrays(1, &system->vao);    glGenBuffers(1, &system->vbo);    glBindVertexArray(system->vao);    glBindBuffer(GL_ARRAY_BUFFER, system->vbo);    glBufferData(GL_ARRAY_BUFFER, max_particles * sizeof(particle_t), NULL, GL_DYNAMIC_DRAW);    // Posição    glEnableVertexAttribArray(0);    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(particle_t), (void *)0);    // Cor    glEnableVertexAttribArray(1);    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(particle_t),                          (void *)offsetof(particle_t, color));    // Tamanho    glEnableVertexAttribArray(2);    glVertexAttribPointer(2, 1, GL_FLOAT, GL_FALSE, sizeof(particle_t),                          (void *)offsetof(particle_t, size));    // Criar programa de shader    system->shader_program = create_particle_shader_program();    if (!system->shader_program)    {        particle_system_destroy(system);        return NULL;    }    return system;}void particle_system_destroy(particle_system_t *system){    if (!system)        return;    if (system->particles)    {        free(system->particles);    }    glDeleteVertexArrays(1, &system->vao);    glDeleteBuffers(1, &system->vbo);    glDeleteProgram(system->shader_program);    free(system);}void particle_system_emit(particle_system_t *system, float x, float y, float z,                          float *color, int count){    if (!system)        return;    for (int i = 0; i < system->max_particles && count > 0; i++)    {        if (!system->particles[i].active)        {            particle_t *p = &system->particles[i];            p->active = true;            p->pos[0] = x;            p->pos[1] = y;            p->pos[2] = z;            // Velocidade aleatória            float angle = (float)rand() / RAND_MAX * 2.0f * M_PI;            float speed = ((float)rand() / RAND_MAX * 2.0f + 1.0f);            p->vel[0] = cosf(angle) * speed;            p->vel[1] = sinf(angle) * speed;            p->vel[2] = ((float)rand() / RAND_MAX - 0.5f) * speed;            // Cor            memcpy(p->color, color, sizeof(float) * 4);            p->life = system->particle_life;            p->size = ((float)rand() / RAND_MAX * 5.0f + 5.0f);            count--;        }    }}void particle_system_update(particle_system_t *system, float dt){    if (!system)        return;    for (int i = 0; i < system->max_particles; i++)    {        particle_t *p = &system->particles[i];        if (p->active)        {            // Atualizar posição            p->pos[0] += p->vel[0] * dt;            p->pos[1] += p->vel[1] * dt;            p->pos[2] += p->vel[2] * dt;            // Aplicar gravidade            p->vel[1] -= 9.8f * dt;            // Atualizar vida            p->life -= dt;            if (p->life <= 0.0f)            {                p->active = false;                continue;            }            // Fade out            float life_factor = p->life / system->particle_life;            p->color[3] = life_factor;            p->size = life_factor * 10.0f + 5.0f;        }    }    // Atualizar VBO    glBindBuffer(GL_ARRAY_BUFFER, system->vbo);    glBufferSubData(GL_ARRAY_BUFFER, 0, system->max_particles * sizeof(particle_t),                    system->particles);}void particle_system_render(particle_system_t *system, float *projection, float *view){    if (!system)        return;    glUseProgram(system->shader_program);    // Configurar uniforms    GLint proj_loc = glGetUniformLocation(system->shader_program, "projection");    GLint view_loc = glGetUniformLocation(system->shader_program, "view");    glUniformMatrix4fv(proj_loc, 1, GL_FALSE, projection);    glUniformMatrix4fv(view_loc, 1, GL_FALSE, view);    // Configurar blending    glEnable(GL_BLEND);    glBlendFunc(GL_SRC_ALPHA, GL_ONE);    // Renderizar partículas    glBindVertexArray(system->vao);    glDrawArrays(GL_POINTS, 0, system->max_particles);    glDisable(GL_BLEND);}// Estrutura para configurações de efeitos por jogotypedef struct{    float particle_scale;    // Escala das partículas    float particle_lifetime; // Tempo de vida das partículas    float emission_rate;     // Taxa de emissão de partículas    float gravity;           // Força da gravidade    float wind_force;        // Força do vento    float turbulence;        // Intensidade da turbulência    float color_variation;   // Variação de cor    float size_variation;    // Variação de tamanho    bool use_lighting;       // Usar iluminação dinâmica    bool use_shadows;        // Usar sombras} game_effects_config_t;// Configurações padrãostatic const game_effects_config_t default_config = {    .particle_scale = 1.0f,    .particle_lifetime = 2.0f,    .emission_rate = 50.0f,    .gravity = 9.8f,    .wind_force = 0.0f,    .turbulence = 0.2f,    .color_variation = 0.1f,    .size_variation = 0.2f,    .use_lighting = true,    .use_shadows = true};// Configurações específicas por jogostatic game_effects_config_t game_configs[] = {    // RPG - Partículas maiores, mais duradouras e efeitos de iluminação    {        .particle_scale = 1.5f,        .particle_lifetime = 3.0f,        .emission_rate = 40.0f,        .gravity = 5.0f,        .wind_force = 0.5f,        .turbulence = 0.3f,        .color_variation = 0.2f,        .size_variation = 0.3f,        .use_lighting = true,        .use_shadows = true},    // Plataforma - Partículas rápidas e dinâmicas    {        .particle_scale = 0.8f,        .particle_lifetime = 1.5f,        .emission_rate = 60.0f,        .gravity = 12.0f,        .wind_force = 1.0f,        .turbulence = 0.4f,        .color_variation = 0.15f,        .size_variation = 0.25f,        .use_lighting = true,        .use_shadows = false},    // Ação - Muitas partículas e efeitos intensos    {        .particle_scale = 1.2f,        .particle_lifetime = 1.0f,        .emission_rate = 80.0f,        .gravity = 15.0f,        .wind_force = 2.0f,        .turbulence = 0.5f,        .color_variation = 0.25f,        .size_variation = 0.35f,        .use_lighting = true,        .use_shadows = true},    // Puzzle - Efeitos sutis e suaves    {        .particle_scale = 0.6f,        .particle_lifetime = 2.5f,        .emission_rate = 30.0f,        .gravity = 4.0f,        .wind_force = 0.2f,        .turbulence = 0.1f,        .color_variation = 0.05f,        .size_variation = 0.15f,        .use_lighting = true,        .use_shadows = false}};// Enumeração para tipos de jogostypedef enum{    GAME_TYPE_RPG,    GAME_TYPE_PLATFORM,    GAME_TYPE_ACTION,    GAME_TYPE_PUZZLE,    GAME_TYPE_COUNT} game_type_t;// Configuração atualstatic game_effects_config_t current_config;void vol_effects_set_game_config(game_type_t game_type){    if (game_type >= GAME_TYPE_COUNT)    {        LOG_ERROR("Tipo de jogo inválido: %d", game_type);        memcpy(&current_config, &default_config, sizeof(game_effects_config_t));        return;    }    memcpy(&current_config, &game_configs[game_type], sizeof(game_effects_config_t));    // Atualizar configurações do sistema de partículas    if (particle_system)    {        particle_system->particle_life = current_config.particle_lifetime;        particle_system->spawn_rate = current_config.emission_rate;    }}void vol_effects_update_particle(particle_t *particle, float dt){    if (!particle || !particle->active)        return;    // Aplicar gravidade    particle->vel[1] -= current_config.gravity * dt;    // Aplicar vento    particle->vel[0] += current_config.wind_force * dt;    // Aplicar turbulência    float turbulence_x = (((float)rand() / RAND_MAX) * 2.0f - 1.0f) * current_config.turbulence;    float turbulence_y = (((float)rand() / RAND_MAX) * 2.0f - 1.0f) * current_config.turbulence;    particle->vel[0] += turbulence_x * dt;    particle->vel[1] += turbulence_y * dt;    // Atualizar posição    particle->pos[0] += particle->vel[0] * dt;    particle->pos[1] += particle->vel[1] * dt;    particle->pos[2] += particle->vel[2] * dt;    // Atualizar vida    particle->life -= dt;    if (particle->life <= 0.0f)    {        particle->active = false;        return;    }    // Fade out com base no tempo de vida    float life_factor = particle->life / current_config.particle_lifetime;    particle->color[3] = life_factor;    // Aplicar variação de cor    for (int i = 0; i < 3; i++)    {        float color_var = (((float)rand() / RAND_MAX) * 2.0f - 1.0f) * current_config.color_variation;        particle->color[i] = fmaxf(0.0f, fminf(1.0f, particle->color[i] + color_var * dt));    }    // Aplicar variação de tamanho    float size_var = (((float)rand() / RAND_MAX) * 2.0f - 1.0f) * current_config.size_variation;    particle->size = fmaxf(1.0f, particle->size + size_var * dt);    particle->size *= current_config.particle_scale;}void vol_effects_emit_particles(particle_system_t *system, float x, float y, float z,                                float *base_color, int count){    if (!system)        return;    for (int i = 0; i < system->max_particles && count > 0; i++)    {        if (!system->particles[i].active)        {            particle_t *p = &system->particles[i];            p->active = true;            p->pos[0] = x;            p->pos[1] = y;            p->pos[2] = z;            // Velocidade aleatória com base nas configurações            float angle = (float)rand() / RAND_MAX * 2.0f * M_PI;            float speed = ((float)rand() / RAND_MAX * 2.0f + 1.0f);            p->vel[0] = cosf(angle) * speed;            p->vel[1] = sinf(angle) * speed;            p->vel[2] = ((float)rand() / RAND_MAX - 0.5f) * speed;            // Aplicar variações iniciais de cor            memcpy(p->color, base_color, sizeof(float) * 4);            for (int j = 0; j < 3; j++)            {                float color_var = (((float)rand() / RAND_MAX) * 2.0f - 1.0f) *                                  current_config.color_variation;                p->color[j] = fmaxf(0.0f, fminf(1.0f, p->color[j] + color_var));            }            // Configurar vida e tamanho            p->life = current_config.particle_lifetime *                      (1.0f + ((float)rand() / RAND_MAX - 0.5f) * 0.2f);            p->size = (5.0f + ((float)rand() / RAND_MAX * 5.0f)) *                      current_config.particle_scale;            count--;        }    }}// Inicializa o sistema de efeitos volumétricos e integra com SDL2bool vol_effects_init_with_sdl2(vol_effects_state_t *state, gui_sdl2_backend_t *sdl2_backend,                                const char *shader_path, int quality_level){    if (!state || !sdl2_backend || !sdl2_backend->renderer)    {        return false;    }    // Criar contexto GL para o renderer SDL2    SDL_GLContext gl_context = SDL_GL_CreateContext(sdl2_backend->window);    if (!gl_context)    {        fprintf(stderr, "Falha ao criar contexto OpenGL: %s\n", SDL_GetError());        return false;    }    // Verificar suporte a shaders    int major, minor;    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, &major);    SDL_GL_GetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, &minor);    printf("Versão OpenGL: %d.%d\n", major, minor);    if (major < 3 || (major == 3 && minor < 0))    {        fprintf(stderr, "OpenGL 3.0 ou superior é necessário para efeitos volumétricos\n");        SDL_GL_DeleteContext(gl_context);        return false;    }    // Alocar dados específicos do backend SDL2    vol_sdl2_data_t *sdl2_data = (vol_sdl2_data_t *)malloc(sizeof(vol_sdl2_data_t));    if (!sdl2_data)    {        SDL_GL_DeleteContext(gl_context);        return false;    }    memset(sdl2_data, 0, sizeof(vol_sdl2_data_t));    sdl2_data->gl_context = gl_context;    sdl2_data->renderer = sdl2_backend->renderer;    // Obter informações da GPU    sdl2_data->gpu_name = (const char *)glGetString(GL_RENDERER);    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &sdl2_data->max_texture_size);    printf("GPU: %s\n", sdl2_data->gpu_name);    printf("Tamanho máximo de textura: %d\n", sdl2_data->max_texture_size);    // Criar texturas de trabalho    sdl2_data->mask_texture = SDL_CreateTexture(        sdl2_backend->renderer,        SDL_PIXELFORMAT_RGBA8888,        SDL_TEXTUREACCESS_TARGET,        sdl2_backend->window_size.width,        sdl2_backend->window_size.height);    sdl2_data->temp_texture = SDL_CreateTexture(        sdl2_backend->renderer,        SDL_PIXELFORMAT_RGBA8888,        SDL_TEXTUREACCESS_TARGET,        sdl2_backend->window_size.width,        sdl2_backend->window_size.height);    if (!sdl2_data->mask_texture || !sdl2_data->temp_texture)    {        fprintf(stderr, "Falha ao criar texturas de trabalho: %s\n", SDL_GetError());        if (sdl2_data->mask_texture)            SDL_DestroyTexture(sdl2_data->mask_texture);        if (sdl2_data->temp_texture)            SDL_DestroyTexture(sdl2_data->temp_texture);        SDL_GL_DeleteContext(gl_context);        free(sdl2_data);        return false;    }    // Configurar inicialização do sistema de efeitos volumétricos    vol_init_config_t config;    memset(&config, 0, sizeof(vol_init_config_t));    config.backend_type = VOL_BACKEND_SDL2_GL;    config.width = sdl2_backend->window_size.width;    config.height = sdl2_backend->window_size.height;    config.quality_level = quality_level > 0 ? quality_level : vol_effects_detect_optimal_quality();    config.shader_path = shader_path;    config.backend_data = sdl2_data;    // Inicializar sistema de efeitos    if (!vol_effects_init(state, &config))    {        fprintf(stderr, "Falha ao inicializar sistema de efeitos volumétricos\n");        SDL_DestroyTexture(sdl2_data->mask_texture);        SDL_DestroyTexture(sdl2_data->temp_texture);        SDL_GL_DeleteContext(gl_context);        free(sdl2_data);        return false;    }    printf("Sistema de efeitos volumétricos inicializado (qualidade: %d)\n", config.quality_level);    return true;}// Aplica efeitos volumétricos ao frame atual da emulaçãobool vol_effects_apply_to_frame(vol_effects_state_t *state, gui_sdl2_backend_t *sdl2_backend,                                SDL_Texture *source_texture, SDL_Texture *target_texture){    if (!state || !state->initialized || !sdl2_backend || !source_texture || !target_texture)    {        return false;    }    // Se efeitos estiverem desativados, apenas copia a textura    if (!state->effects_enabled)    {        SDL_SetRenderTarget(sdl2_backend->renderer, target_texture);        SDL_RenderCopy(sdl2_backend->renderer, source_texture, NULL, NULL);        return true;    }    // Obter dados específicos do backend    vol_sdl2_data_t *sdl2_data = NULL;    if (state->renderer_data)    {        sdl2_data = ((vol_gl_renderer_t *)state->renderer_data)->backend_handle;    }    if (!sdl2_data)    {        // Fallback sem efeitos        SDL_SetRenderTarget(sdl2_backend->renderer, target_texture);        SDL_RenderCopy(sdl2_backend->renderer, source_texture, NULL, NULL);        return false;    }    // Preparar rendering    if (!vol_effects_begin_frame(state))    {        return false;    }    // Aplicar efeitos    bool result = vol_effects_render(state, source_texture, target_texture);    // Finalizar rendering    vol_effects_end_frame(state);    // Atualizar estatísticas    sdl2_data->frame_count++;    return result;}// Obtém textura da máscara de obstáculos de luz da cenaSDL_Texture *vol_effects_create_light_mask(vol_effects_state_t *state, gui_sdl2_backend_t *sdl2_backend,                                           int width, int height){    if (!state || !state->initialized || !sdl2_backend)    {        return NULL;    }    // Obter dados específicos do backend    vol_sdl2_data_t *sdl2_data = NULL;    if (state->renderer_data)    {        sdl2_data = ((vol_gl_renderer_t *)state->renderer_data)->backend_handle;    }    if (!sdl2_data)    {        return NULL;    }    // Verificar se as dimensões mudaram    if (!sdl2_data->mask_texture ||        width != sdl2_backend->window_size.width ||        height != sdl2_backend->window_size.height)    {        // Recriar textura com novas dimensões        if (sdl2_data->mask_texture)        {            SDL_DestroyTexture(sdl2_data->mask_texture);        }        sdl2_data->mask_texture = SDL_CreateTexture(            sdl2_backend->renderer,            SDL_PIXELFORMAT_RGBA8888,            SDL_TEXTUREACCESS_TARGET,            width,            height);        if (!sdl2_data->mask_texture)        {            return NULL;        }    }    // Limpar textura    SDL_SetRenderTarget(sdl2_backend->renderer, sdl2_data->mask_texture);    SDL_SetRenderDrawColor(sdl2_backend->renderer, 0, 0, 0, 0);    SDL_RenderClear(sdl2_backend->renderer);    // Restaurar target padrão    SDL_SetRenderTarget(sdl2_backend->renderer, NULL);    return sdl2_data->mask_texture;}// Adiciona os elementos de UI para controle dos efeitos no sistema do emuladorbool vol_effects_add_ui_controls(vol_effects_state_t *state){    // Esta função depende da implementação de UI do emulador    // Por enquanto, apenas um placeholder    return true;}// Define preset com base no jogo que está sendo executadobool vol_effects_select_preset_for_game(vol_effects_state_t *state, const char *rom_path,                                        const char *platform_name){    if (!state || !state->initialized || !platform_name)    {        return false;    }    // Usar o nome da plataforma para selecionar o preset base    bool preset_loaded = false;    if (strcmp(platform_name, "nes") == 0)    {        preset_loaded = vol_effects_load_preset(state, "nes");    }    else if (strcmp(platform_name, "snes") == 0)    {        preset_loaded = vol_effects_load_preset(state, "snes");    }    else if (strcmp(platform_name, "megadrive") == 0 || strcmp(platform_name, "genesis") == 0)    {        preset_loaded = vol_effects_load_preset(state, "megadrive");    }    else    {        // Plataforma desconhecida, usar preset genérico        vol_effects_load_preset(state, "nes"); // NES tem o preset mais leve        preset_loaded = true;    }    // TODO: Ajustar configurações específicas por jogo    // Poderia usar uma base de dados de jogos para configurações otimizadas    return preset_loaded;}// Salva configurações personalizadas do usuáriobool vol_effects_save_user_settings(vol_effects_state_t *state, const char *config_path){    if (!state || !state->initialized || !config_path)    {        return false;    }    FILE *file = fopen(config_path, "wb");    if (!file)    {        fprintf(stderr, "Não foi possível abrir arquivo de configuração para escrita: %s\n", config_path);        return false;    }    // Versão do arquivo    const uint32_t version = 1;    fwrite(&version, sizeof(uint32_t), 1, file);    // Configurações de efeitos    fwrite(&state->light, sizeof(vol_light_config_t), 1, file);    fwrite(&state->water, sizeof(vol_water_reflection_t), 1, file);    fwrite(&state->weather, sizeof(vol_weather_config_t), 1, file);    fwrite(&state->dof, sizeof(vol_dof_config_t), 1, file);    fwrite(&state->particles, sizeof(vol_particle_config_t), 1, file);    // Configurações gerais    fwrite(&state->quality_level, sizeof(int), 1, file);    fwrite(&state->effects_enabled, sizeof(bool), 1, file);    fclose(file);    return true;}// Carrega configurações personalizadas do usuáriobool vol_effects_load_user_settings(vol_effects_state_t *state, const char *config_path){    if (!state || !state->initialized || !config_path)    {        return false;    }    FILE *file = fopen(config_path, "rb");    if (!file)    {        fprintf(stderr, "Não foi possível abrir arquivo de configuração para leitura: %s\n", config_path);        return false;    }    // Verificar versão do arquivo    uint32_t version;    if (fread(&version, sizeof(uint32_t), 1, file) != 1 || version != 1)    {        fprintf(stderr, "Versão do arquivo de configuração incompatível\n");        fclose(file);        return false;    }    // Ler configurações de efeitos    if (fread(&state->light, sizeof(vol_light_config_t), 1, file) != 1 ||        fread(&state->water, sizeof(vol_water_reflection_t), 1, file) != 1 ||        fread(&state->weather, sizeof(vol_weather_config_t), 1, file) != 1 ||        fread(&state->dof, sizeof(vol_dof_config_t), 1, file) != 1 ||        fread(&state->particles, sizeof(vol_particle_config_t), 1, file) != 1)    {        fprintf(stderr, "Erro ao ler configurações de efeitos\n");        fclose(file);        return false;    }    // Ler configurações gerais    int quality_level;    bool effects_enabled;    if (fread(&quality_level, sizeof(int), 1, file) != 1 ||        fread(&effects_enabled, sizeof(bool), 1, file) != 1)    {        fprintf(stderr, "Erro ao ler configurações gerais\n");        fclose(file);        return false;    }    // Aplicar configurações gerais    vol_effects_set_quality(state, quality_level);    vol_effects_enable(state, effects_enabled);    fclose(file);    return true;}// Identifica elementos na cena que podem servir de fonte de luzbool vol_effects_detect_light_sources(vol_effects_state_t *state, SDL_Texture *game_frame,                                      vol_vector2_t *out_positions, int *out_count, int max_count){    // Função avançada que requer análise de imagem    // Implementação básica que simplesmente define uma luz central    if (!state || !state->initialized || !out_positions || !out_count || max_count <= 0)    {        return false;    }    // Por enquanto, apenas retornar uma posição central    out_positions[0].x = 0.5f;    out_positions[0].y = 0.5f;    *out_count = 1;    return true;}// Gera eventos de partículas baseados na gameplaybool vol_effects_trigger_gameplay_particles(vol_effects_state_t *state,                                            vol_vector2_t position,                                            int effect_type){    // Função que será expandida no futuro para suportar diferentes tipos de efeitos    if (!state || !state->initialized)    {        return false;    }    // TODO: Implementar sistema de partículas vinculado a eventos de gameplay    return true;}// Atualiza os efeitos com base em alterações de configuração em tempo realvoid vol_effects_update_config(vol_effects_state_t *state){    if (!state || !state->initialized || !state->renderer_data)    {        return;    }    // Obter renderer OpenGL    vol_gl_renderer_t *renderer = (vol_gl_renderer_t *)state->renderer_data;    // Atualizar uniforms nos shaders    // Este stub será implementado quando as funções OpenGL estiverem completas}// Implementa detector de melhor qualidade com base no hardwareint vol_effects_detect_optimal_quality(void){    // Simple heuristic for now    const char *renderer_str = (const char *)glGetString(GL_RENDERER);    // Se não conseguir obter informações da GPU, usar qualidade média    if (!renderer_str)    {        return 3;    }    // Converter para minúsculas para comparação simplificada    char renderer_lower[256] = {0};    strncpy(renderer_lower, renderer_str, 255);    for (int i = 0; renderer_lower[i]; i++)    {        renderer_lower[i] = tolower(renderer_lower[i]);    }    // Detectar GPUs de alta performance    if (strstr(renderer_lower, "rtx") ||        strstr(renderer_lower, "geforce") ||        strstr(renderer_lower, "radeon rx") ||        strstr(renderer_lower, "quadro"))    {        return 5; // Alta qualidade    }    // GPUs integradas ou de menor performance    if (strstr(renderer_lower, "intel") ||        strstr(renderer_lower, "hd graphics") ||        strstr(renderer_lower, "uhd graphics"))    {        return 2; // Qualidade mais baixa    }    // GPU desconhecida ou média    return 3; // Qualidade média}int vol_effects_init_particle_system(){    // Inicializar partículas    memset(&particle_system, 0, sizeof(particle_system));    // Criar VAO e VBO    glGenVertexArrays(1, &particle_system.vao);    glGenBuffers(1, &particle_system.vbo);    glBindVertexArray(particle_system.vao);    glBindBuffer(GL_ARRAY_BUFFER, particle_system.vbo);    glBufferData(GL_ARRAY_BUFFER, MAX_PARTICLES * sizeof(particle_t), NULL, GL_DYNAMIC_DRAW);    // Configurar atributos    glEnableVertexAttribArray(0); // Posição    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(particle_t), (void *)offsetof(particle_t, x));    glEnableVertexAttribArray(1); // Cor    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(particle_t), (void *)offsetof(particle_t, r));    glEnableVertexAttribArray(2); // Tamanho    glVertexAttribPointer(2, 1, GL_FLOAT, GL_FALSE, sizeof(particle_t), (void *)offsetof(particle_t, size));    // Criar programa de shader    particle_system.shader_program = create_particle_shader_program();    if (!particle_system.shader_program)    {        LOG_ERROR("Falha ao criar programa de shader para partículas");        return -1;    }    // Criar textura de partícula    create_particle_texture();    return 0;}void vol_effects_shutdown_particle_system(){    glDeleteVertexArrays(1, &particle_system.vao);    glDeleteBuffers(1, &particle_system.vbo);    glDeleteProgram(particle_system.shader_program);    glDeleteTextures(1, &particle_system.texture);}static void emit_particle(float x, float y, float vx, float vy, float r, float g, float b, float size, float life){    if (particle_system.num_active >= MAX_PARTICLES)    {        return;    }    // Encontrar slot livre    for (int i = 0; i < MAX_PARTICLES; i++)    {        if (!particle_system.particles[i].active)        {            particle_t *p = &particle_system.particles[i];            p->x = x;            p->y = y;            p->vx = vx;            p->vy = vy;            p->ax = 0;            p->ay = 100.0f; // Gravidade            p->r = r;            p->g = g;            p->b = b;            p->a = 1.0f;            p->size = size;            p->life = life;            p->decay = 1.0f / life;            p->active = true;            particle_system.num_active++;            break;        }    }}void vol_effects_emit_particles(float x, float y, int count, float r, float g, float b, float size, float life){    for (int i = 0; i < count; i++)    {        float angle = (float)rand() / RAND_MAX * 2 * M_PI;        float speed = ((float)rand() / RAND_MAX * 100.0f + 50.0f);        float vx = cosf(angle) * speed;        float vy = sinf(angle) * speed;        emit_particle(x, y, vx, vy, r, g, b, size, life);    }}void vol_effects_update_particles(float dt){    for (int i = 0; i < MAX_PARTICLES; i++)    {        particle_t *p = &particle_system.particles[i];        if (p->active)        {            // Atualizar posição            p->vx += p->ax * dt;            p->vy += p->ay * dt;            p->x += p->vx * dt;            p->y += p->vy * dt;            // Atualizar vida            p->life -= dt;            p->a = p->life * p->decay;            if (p->life <= 0)            {                p->active = false;                particle_system.num_active--;            }        }    }}void vol_effects_render_particles(){    glUseProgram(particle_system.shader_program);    // Configurar uniforms    GLint proj_loc = glGetUniformLocation(particle_system.shader_program, "projection");    // Configurar matriz de projeção ortográfica aqui...    // Atualizar VBO    glBindBuffer(GL_ARRAY_BUFFER, particle_system.vbo);    glBufferSubData(GL_ARRAY_BUFFER, 0, MAX_PARTICLES * sizeof(particle_t), particle_system.particles);    // Renderizar partículas    glBindVertexArray(particle_system.vao);    glBindTexture(GL_TEXTURE_2D, particle_system.texture);    glEnable(GL_BLEND);    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);    glDrawArrays(GL_POINTS, 0, MAX_PARTICLES);    glDisable(GL_BLEND);}void vol_effects_handle_gameplay_event(gameplay_event_type_t type, float x, float y){    switch (type)    {    case GAMEPLAY_EVENT_EXPLOSION:        // Explosão grande com partículas vermelhas e laranjas        vol_effects_emit_particles(x, y, 100, 1.0f, 0.5f, 0.0f, 8.0f, 1.0f);        vol_effects_emit_particles(x, y, 50, 1.0f, 0.2f, 0.0f, 6.0f, 0.8f);        break;    case GAMEPLAY_EVENT_ITEM_COLLECT:        // Brilho dourado ao coletar item        vol_effects_emit_particles(x, y, 20, 1.0f, 0.8f, 0.0f, 4.0f, 0.5f);        break;    case GAMEPLAY_EVENT_ENEMY_DEFEAT:        // Explosão menor com partículas roxas        vol_effects_emit_particles(x, y, 30, 0.8f, 0.0f, 1.0f, 5.0f, 0.7f);        break;    case GAMEPLAY_EVENT_POWERUP:        // Aura brilhante com partículas azuis        vol_effects_emit_particles(x, y, 50, 0.0f, 0.5f, 1.0f, 6.0f, 1.2f);        break;    case GAMEPLAY_EVENT_DAMAGE:        // Faíscas vermelhas        vol_effects_emit_particles(x, y, 15, 1.0f, 0.0f, 0.0f, 3.0f, 0.3f);        break;    case GAMEPLAY_EVENT_HEAL:        // Brilho verde de cura        vol_effects_emit_particles(x, y, 25, 0.0f, 1.0f, 0.2f, 5.0f, 0.8f);        break;    case GAMEPLAY_EVENT_SPEED_BOOST:        // Rastro de velocidade azul claro        vol_effects_emit_particles(x, y, 40, 0.2f, 0.8f, 1.0f, 4.0f, 0.4f);        break;    case GAMEPLAY_EVENT_SHIELD:        // Barreira protetora branca        vol_effects_emit_particles(x, y, 60, 1.0f, 1.0f, 1.0f, 7.0f, 1.5f);        break;    default:        break;    }}