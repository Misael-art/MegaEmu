#include <vulkan/vulkan.h>#include "frontend/gui/volumetric_effects.h"#include "utils/log.h"// Estrutura para dados do backend Vulkantypedef struct{    VkDevice device;    VkRenderPass render_pass;    VkFramebuffer framebuffer;    VkImage color_image;    VkImageView color_view;    VkImage depth_image;    VkImageView depth_view;    VkImage noise_image;    VkImageView noise_view;    VkImage mask_image;    VkImageView mask_view;    VkPipeline pipeline;    VkPipelineLayout pipeline_layout;    VkBuffer vertex_buffer;    VkDeviceMemory vertex_memory;    VkDescriptorSet descriptor_set;    VkDescriptorPool descriptor_pool;    VkDescriptorSetLayout descriptor_layout;    VkSampler sampler;    VkCommandPool command_pool;    VkCommandBuffer command_buffer;} vol_vulkan_data_t;// Vertex shader em SPIR-Vstatic const uint32_t vertex_shader_spv[] = {    // Código SPIR-V do vertex shader aqui};// Fragment shader em SPIR-Vstatic const uint32_t fragment_shader_spv[] = {    // Código SPIR-V do fragment shader aqui};static VkShaderModule create_shader_module(VkDevice device, const uint32_t *code, size_t size){    VkShaderModuleCreateInfo create_info = {        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,        .codeSize = size,        .pCode = code};    VkShaderModule shader_module;    if (vkCreateShaderModule(device, &create_info, NULL, &shader_module) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar módulo de shader Vulkan");        return VK_NULL_HANDLE;    }    return shader_module;}static void create_pipeline(vol_vulkan_data_t *data){    // Criar módulos de shader    VkShaderModule vert_shader = create_shader_module(data->device,                                                      vertex_shader_spv, sizeof(vertex_shader_spv));    VkShaderModule frag_shader = create_shader_module(data->device,                                                      fragment_shader_spv, sizeof(fragment_shader_spv));    // Configurar estágios de shader    VkPipelineShaderStageCreateInfo shader_stages[2] = {        {.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,         .stage = VK_SHADER_STAGE_VERTEX_BIT,         .module = vert_shader,         .pName = "main"},        {.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,         .stage = VK_SHADER_STAGE_FRAGMENT_BIT,         .module = frag_shader,         .pName = "main"}};    // Configurar input de vértices    VkVertexInputBindingDescription binding_desc = {        .binding = 0,        .stride = sizeof(float) * 5, // pos (3) + texcoord (2)        .inputRate = VK_VERTEX_INPUT_RATE_VERTEX};    VkVertexInputAttributeDescription attr_desc[2] = {        {.binding = 0,         .location = 0,         .format = VK_FORMAT_R32G32B32_SFLOAT,         .offset = 0},        {.binding = 0,         .location = 1,         .format = VK_FORMAT_R32G32_SFLOAT,         .offset = sizeof(float) * 3}};    VkPipelineVertexInputStateCreateInfo vertex_input = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,        .vertexBindingDescriptionCount = 1,        .pVertexBindingDescriptions = &binding_desc,        .vertexAttributeDescriptionCount = 2,        .pVertexAttributeDescriptions = attr_desc};    // Configurar assembly de primitivas    VkPipelineInputAssemblyStateCreateInfo input_assembly = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,        .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,        .primitiveRestartEnable = VK_FALSE};    // Configurar viewport e scissor    VkPipelineViewportStateCreateInfo viewport_state = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,        .viewportCount = 1,        .scissorCount = 1};    // Configurar rasterização    VkPipelineRasterizationStateCreateInfo rasterizer = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,        .depthClampEnable = VK_FALSE,        .rasterizerDiscardEnable = VK_FALSE,        .polygonMode = VK_POLYGON_MODE_FILL,        .cullMode = VK_CULL_MODE_NONE,        .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE,        .depthBiasEnable = VK_FALSE};    // Configurar multisampling    VkPipelineMultisampleStateCreateInfo multisampling = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT,        .sampleShadingEnable = VK_FALSE};    // Configurar blending    VkPipelineColorBlendAttachmentState blend_attachment = {        .blendEnable = VK_TRUE,        .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA,        .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,        .colorBlendOp = VK_BLEND_OP_ADD,        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,        .alphaBlendOp = VK_BLEND_OP_ADD,        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT |                          VK_COLOR_COMPONENT_G_BIT |                          VK_COLOR_COMPONENT_B_BIT |                          VK_COLOR_COMPONENT_A_BIT};    VkPipelineColorBlendStateCreateInfo color_blending = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,        .logicOpEnable = VK_FALSE,        .attachmentCount = 1,        .pAttachments = &blend_attachment};    // Configurar estados dinâmicos    VkDynamicState dynamic_states[] = {        VK_DYNAMIC_STATE_VIEWPORT,        VK_DYNAMIC_STATE_SCISSOR};    VkPipelineDynamicStateCreateInfo dynamic_state = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,        .dynamicStateCount = 2,        .pDynamicStates = dynamic_states};    // Criar pipeline layout    VkPipelineLayoutCreateInfo pipeline_layout_info = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,        .setLayoutCount = 1,        .pSetLayouts = &data->descriptor_layout};    if (vkCreatePipelineLayout(data->device, &pipeline_layout_info, NULL,                               &data->pipeline_layout) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar pipeline layout");        return;    }    // Criar pipeline gráfico    VkGraphicsPipelineCreateInfo pipeline_info = {        .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,        .stageCount = 2,        .pStages = shader_stages,        .pVertexInputState = &vertex_input,        .pInputAssemblyState = &input_assembly,        .pViewportState = &viewport_state,        .pRasterizationState = &rasterizer,        .pMultisampleState = &multisampling,        .pColorBlendState = &color_blending,        .pDynamicState = &dynamic_state,        .layout = data->pipeline_layout,        .renderPass = data->render_pass,        .subpass = 0};    if (vkCreateGraphicsPipelines(data->device, VK_NULL_HANDLE, 1, &pipeline_info,                                  NULL, &data->pipeline) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar pipeline gráfico");    }    // Limpar    vkDestroyShaderModule(data->device, vert_shader, NULL);    vkDestroyShaderModule(data->device, frag_shader, NULL);}static void create_descriptor_set(vol_vulkan_data_t *data){    // Criar pool de descritores    VkDescriptorPoolSize pool_sizes[] = {        {            .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,            .descriptorCount = 3 // color, noise, mask        }};    VkDescriptorPoolCreateInfo pool_info = {        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,        .poolSizeCount = 1,        .pPoolSizes = pool_sizes,        .maxSets = 1};    if (vkCreateDescriptorPool(data->device, &pool_info, NULL,                               &data->descriptor_pool) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar pool de descritores");        return;    }    // Criar layout do set de descritores    VkDescriptorSetLayoutBinding bindings[] = {        {.binding = 0,         .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,         .descriptorCount = 1,         .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT},        {.binding = 1,         .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,         .descriptorCount = 1,         .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT},        {.binding = 2,         .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,         .descriptorCount = 1,         .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT}};    VkDescriptorSetLayoutCreateInfo layout_info = {        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,        .bindingCount = 3,        .pBindings = bindings};    if (vkCreateDescriptorSetLayout(data->device, &layout_info, NULL,                                    &data->descriptor_layout) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar layout do set de descritores");        return;    }    // Alocar set de descritores    VkDescriptorSetAllocateInfo alloc_info = {        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,        .descriptorPool = data->descriptor_pool,        .descriptorSetCount = 1,        .pSetLayouts = &data->descriptor_layout};    if (vkAllocateDescriptorSets(data->device, &alloc_info,                                 &data->descriptor_set) != VK_SUCCESS)    {        LOG_ERROR("Falha ao alocar set de descritores");        return;    }    // Atualizar set de descritores    VkDescriptorImageInfo image_infos[3] = {        {.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,         .imageView = data->color_view,         .sampler = data->sampler},        {.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,         .imageView = data->noise_view,         .sampler = data->sampler},        {.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,         .imageView = data->mask_view,         .sampler = data->sampler}};    VkWriteDescriptorSet descriptor_writes[3] = {        {.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,         .dstSet = data->descriptor_set,         .dstBinding = 0,         .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,         .descriptorCount = 1,         .pImageInfo = &image_infos[0]},        {.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,         .dstSet = data->descriptor_set,         .dstBinding = 1,         .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,         .descriptorCount = 1,         .pImageInfo = &image_infos[1]},        {.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,         .dstSet = data->descriptor_set,         .dstBinding = 2,         .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,         .descriptorCount = 1,         .pImageInfo = &image_infos[2]}};    vkUpdateDescriptorSets(data->device, 3, descriptor_writes, 0, NULL);}int vol_effects_init_vulkan(vol_effects_t *effects){    if (!effects)    {        LOG_ERROR("Efeitos volumétricos nulos");        return -1;    }    vol_vulkan_data_t *data = malloc(sizeof(vol_vulkan_data_t));    if (!data)    {        LOG_ERROR("Falha ao alocar dados Vulkan");        return -1;    }    // Criar sampler    VkSamplerCreateInfo sampler_info = {        .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,        .magFilter = VK_FILTER_LINEAR,        .minFilter = VK_FILTER_LINEAR,        .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,        .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,        .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT};    if (vkCreateSampler(data->device, &sampler_info, NULL, &data->sampler) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar sampler");        free(data);        return -1;    }    // Criar command pool    VkCommandPoolCreateInfo pool_info = {        .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,        .flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT};    if (vkCreateCommandPool(data->device, &pool_info, NULL,                            &data->command_pool) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar command pool");        vkDestroySampler(data->device, data->sampler, NULL);        free(data);        return -1;    }    // Alocar command buffer    VkCommandBufferAllocateInfo alloc_info = {        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,        .commandPool = data->command_pool,        .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,        .commandBufferCount = 1};    if (vkAllocateCommandBuffers(data->device, &alloc_info,                                 &data->command_buffer) != VK_SUCCESS)    {        LOG_ERROR("Falha ao alocar command buffer");        vkDestroyCommandPool(data->device, data->command_pool, NULL);        vkDestroySampler(data->device, data->sampler, NULL);        free(data);        return -1;    }    // Criar descritores    create_descriptor_set(data);    // Criar pipeline    create_pipeline(data);    effects->backend_data = data;    effects->backend_type = VOL_EFFECTS_BACKEND_VULKAN;    return 0;}void vol_effects_shutdown_vulkan(vol_effects_t *effects){    if (!effects || !effects->backend_data)    {        return;    }    vol_vulkan_data_t *data = (vol_vulkan_data_t *)effects->backend_data;    vkDestroyPipeline(data->device, data->pipeline, NULL);    vkDestroyPipelineLayout(data->device, data->pipeline_layout, NULL);    vkDestroyDescriptorPool(data->device, data->descriptor_pool, NULL);    vkDestroyDescriptorSetLayout(data->device, data->descriptor_layout, NULL);    vkDestroySampler(data->device, data->sampler, NULL);    vkDestroyCommandPool(data->device, data->command_pool, NULL);    free(data);    effects->backend_data = NULL;}void vol_effects_update_mask_vulkan(vol_effects_t *effects, const void *mask_data){    if (!effects || !effects->backend_data || !mask_data)    {        return;    }    vol_vulkan_data_t *data = (vol_vulkan_data_t *)effects->backend_data;    // Atualizar dados da textura de máscara    VkBufferImageCopy region = {        .imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,        .imageSubresource.layerCount = 1,        .imageExtent = {            .width = effects->width,            .height = effects->height,            .depth = 1}};    // Criar buffer temporário    VkBuffer staging_buffer;    VkDeviceMemory staging_memory;    // ... código para criar e copiar dados para o buffer de staging ...    // Copiar dados para a imagem    VkCommandBufferBeginInfo begin_info = {        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,        .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT};    vkBeginCommandBuffer(data->command_buffer, &begin_info);    VkImageMemoryBarrier barrier = {        .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,        .oldLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,        .newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,        .image = data->mask_image,        .subresourceRange = {            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,            .baseMipLevel = 0,            .levelCount = 1,            .baseArrayLayer = 0,            .layerCount = 1}};    vkCmdPipelineBarrier(data->command_buffer,                         VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,                         VK_PIPELINE_STAGE_TRANSFER_BIT,                         0, 0, NULL, 0, NULL, 1, &barrier);    vkCmdCopyBufferToImage(data->command_buffer,                           staging_buffer,                           data->mask_image,                           VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,                           1, &region);    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;    vkCmdPipelineBarrier(data->command_buffer,                         VK_PIPELINE_STAGE_TRANSFER_BIT,                         VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,                         0, 0, NULL, 0, NULL, 1, &barrier);    vkEndCommandBuffer(data->command_buffer);    // Submeter comando    VkSubmitInfo submit_info = {        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,        .commandBufferCount = 1,        .pCommandBuffers = &data->command_buffer};    // ... código para submeter comando e esperar conclusão ...    // Limpar recursos temporários    vkDestroyBuffer(data->device, staging_buffer, NULL);    vkFreeMemory(data->device, staging_memory, NULL);}void vol_effects_render_vulkan(vol_effects_t *effects, float dt){    if (!effects || !effects->backend_data)    {        return;    }    vol_vulkan_data_t *data = (vol_vulkan_data_t *)effects->backend_data;    VkCommandBufferBeginInfo begin_info = {        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,        .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT};    vkBeginCommandBuffer(data->command_buffer, &begin_info);    VkRenderPassBeginInfo render_pass_info = {        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,        .renderPass = data->render_pass,        .framebuffer = data->framebuffer,        .renderArea.extent = {            .width = effects->width,            .height = effects->height}};    vkCmdBeginRenderPass(data->command_buffer, &render_pass_info,                         VK_SUBPASS_CONTENTS_INLINE);    vkCmdBindPipeline(data->command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS,                      data->pipeline);    VkViewport viewport = {        .width = effects->width,        .height = effects->height,        .maxDepth = 1.0f};    vkCmdSetViewport(data->command_buffer, 0, 1, &viewport);    VkRect2D scissor = {        .extent = {            .width = effects->width,            .height = effects->height}};    vkCmdSetScissor(data->command_buffer, 0, 1, &scissor);    vkCmdBindDescriptorSets(data->command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS,                            data->pipeline_layout, 0, 1, &data->descriptor_set, 0, NULL);    // Push constants para uniforms    struct    {        float time;        float density;        float weight;        float padding;        float light_color[3];    } push_constants;    push_constants.time = effects->time;    push_constants.density = effects->density;    push_constants.weight = effects->weight;    memcpy(push_constants.light_color, effects->light_color, sizeof(float) * 3);    vkCmdPushConstants(data->command_buffer, data->pipeline_layout,                       VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(push_constants), &push_constants);    // Renderizar quad de tela cheia    vkCmdDraw(data->command_buffer, 4, 1, 0, 0);    vkCmdEndRenderPass(data->command_buffer);    vkEndCommandBuffer(data->command_buffer);    // Submeter comando    VkSubmitInfo submit_info = {        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,        .commandBufferCount = 1,        .pCommandBuffers = &data->command_buffer};    // ... código para submeter comando e esperar conclusão ...    effects->time += dt;}