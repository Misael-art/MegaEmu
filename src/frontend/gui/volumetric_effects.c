#include "volumetric_effects.h"#include <stdlib.h>#include <string.h>#include <math.h>#include <stdio.h>#include <vulkan/vulkan.h>#include "utils/log.h"#include <GL/glew.h>// Versão do sistema de efeitos#define VOL_EFFECTS_VERSION "1.0.0"// Valores padrão para luz volumétrica#define DEFAULT_LIGHT_SAMPLES 32#define DEFAULT_LIGHT_DENSITY 0.3f#define DEFAULT_LIGHT_SCATTER 32.0f#define DEFAULT_LIGHT_DECAY 1.0f#define DEFAULT_NOISE_SCALE 1.5f// Caminho padrão para shaders#define DEFAULT_SHADER_PATH "shaders/modern/"// Constantes para ruído Perlin#define PERLIN_OCTAVES 4#define PERLIN_PERSISTENCE 0.5f#define PERLIN_SCALE 0.1f// Permutação para ruído Perlinstatic const int perlin_perm[256] = {    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,    8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,    35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,    134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,    55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,    18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,    250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,    189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,    172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,    228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,    107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180};static float fade(float t){    return t * t * t * (t * (t * 6 - 15) + 10);}static float lerp(float a, float b, float t){    return a + t * (b - a);}static float grad(int hash, float x, float y, float z){    int h = hash & 15;    float u = h < 8 ? x : y;    float v = h < 4 ? y : h == 12 || h == 14 ? x                                             : z;    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);}static float noise(float x, float y, float z){    int X = (int)floor(x) & 255;    int Y = (int)floor(y) & 255;    int Z = (int)floor(z) & 255;    x -= floor(x);    y -= floor(y);    z -= floor(z);    float u = fade(x);    float v = fade(y);    float w = fade(z);    int A = perlin_perm[X] + Y;    int AA = perlin_perm[A] + Z;    int AB = perlin_perm[A + 1] + Z;    int B = perlin_perm[X + 1] + Y;    int BA = perlin_perm[B] + Z;    int BB = perlin_perm[B + 1] + Z;    return lerp(        lerp(            lerp(grad(perlin_perm[AA], x, y, z),                 grad(perlin_perm[BA], x - 1, y, z),                 u),            lerp(grad(perlin_perm[AB], x, y - 1, z),                 grad(perlin_perm[BB], x - 1, y - 1, z),                 u),            v),        lerp(            lerp(grad(perlin_perm[AA + 1], x, y, z - 1),                 grad(perlin_perm[BA + 1], x - 1, y, z - 1),                 u),            lerp(grad(perlin_perm[AB + 1], x, y - 1, z - 1),                 grad(perlin_perm[BB + 1], x - 1, y - 1, z - 1),                 u),            v),        w);}static void generate_perlin_noise(unsigned char *data, int width, int height){    float *noise_data = malloc(width * height * sizeof(float));    if (!noise_data)    {        LOG_ERROR("Falha ao alocar memória para ruído Perlin");        return;    }    // Gerar ruído Perlin com várias oitavas    for (int y = 0; y < height; y++)    {        for (int x = 0; x < width; x++)        {            float amplitude = 1.0f;            float frequency = 1.0f;            float noise_value = 0.0f;            float max_value = 0.0f;            for (int o = 0; o < PERLIN_OCTAVES; o++)            {                float sample_x = x * PERLIN_SCALE * frequency;                float sample_y = y * PERLIN_SCALE * frequency;                noise_value += noise(sample_x, sample_y, 0.0f) * amplitude;                max_value += amplitude;                amplitude *= PERLIN_PERSISTENCE;                frequency *= 2.0f;            }            noise_value = (noise_value / max_value + 1.0f) * 0.5f;            noise_data[y * width + x] = noise_value;        }    }    // Converter para bytes    for (int i = 0; i < width * height; i++)    {        data[i] = (unsigned char)(noise_data[i] * 255.0f);    }    free(noise_data);}// Estrutura interna do renderer OpenGLtypedef struct{    // IDs de shaders    unsigned int volumetric_shader;    unsigned int water_shader;    unsigned int weather_shader;    unsigned int dof_shader;    unsigned int particles_shader;    // IDs de texturas    unsigned int noise_texture;    unsigned int mask_texture;    unsigned int scene_texture;    unsigned int temp_texture;    // Framebuffers    unsigned int scene_fbo;    unsigned int mask_fbo;    unsigned int temp_fbo;    // IDs de uniforms para volumetric lighting    struct    {        int light_pos;        int light_color;        int density;        int scatter;        int decay;        int num_samples;        int use_noise;        int noise_scale;        int screen_size;        int time;    } vol_uniforms;    // Outros dados do renderer    int width;    int height;    float time_counter;    // Dados específicos do backend    void *backend_handle;} vol_gl_renderer_t;// Estruturas Vulkantypedef struct{    VkInstance instance;    VkPhysicalDevice physical_device;    VkDevice device;    VkQueue graphics_queue;    VkCommandPool command_pool;    VkCommandBuffer command_buffer;    VkRenderPass render_pass;    VkFramebuffer framebuffer;    VkPipeline pipeline;    VkPipelineLayout pipeline_layout;    VkDescriptorPool descriptor_pool;    VkDescriptorSet descriptor_set;    VkDescriptorSetLayout descriptor_layout;    VkBuffer vertex_buffer;    VkDeviceMemory vertex_memory;    VkBuffer uniform_buffer;    VkDeviceMemory uniform_memory;    VkImage texture;    VkDeviceMemory texture_memory;    VkImageView texture_view;    VkSampler sampler;} vulkan_state_t;static vulkan_state_t vk_state;// Shaders SPIR-V compilados (incluídos como arrays de bytes)extern const uint32_t volumetric_vert_spv[];extern const uint32_t volumetric_frag_spv[];extern const size_t volumetric_vert_spv_size;extern const size_t volumetric_frag_spv_size;// Estrutura para dados do backend OpenGLtypedef struct{    GLuint framebuffer;    GLuint color_texture;    GLuint depth_texture;    GLuint noise_texture;    GLuint mask_texture;    GLuint shader_program;    GLuint vao;    GLuint vbo;} vol_opengl_data_t;// Estrutura para dados do backend Vulkantypedef struct{    VkDevice device;    VkRenderPass render_pass;    VkFramebuffer framebuffer;    VkImage color_image;    VkImageView color_view;    VkImage depth_image;    VkImageView depth_view;    VkImage noise_image;    VkImageView noise_view;    VkImage mask_image;    VkImageView mask_view;    VkPipeline pipeline;    VkPipelineLayout pipeline_layout;    VkBuffer vertex_buffer;    VkDeviceMemory vertex_memory;} vol_vulkan_data_t;// Estrutura para dados do backend customizadotypedef struct{    void *render_target;    void *noise_data;    void *mask_data;    void *shader_data;    void (*render_func)(void *data, float dt);} vol_custom_data_t;// Vertex shader para efeitos volumétricosstatic const char *volumetric_vertex_shader =    "#version 330 core\n"    "layout (location = 0) in vec3 aPos;\n"    "layout (location = 1) in vec2 aTexCoord;\n"    "out vec2 TexCoord;\n"    "void main() {\n"    "    gl_Position = vec4(aPos, 1.0);\n"    "    TexCoord = aTexCoord;\n"    "}\n";// Fragment shader para efeitos volumétricosstatic const char *volumetric_fragment_shader =    "#version 330 core\n"    "in vec2 TexCoord;\n"    "out vec4 FragColor;\n"    "uniform sampler2D colorTexture;\n"    "uniform sampler2D noiseTexture;\n"    "uniform sampler2D maskTexture;\n"    "uniform float time;\n"    "uniform float density;\n"    "uniform float weight;\n"    "uniform vec3 lightColor;\n"    "void main() {\n"    "    vec2 noiseCoord = TexCoord + vec2(time * 0.1);\n"    "    float noise = texture(noiseTexture, noiseCoord).r;\n"    "    float mask = texture(maskTexture, TexCoord).r;\n"    "    vec4 color = texture(colorTexture, TexCoord);\n"    "    float volumetric = noise * mask * density;\n"    "    vec3 lightEffect = lightColor * volumetric * weight;\n"    "    FragColor = vec4(color.rgb + lightEffect, color.a);\n"    "}\n";static GLuint create_shader_program(const char *vertex_source, const char *fragment_source){    // Compilar vertex shader    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);    glShaderSource(vertex_shader, 1, &vertex_source, NULL);    glCompileShader(vertex_shader);    GLint success;    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);    if (!success)    {        char info_log[512];        glGetShaderInfoLog(vertex_shader, sizeof(info_log), NULL, info_log);        LOG_ERROR("Falha na compilação do vertex shader: %s", info_log);        return 0;    }    // Compilar fragment shader    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragment_shader, 1, &fragment_source, NULL);    glCompileShader(fragment_shader);    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);    if (!success)    {        char info_log[512];        glGetShaderInfoLog(fragment_shader, sizeof(info_log), NULL, info_log);        LOG_ERROR("Falha na compilação do fragment shader: %s", info_log);        glDeleteShader(vertex_shader);        return 0;    }    // Criar e linkar programa    GLuint program = glCreateProgram();    glAttachShader(program, vertex_shader);    glAttachShader(program, fragment_shader);    glLinkProgram(program);    glGetProgramiv(program, GL_LINK_STATUS, &success);    if (!success)    {        char info_log[512];        glGetProgramInfoLog(program, sizeof(info_log), NULL, info_log);        LOG_ERROR("Falha na linkagem do programa: %s", info_log);        glDeleteShader(vertex_shader);        glDeleteShader(fragment_shader);        return 0;    }    glDeleteShader(vertex_shader);    glDeleteShader(fragment_shader);    return program;}static void create_framebuffers_gl(vol_opengl_data_t *data, int width, int height){    // Criar framebuffer    glGenFramebuffers(1, &data->framebuffer);    glBindFramebuffer(GL_FRAMEBUFFER, data->framebuffer);    // Criar textura de cor    glGenTextures(1, &data->color_texture);    glBindTexture(GL_TEXTURE_2D, data->color_texture);    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, data->color_texture, 0);    // Criar textura de profundidade    glGenTextures(1, &data->depth_texture);    glBindTexture(GL_TEXTURE_2D, data->depth_texture);    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, data->depth_texture, 0);    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)    {        LOG_ERROR("Falha ao criar framebuffer");    }}static void create_noise_texture_opengl(vol_opengl_data_t *data){    glGenTextures(1, &data->noise_texture);    glBindTexture(GL_TEXTURE_2D, data->noise_texture);    // Gerar textura de ruído Perlin    const int noise_size = 256;    unsigned char *noise_data = malloc(noise_size * noise_size * 4);    if (noise_data)    {        generate_perlin_noise(noise_data, 256, 256);        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, noise_size, noise_size, 0, GL_RGBA, GL_UNSIGNED_BYTE, noise_data);        free(noise_data);    }    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);}static void create_mask_texture_opengl(vol_opengl_data_t *data, int width, int height){    glGenTextures(1, &data->mask_texture);    glBindTexture(GL_TEXTURE_2D, data->mask_texture);    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);}int vol_effects_init_opengl(vol_effects_state_t *state){    if (!state)    {        LOG_ERROR("Efeitos volumétricos nulos");        return -1;    }    vol_opengl_data_t *data = malloc(sizeof(vol_opengl_data_t));    if (!data)    {        LOG_ERROR("Falha ao alocar dados OpenGL");        return -1;    }    // Criar programa de shader    data->shader_program = create_shader_program(volumetric_vertex_shader, volumetric_fragment_shader);    if (!data->shader_program)    {        free(data);        return -1;    }    // Criar framebuffers    create_framebuffers_gl(data, state->width, state->height);    // Criar textura de ruído    create_noise_texture_opengl(data);    // Criar textura de máscara    create_mask_texture_opengl(data, state->width, state->height);    // Criar VAO e VBO para quad de tela cheia    float vertices[] = {        // Posições    // Coordenadas de textura        -1.0f, 1.0f, 0.0f, 0.0f, 1.0f,        -1.0f, -1.0f, 0.0f, 0.0f, 0.0f,        1.0f, 1.0f, 0.0f, 1.0f, 1.0f,        1.0f, -1.0f, 0.0f, 1.0f, 0.0f};    glGenVertexArrays(1, &data->vao);    glGenBuffers(1, &data->vbo);    glBindVertexArray(data->vao);    glBindBuffer(GL_ARRAY_BUFFER, data->vbo);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // Posição    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void *)0);    glEnableVertexAttribArray(0);    // Coordenadas de textura    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float),                          (void *)(3 * sizeof(float)));    glEnableVertexAttribArray(1);    state->renderer_data = data;    return 0;}void vol_effects_shutdown_opengl(vol_effects_state_t *state){    if (!state || !state->renderer_data)    {        return;    }    vol_opengl_data_t *data = (vol_opengl_data_t *)state->renderer_data;    glDeleteVertexArrays(1, &data->vao);    glDeleteBuffers(1, &data->vbo);    glDeleteTextures(1, &data->color_texture);    glDeleteTextures(1, &data->depth_texture);    glDeleteTextures(1, &data->noise_texture);    glDeleteTextures(1, &data->mask_texture);    glDeleteFramebuffers(1, &data->framebuffer);    glDeleteProgram(data->shader_program);    free(data);    state->renderer_data = NULL;}void vol_effects_update_mask_opengl(vol_effects_state_t *state, const void *mask_data){    if (!state || !state->renderer_data || !mask_data)    {        return;    }    vol_opengl_data_t *data = (vol_opengl_data_t *)state->renderer_data;    glBindTexture(GL_TEXTURE_2D, data->mask_texture);    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, state->width, state->height,                    GL_RGBA, GL_UNSIGNED_BYTE, mask_data);}void vol_effects_render_opengl(vol_effects_state_t *state, float dt){    if (!state || !state->renderer_data)    {        return;    }    vol_opengl_data_t *data = (vol_opengl_data_t *)state->renderer_data;    glUseProgram(data->shader_program);    // Configurar uniforms    glUniform1f(glGetUniformLocation(data->shader_program, "time"), state->time);    glUniform1f(glGetUniformLocation(data->shader_program, "density"), state->light.density);    glUniform1f(glGetUniformLocation(data->shader_program, "weight"), state->weight);    glUniform3f(glGetUniformLocation(data->shader_program, "lightColor"),                state->light.color.r, state->light.color.g, state->light.color.b);    // Configurar texturas    glActiveTexture(GL_TEXTURE0);    glBindTexture(GL_TEXTURE_2D, data->color_texture);    glUniform1i(glGetUniformLocation(data->shader_program, "colorTexture"), 0);    glActiveTexture(GL_TEXTURE1);    glBindTexture(GL_TEXTURE_2D, data->noise_texture);    glUniform1i(glGetUniformLocation(data->shader_program, "noiseTexture"), 1);    glActiveTexture(GL_TEXTURE2);    glBindTexture(GL_TEXTURE_2D, data->mask_texture);    glUniform1i(glGetUniformLocation(data->shader_program, "maskTexture"), 2);    // Renderizar quad de tela cheia    glBindVertexArray(data->vao);    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);    // Atualizar tempo    state->time += dt;}// Implementação do backend customizadoint vol_effects_init_custom(vol_effects_state_t *state){    if (!state)    {        LOG_ERROR("Efeitos volumétricos nulos");        return -1;    }    vol_custom_data_t *data = malloc(sizeof(vol_custom_data_t));    if (!data)    {        LOG_ERROR("Falha ao alocar dados do backend customizado");        return -1;    }    // Inicializar dados do backend customizado    data->render_target = malloc(state->width * state->height * 4);    data->noise_data = malloc(256 * 256 * 4);    data->mask_data = malloc(state->width * state->height * 4);    data->shader_data = malloc(1024); // Tamanho arbitrário para dados do shader    if (!data->render_target || !data->noise_data || !data->mask_data || !data->shader_data)    {        LOG_ERROR("Falha ao alocar buffers do backend customizado");        free(data->render_target);        free(data->noise_data);        free(data->mask_data);        free(data->shader_data);        free(data);        return -1;    }    // Configurar função de renderização    data->render_func = NULL; // Será definida pelo usuário    state->renderer_data = data;    return 0;}void vol_effects_shutdown_custom(vol_effects_state_t *state){    if (!state || !state->renderer_data)    {        return;    }    vol_custom_data_t *data = (vol_custom_data_t *)state->renderer_data;    free(data->render_target);    free(data->noise_data);    free(data->mask_data);    free(data->shader_data);    free(data);    state->renderer_data = NULL;}void vol_effects_update_mask_custom(vol_effects_state_t *state, const void *mask_data){    if (!state || !state->renderer_data || !mask_data)    {        return;    }    vol_custom_data_t *data = (vol_custom_data_t *)state->renderer_data;    memcpy(data->mask_data, mask_data, state->width * state->height * 4);}void vol_effects_render_custom(vol_effects_state_t *state, float dt){    if (!state || !state->renderer_data)    {        return;    }    vol_custom_data_t *data = (vol_custom_data_t *)state->renderer_data;    if (data->render_func)    {        data->render_func(data, dt);    }    state->time += dt;}// Funções principaisint vol_effects_init(vol_effects_state_t *state, const vol_init_config_t *config){    if (!state || !config)    {        return false;    }    // Limpar estrutura de estado    memset(state, 0, sizeof(vol_effects_state_t));    // Inicializar valores padrão    state->quality_level = config->quality_level > 0 ? config->quality_level : 3;    state->effects_enabled = true;    state->time = 0.0f;    state->frame_count = 0;    // Configurar luz volumétrica padrão    state->light.position.x = 0.5f;    state->light.position.y = 0.3f;    state->light.color.r = 1.0f;    state->light.color.g = 0.9f;    state->light.color.b = 0.7f;    state->light.color.a = 1.0f;    state->light.density = DEFAULT_LIGHT_DENSITY;    state->light.scatter = DEFAULT_LIGHT_SCATTER;    state->light.decay = DEFAULT_LIGHT_DECAY;    state->light.num_samples = DEFAULT_LIGHT_SAMPLES;    state->light.use_noise = true;    state->light.noise_scale = DEFAULT_NOISE_SCALE;    // Inicializar com base no tipo de backend    bool init_success = false;    switch (config->backend_type)    {    case VOL_BACKEND_SDL3_GL:    case VOL_BACKEND_SDL2_GL:        init_success = init_opengl_renderer(state, config);        break;    case VOL_BACKEND_SDL3_VULKAN:        init_success = vol_effects_init_vulkan(config->width, config->height);        break;    case VOL_BACKEND_CUSTOM:        init_success = vol_effects_init_custom(state);        break;    default:        fprintf(stderr, "Tipo de backend não suportado: %d\n", config->backend_type);        return false;    }    if (!init_success)    {        fprintf(stderr, "Falha ao inicializar renderer\n");        vol_effects_shutdown(state);        return false;    }    // Ajustar configurações de qualidade    adjust_quality_settings(state, state->quality_level);    state->initialized = true;    return true;}// Finaliza o sistema de efeitos volumétricosvoid vol_effects_shutdown(vol_effects_state_t *state){    if (!state || !state->initialized)    {        return;    }    // Liberar recursos do renderer    if (state->renderer_data)    {        switch (state->backend_type)        {        case VOL_BACKEND_SDL2_GL:        case VOL_BACKEND_SDL3_GL:            vol_effects_shutdown_opengl(state);            break;        case VOL_BACKEND_SDL3_VULKAN:            vol_effects_shutdown_vulkan();            break;        case VOL_BACKEND_CUSTOM:            vol_effects_shutdown_custom(state);            break;        }        state->renderer_data = NULL;    }    state->initialized = false;}// Inicia um novo frame para renderizaçãobool vol_effects_begin_frame(vol_effects_state_t *state){    if (!state || !state->initialized || !state->effects_enabled)    {        return false;    }    // Atualizar contadores de tempo    state->time += 1.0f / 60.0f; // Assumindo 60 FPS    state->frame_count++;    if (state->renderer_data)    {        switch (state->backend_type)        {        case VOL_BACKEND_SDL2_GL:        case VOL_BACKEND_SDL3_GL:            vol_effects_render_opengl(state, 1.0f / 60.0f);            break;        case VOL_BACKEND_SDL3_VULKAN:            vol_effects_render_vulkan(state, 1.0f / 60.0f);            break;        case VOL_BACKEND_CUSTOM:            vol_effects_render_custom(state, 1.0f / 60.0f);            break;        }    }    return true;}// Finaliza a renderização do frame atualbool vol_effects_end_frame(vol_effects_state_t *state){    if (!state || !state->initialized || !state->effects_enabled)    {        return false;    }    // Nada a fazer aqui por enquanto    return true;}// Renderiza os efeitos para a cena atualbool vol_effects_render(vol_effects_state_t *state, void *scene_texture, void *output_texture){    if (!state || !state->initialized || !state->effects_enabled)    {        return false;    }    // TODO: Implementar a renderização dos efeitos com OpenGL/Vulkan    // Esta é a função principal que aplicará os shaders na textura da cena    return true;}// Define a máscara de luz para obstruçõesbool vol_effects_set_light_mask(vol_effects_state_t *state, void *mask_texture){    if (!state || !state->initialized)    {        return false;    }    // TODO: Configurar textura de máscara para o renderer    return true;}// Adiciona um objeto que obstrui a luzbool vol_effects_add_light_occluder(vol_effects_state_t *state, vol_vector2_t position,                                    float width, float height, float opacity){    if (!state || !state->initialized)    {        return false;    }    // TODO: Adicionar objeto à máscara de luz    return true;}// Configura os parâmetros da luz volumétricavoid vol_effects_set_light(vol_effects_state_t *state, const vol_light_config_t *config){    if (!state || !state->initialized || !config)    {        return;    }    // Copiar configuração    memcpy(&state->light, config, sizeof(vol_light_config_t));    // Atualizar uniforms se o renderer estiver ativo    if (state->renderer_data)    {        switch (state->backend_type)        {        case VOL_BACKEND_SDL2_GL:        case VOL_BACKEND_SDL3_GL:            vol_effects_render_opengl(state, 0.0f);            break;        case VOL_BACKEND_SDL3_VULKAN:            vol_effects_render_vulkan(state, 0.0f);            break;        case VOL_BACKEND_CUSTOM:            vol_effects_render_custom(state, 0.0f);            break;        }    }}// Configura a reflexão da águavoid vol_effects_set_water(vol_effects_state_t *state, const vol_water_reflection_t *config){    if (!state || !state->initialized || !config)    {        return;    }    // Copiar configuração    memcpy(&state->water, config, sizeof(vol_water_reflection_t));}// Configura os efeitos climáticosvoid vol_effects_set_weather(vol_effects_state_t *state, const vol_weather_config_t *config){    if (!state || !state->initialized || !config)    {        return;    }    // Copiar configuração    memcpy(&state->weather, config, sizeof(vol_weather_config_t));}// Configura o efeito de profundidade de campovoid vol_effects_set_dof(vol_effects_state_t *state, const vol_dof_config_t *config){    if (!state || !state->initialized || !config)    {        return;    }    // Copiar configuração    memcpy(&state->dof, config, sizeof(vol_dof_config_t));}// Configura o sistema de partículasvoid vol_effects_set_particles(vol_effects_state_t *state, const vol_particle_config_t *config){    if (!state || !state->initialized || !config)    {        return;    }    // Copiar configuração    memcpy(&state->particles, config, sizeof(vol_particle_config_t));}// Carrega preset para uma plataforma específicabool vol_effects_load_preset(vol_effects_state_t *state, const char *preset_name){    if (!state || !state->initialized || !preset_name)    {        return false;    }    const vol_platform_preset_t *preset = NULL;    // Selecionar preset com base no nome    if (strcmp(preset_name, "nes") == 0)    {        preset = &g_preset_nes;    }    else if (strcmp(preset_name, "snes") == 0)    {        preset = &g_preset_snes;    }    else if (strcmp(preset_name, "megadrive") == 0 || strcmp(preset_name, "genesis") == 0)    {        preset = &g_preset_megadrive;    }    else    {        fprintf(stderr, "Preset desconhecido: %s\n", preset_name);        return false;    }    // Aplicar preset    vol_effects_set_light(state, &preset->light);    vol_effects_set_water(state, &preset->water);    vol_effects_set_weather(state, &preset->weather);    vol_effects_set_dof(state, &preset->dof);    vol_effects_set_particles(state, &preset->particles);    return true;}// Obtém o preset para NESconst vol_platform_preset_t *vol_effects_get_preset_nes(void){    return &g_preset_nes;}// Obtém o preset para SNESconst vol_platform_preset_t *vol_effects_get_preset_snes(void){    return &g_preset_snes;}// Obtém o preset para Mega Driveconst vol_platform_preset_t *vol_effects_get_preset_megadrive(void){    return &g_preset_megadrive;}// Define o nível de qualidade dos efeitosvoid vol_effects_set_quality(vol_effects_state_t *state, int quality_level){    if (!state || !state->initialized)    {        return;    }    // Limitar valores entre 1 e 5    if (quality_level < 1)        quality_level = 1;    if (quality_level > 5)        quality_level = 5;    state->quality_level = quality_level;    adjust_quality_settings(state, quality_level);}// Ativa ou desativa os efeitosvoid vol_effects_enable(vol_effects_state_t *state, bool enable){    if (!state)    {        return;    }    state->effects_enabled = enable;}// Verifica se o backend é suportadobool vol_effects_is_supported(vol_backend_type_t backend_type){    switch (backend_type)    {    case VOL_BACKEND_SDL2_GL:        // SDL2 com OpenGL é sempre suportado        return true;    case VOL_BACKEND_SDL3_GL:// Verificar se SDL3 está disponível (em tempo de compilação)#ifdef SDL3_SUPPORTED        return true;#else        return false;#endif    case VOL_BACKEND_SDL3_VULKAN:// Verificar se Vulkan está disponível (em tempo de compilação)#ifdef VULKAN_SUPPORTED        return true;#else        return false;#endif    case VOL_BACKEND_CUSTOM:        // Backend personalizado requer implementação externa        return true;    default:        return false;    }}// Obtém versão do sistema de efeitosconst char *vol_effects_get_version(void){    return VOL_EFFECTS_VERSION;}// Obtém estatísticas de renderizaçãobool vol_effects_get_stats(vol_effects_state_t *state, int *out_draw_calls,                           float *out_render_time_ms){    if (!state || !state->initialized)    {        return false;    }    // Estatísticas ainda não implementadas    if (out_draw_calls)        *out_draw_calls = 0;    if (out_render_time_ms)        *out_render_time_ms = 0.0f;    return true;}//--------------------------------------------------------------------------// Funções internas de implementação//--------------------------------------------------------------------------// Inicializa o renderer OpenGLstatic bool init_opengl_renderer(vol_effects_state_t *state, const vol_init_config_t *config){    // Alocar estrutura do renderer    vol_gl_renderer_t *renderer = (vol_gl_renderer_t *)malloc(sizeof(vol_gl_renderer_t));    if (!renderer)    {        return false;    }    memset(renderer, 0, sizeof(vol_gl_renderer_t));    renderer->width = config->width;    renderer->height = config->height;    // TODO: Inicializar OpenGL, criar shaders, framebuffers, etc.    // Isso requer integração com a API gráfica existente    const char *shader_path = config->shader_path ? config->shader_path : DEFAULT_SHADER_PATH;    // Carregar shaders    if (!load_shaders(renderer, shader_path))    {        free(renderer);        return false;    }    // Criar framebuffers    if (!create_framebuffers(renderer, config->width, config->height))    {        free(renderer);        return false;    }    // Criar textura de ruído    if (!create_noise_texture(renderer))    {        free(renderer);        return false;    }    state->renderer_data = renderer;    return true;}// Finaliza o renderer OpenGLstatic void shutdown_opengl_renderer(vol_effects_state_t *state){    if (!state || !state->renderer_data)    {        return;    }    vol_gl_renderer_t *renderer = (vol_gl_renderer_t *)state->renderer_data;    // TODO: Liberar recursos OpenGL    free(renderer);    state->renderer_data = NULL;}// Cria framebuffers para render offscreenstatic bool create_framebuffers(vol_gl_renderer_t *renderer, int width, int height){    // TODO: Implementar criação de framebuffers OpenGL    return true;}// Carrega shaders do discostatic bool load_shaders(vol_gl_renderer_t *renderer, const char *shader_path){    // TODO: Implementar carregamento de shaders    return true;}// Cria textura de ruído para simulação de variaçõesstatic bool create_noise_texture(vol_gl_renderer_t *renderer){    // TODO: Implementar criação de textura de ruído    return true;}// Ajusta configurações com base no nível de qualidadestatic void adjust_quality_settings(vol_effects_state_t *state, int quality_level){    switch (quality_level)    {    case 1: // Baixa qualidade        state->light.num_samples = 16;        break;    case 2: // Média-baixa qualidade        state->light.num_samples = 24;        break;    case 3: // Média qualidade (padrão)        state->light.num_samples = 32;        break;    case 4: // Média-alta qualidade        state->light.num_samples = 48;        break;    case 5: // Alta qualidade        state->light.num_samples = 64;        break;    default:        state->light.num_samples = 32;        break;    }}// Atualiza uniforms do shader com a configuração atualstatic void update_uniforms(vol_gl_renderer_t *renderer, vol_effects_state_t *state){    // TODO: Implementar atualização de uniforms OpenGL}static VkShaderModule create_shader_module(const uint32_t *code, size_t size){    VkShaderModuleCreateInfo create_info = {        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,        .codeSize = size,        .pCode = code};    VkShaderModule shader_module;    if (vkCreateShaderModule(vk_state.device, &create_info, NULL, &shader_module) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar módulo de shader Vulkan");        return VK_NULL_HANDLE;    }    return shader_module;}static void create_pipeline(){    // Criar módulos de shader    VkShaderModule vert_module = create_shader_module(volumetric_vert_spv, volumetric_vert_spv_size);    VkShaderModule frag_module = create_shader_module(volumetric_frag_spv, volumetric_frag_spv_size);    // Configurar estágios de shader    VkPipelineShaderStageCreateInfo shader_stages[2] = {        {.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,         .stage = VK_SHADER_STAGE_VERTEX_BIT,         .module = vert_module,         .pName = "main"},        {.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,         .stage = VK_SHADER_STAGE_FRAGMENT_BIT,         .module = frag_module,         .pName = "main"}};    // Configurar layout do vértice    VkVertexInputBindingDescription binding_desc = {        .binding = 0,        .stride = sizeof(float) * 5, // posição (3) + texcoord (2)        .inputRate = VK_VERTEX_INPUT_RATE_VERTEX};    VkVertexInputAttributeDescription attr_desc[2] = {        {.binding = 0,         .location = 0,         .format = VK_FORMAT_R32G32B32_SFLOAT,         .offset = 0},        {.binding = 0,         .location = 1,         .format = VK_FORMAT_R32G32_SFLOAT,         .offset = sizeof(float) * 3}};    VkPipelineVertexInputStateCreateInfo vertex_input = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,        .vertexBindingDescriptionCount = 1,        .pVertexBindingDescriptions = &binding_desc,        .vertexAttributeDescriptionCount = 2,        .pVertexAttributeDescriptions = attr_desc};    // Configurar layout do pipeline    VkPipelineLayoutCreateInfo pipeline_layout_info = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,        .setLayoutCount = 1,        .pSetLayouts = &vk_state.descriptor_layout};    if (vkCreatePipelineLayout(vk_state.device, &pipeline_layout_info, NULL, &vk_state.pipeline_layout) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar layout do pipeline Vulkan");        return;    }    // Configurar estados do pipeline    VkPipelineInputAssemblyStateCreateInfo input_assembly = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,        .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,        .primitiveRestartEnable = VK_FALSE};    VkPipelineRasterizationStateCreateInfo rasterizer = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,        .depthClampEnable = VK_FALSE,        .rasterizerDiscardEnable = VK_FALSE,        .polygonMode = VK_POLYGON_MODE_FILL,        .lineWidth = 1.0f,        .cullMode = VK_CULL_MODE_BACK_BIT,        .frontFace = VK_FRONT_FACE_CLOCKWISE,        .depthBiasEnable = VK_FALSE};    VkPipelineMultisampleStateCreateInfo multisampling = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,        .sampleShadingEnable = VK_FALSE,        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT};    VkPipelineColorBlendAttachmentState color_blend_attachment = {        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |                          VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT,        .blendEnable = VK_TRUE,        .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA,        .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,        .colorBlendOp = VK_BLEND_OP_ADD,        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,        .alphaBlendOp = VK_BLEND_OP_ADD};    VkPipelineColorBlendStateCreateInfo color_blending = {        .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,        .logicOpEnable = VK_FALSE,        .attachmentCount = 1,        .pAttachments = &color_blend_attachment};    // Criar pipeline gráfico    VkGraphicsPipelineCreateInfo pipeline_info = {        .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,        .stageCount = 2,        .pStages = shader_stages,        .pVertexInputState = &vertex_input,        .pInputAssemblyState = &input_assembly,        .pViewportState = NULL, // Dinâmico        .pRasterizationState = &rasterizer,        .pMultisampleState = &multisampling,        .pDepthStencilState = NULL,        .pColorBlendState = &color_blending,        .layout = vk_state.pipeline_layout,        .renderPass = vk_state.render_pass,        .subpass = 0};    if (vkCreateGraphicsPipelines(vk_state.device, VK_NULL_HANDLE, 1, &pipeline_info, NULL, &vk_state.pipeline) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar pipeline gráfico Vulkan");        return;    }    // Limpar módulos de shader    vkDestroyShaderModule(vk_state.device, vert_module, NULL);    vkDestroyShaderModule(vk_state.device, frag_module, NULL);}static void create_framebuffers(int width, int height){    // Criar imagem de cor    VkImageCreateInfo image_info = {        .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,        .imageType = VK_IMAGE_TYPE_2D,        .extent.width = width,        .extent.height = height,        .extent.depth = 1,        .mipLevels = 1,        .arrayLayers = 1,        .format = VK_FORMAT_R8G8B8A8_UNORM,        .tiling = VK_IMAGE_TILING_OPTIMAL,        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,        .usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,        .samples = VK_SAMPLE_COUNT_1_BIT,        .sharingMode = VK_SHARING_MODE_EXCLUSIVE};    if (vkCreateImage(vk_state.device, &image_info, NULL, &vk_state.texture) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar imagem Vulkan");        return;    }    // Alocar memória para a imagem    VkMemoryRequirements mem_requirements;    vkGetImageMemoryRequirements(vk_state.device, vk_state.texture, &mem_requirements);    VkMemoryAllocateInfo alloc_info = {        .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,        .allocationSize = mem_requirements.size,        .memoryTypeIndex = 0 // Encontrar índice apropriado    };    if (vkAllocateMemory(vk_state.device, &alloc_info, NULL, &vk_state.texture_memory) != VK_SUCCESS)    {        LOG_ERROR("Falha ao alocar memória para imagem Vulkan");        return;    }    vkBindImageMemory(vk_state.device, vk_state.texture, vk_state.texture_memory, 0);    // Criar view da imagem    VkImageViewCreateInfo view_info = {        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,        .image = vk_state.texture,        .viewType = VK_IMAGE_VIEW_TYPE_2D,        .format = VK_FORMAT_R8G8B8A8_UNORM,        .subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,        .subresourceRange.baseMipLevel = 0,        .subresourceRange.levelCount = 1,        .subresourceRange.baseArrayLayer = 0,        .subresourceRange.layerCount = 1};    if (vkCreateImageView(vk_state.device, &view_info, NULL, &vk_state.texture_view) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar view de imagem Vulkan");        return;    }    // Criar framebuffer    VkFramebufferCreateInfo framebuffer_info = {        .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,        .renderPass = vk_state.render_pass,        .attachmentCount = 1,        .pAttachments = &vk_state.texture_view,        .width = width,        .height = height,        .layers = 1};    if (vkCreateFramebuffer(vk_state.device, &framebuffer_info, NULL, &vk_state.framebuffer) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar framebuffer Vulkan");        return;    }}int vol_effects_init_vulkan(int width, int height){    // Criar instância Vulkan    VkApplicationInfo app_info = {        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,        .pApplicationName = "MegaEmu",        .applicationVersion = VK_MAKE_VERSION(1, 0, 0),        .pEngineName = "No Engine",        .engineVersion = VK_MAKE_VERSION(1, 0, 0),        .apiVersion = VK_API_VERSION_1_0};    VkInstanceCreateInfo create_info = {        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,        .pApplicationInfo = &app_info};    if (vkCreateInstance(&create_info, NULL, &vk_state.instance) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar instância Vulkan");        return -1;    }    // Selecionar dispositivo físico    uint32_t device_count = 0;    vkEnumeratePhysicalDevices(vk_state.instance, &device_count, NULL);    if (device_count == 0)    {        LOG_ERROR("Nenhum dispositivo Vulkan encontrado");        return -1;    }    VkPhysicalDevice devices[device_count];    vkEnumeratePhysicalDevices(vk_state.instance, &device_count, devices);    vk_state.physical_device = devices[0]; // Usar primeiro dispositivo    // Criar dispositivo lógico    float queue_priority = 1.0f;    VkDeviceQueueCreateInfo queue_create_info = {        .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,        .queueFamilyIndex = 0, // Assumindo que a primeira família suporta gráficos        .queueCount = 1,        .pQueuePriorities = &queue_priority};    VkDeviceCreateInfo device_create_info = {        .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,        .queueCreateInfoCount = 1,        .pQueueCreateInfos = &queue_create_info};    if (vkCreateDevice(vk_state.physical_device, &device_create_info, NULL, &vk_state.device) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar dispositivo Vulkan");        return -1;    }    vkGetDeviceQueue(vk_state.device, 0, 0, &vk_state.graphics_queue);    // Criar pool de comandos    VkCommandPoolCreateInfo pool_info = {        .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,        .queueFamilyIndex = 0};    if (vkCreateCommandPool(vk_state.device, &pool_info, NULL, &vk_state.command_pool) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar pool de comandos Vulkan");        return -1;    }    // Criar buffer de comandos    VkCommandBufferAllocateInfo alloc_info = {        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,        .commandPool = vk_state.command_pool,        .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,        .commandBufferCount = 1};    if (vkAllocateCommandBuffers(vk_state.device, &alloc_info, &vk_state.command_buffer) != VK_SUCCESS)    {        LOG_ERROR("Falha ao alocar buffer de comandos Vulkan");        return -1;    }    // Criar render pass    VkAttachmentDescription color_attachment = {        .format = VK_FORMAT_R8G8B8A8_UNORM,        .samples = VK_SAMPLE_COUNT_1_BIT,        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,        .storeOp = VK_ATTACHMENT_STORE_OP_STORE,        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,        .finalLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL};    VkAttachmentReference color_attachment_ref = {        .attachment = 0,        .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};    VkSubpassDescription subpass = {        .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,        .colorAttachmentCount = 1,        .pColorAttachments = &color_attachment_ref};    VkRenderPassCreateInfo render_pass_info = {        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,        .attachmentCount = 1,        .pAttachments = &color_attachment,        .subpassCount = 1,        .pSubpasses = &subpass};    if (vkCreateRenderPass(vk_state.device, &render_pass_info, NULL, &vk_state.render_pass) != VK_SUCCESS)    {        LOG_ERROR("Falha ao criar render pass Vulkan");        return -1;    }    // Criar pipeline    create_pipeline();    // Criar framebuffers    create_framebuffers(width, height);    return 0;}void vol_effects_shutdown_vulkan(){    vkDestroyFramebuffer(vk_state.device, vk_state.framebuffer, NULL);    vkDestroyImageView(vk_state.device, vk_state.texture_view, NULL);    vkDestroyImage(vk_state.device, vk_state.texture, NULL);    vkFreeMemory(vk_state.device, vk_state.texture_memory, NULL);    vkDestroyPipeline(vk_state.device, vk_state.pipeline, NULL);    vkDestroyPipelineLayout(vk_state.device, vk_state.pipeline_layout, NULL);    vkDestroyRenderPass(vk_state.device, vk_state.render_pass, NULL);    vkFreeCommandBuffers(vk_state.device, vk_state.command_pool, 1, &vk_state.command_buffer);    vkDestroyCommandPool(vk_state.device, vk_state.command_pool, NULL);    vkDestroyDevice(vk_state.device, NULL);    vkDestroyInstance(vk_state.instance, NULL);}void vol_effects_render_vulkan(VkCommandBuffer cmd_buffer){    VkCommandBufferBeginInfo begin_info = {        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};    vkBeginCommandBuffer(cmd_buffer, &begin_info);    VkRenderPassBeginInfo render_pass_info = {        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,        .renderPass = vk_state.render_pass,        .framebuffer = vk_state.framebuffer,        .renderArea.offset = {0, 0},        .renderArea.extent = {800, 600}, // Ajustar para dimensões reais        .clearValueCount = 1,        .pClearValues = &(VkClearValue){{0.0f, 0.0f, 0.0f, 1.0f}}};    vkCmdBeginRenderPass(cmd_buffer, &render_pass_info, VK_SUBPASS_CONTENTS_INLINE);    vkCmdBindPipeline(cmd_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, vk_state.pipeline);    vkCmdDraw(cmd_buffer, 6, 1, 0, 0); // Renderizar quad    vkCmdEndRenderPass(cmd_buffer);    vkEndCommandBuffer(cmd_buffer);    VkSubmitInfo submit_info = {        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,        .commandBufferCount = 1,        .pCommandBuffers = &cmd_buffer};    vkQueueSubmit(vk_state.graphics_queue, 1, &submit_info, VK_NULL_HANDLE);    vkQueueWaitIdle(vk_state.graphics_queue);}