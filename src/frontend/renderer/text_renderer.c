/** * @file text_renderer.c * @brief Implementação do sistema de renderização de texto */#include "text_renderer.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <SDL2/SDL.h>// Verifica se o SDL2_ttf está disponível#ifdef USE_SDL2_TTF#include <SDL2/SDL_ttf.h>#endif// Caracteres suportados pela fonte bitmapstatic const char *BITMAP_FONT_CHARS = " 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,!?-+*/=()[]{}";// Estrutura de fontetypedef struct{    text_size_t size;    text_style_flags_t style_flags;#ifdef USE_SDL2_TTF    TTF_Font *font;#endif} font_entry_t;// Estrutura global para o sistema de textostatic struct{    SDL_Renderer *renderer;    texture_cache_t *texture_cache;    char resources_path[512];    bool initialized;    // Fonte bitmap para fallback    SDL_Surface *bitmap_font;    SDL_Texture *font_texture;    int glyph_width;    int glyph_height;#ifdef USE_SDL2_TTF    font_entry_t fonts[16]; // Suporta até 16 combinações de tamanho/estilo    int font_count;    bool ttf_available;#endif} g_text_renderer = {0};// Fontes fallback para sistemas sem SDL2_ttfstatic const uint8_t g_simple_font_data[128][8] = {    // Implementação simplificada de fonte 8x8 para fallback    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Espaço    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, // !    {0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // "    {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00}, // #    // Restante dos caracteres ASCII seria definido aqui    // Implementando apenas alguns básicos para exemplo    {0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00}, // >    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}  // Espaço (repetido para preencher)};#ifndef USE_SDL2_TTF// Função auxiliar para encontrar o índice de um caractere na tabela bitmapstatic int find_char_index(char c){    const char *pos = strchr(BITMAP_FONT_CHARS, c);    if (pos)    {        return (int)(pos - BITMAP_FONT_CHARS);    }    return 0; // Caractere desconhecido = espaço}// Cria uma fonte bitmap básicastatic bool create_bitmap_font(void){    // Cria uma superfície para a fonte bitmap 16x6 caracteres, cada um 8x12 pixels    g_text_renderer.glyph_width = 8;    g_text_renderer.glyph_height = 12;    int surface_width = 16 * g_text_renderer.glyph_width;    int surface_height = 6 * g_text_renderer.glyph_height;    g_text_renderer.bitmap_font = SDL_CreateRGBSurface(0, surface_width, surface_height, 32,                                                       0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF);    if (!g_text_renderer.bitmap_font)    {        printf("Falha ao criar superfície para fonte bitmap: %s\n", SDL_GetError());        return false;    }    // Define cor de fundo transparente    SDL_SetColorKey(g_text_renderer.bitmap_font, SDL_TRUE, SDL_MapRGBA(g_text_renderer.bitmap_font->format, 0, 0, 0, 0));    // Desenha cada caractere (fonte muito básica)    // Aqui usamos apenas pixels brancos para cada glifo    SDL_LockSurface(g_text_renderer.bitmap_font);    Uint32 white = SDL_MapRGBA(g_text_renderer.bitmap_font->format, 255, 255, 255, 255);    Uint32 *pixels = (Uint32 *)g_text_renderer.bitmap_font->pixels;    // Caracteres básicos - implementação simplificada    // Normalmente, aqui incluiríamos um bitmap real desenhando cada caractere    for (int i = 0; i < strlen(BITMAP_FONT_CHARS); i++)    {        int x = (i % 16) * g_text_renderer.glyph_width;        int y = (i / 16) * g_text_renderer.glyph_height;        // Desenha o caractere (aqui apenas um quadrado para exemplo)        for (int cy = 2; cy < g_text_renderer.glyph_height - 2; cy++)        {            for (int cx = 1; cx < g_text_renderer.glyph_width - 1; cx++)            {                // Pula o caractere espaço                if (i == 0)                    continue;                // Desenha o pixel apenas na borda para caracteres normais                if (cx == 1 || cx == g_text_renderer.glyph_width - 2 ||                    cy == 2 || cy == g_text_renderer.glyph_height - 3)                {                    pixels[(y + cy) * surface_width + (x + cx)] = white;                }                // Para números, preenche o interior                if (i >= 16 && i <= 25 &&                    cx > 1 && cx < g_text_renderer.glyph_width - 2 &&                    cy > 2 && cy < g_text_renderer.glyph_height - 3)                {                    pixels[(y + cy) * surface_width + (x + cx)] = white;                }            }        }    }    SDL_UnlockSurface(g_text_renderer.bitmap_font);    // Cria textura a partir da superfície    g_text_renderer.font_texture = SDL_CreateTextureFromSurface(g_text_renderer.renderer, g_text_renderer.bitmap_font);    if (!g_text_renderer.font_texture)    {        printf("Falha ao criar textura para fonte bitmap: %s\n", SDL_GetError());        SDL_FreeSurface(g_text_renderer.bitmap_font);        g_text_renderer.bitmap_font = NULL;        return false;    }    return true;}#endif/** * @brief Inicializa o sistema de renderização de texto */bool text_renderer_init(SDL_Renderer *renderer, texture_cache_t *cache){    if (g_text_renderer.initialized)    {        return true; // Já inicializado    }    // Inicializa a estrutura    memset(&g_text_renderer, 0, sizeof(g_text_renderer));    g_text_renderer.renderer = renderer;    g_text_renderer.texture_cache = cache;    // Inicializa a fonte bitmap para fallback    if (!create_bitmap_font())    {        return false;    }    // Inicializa SDL_ttf se disponível#ifdef USE_SDL2_TTF    g_text_renderer.ttf_available = (TTF_Init() == 0);    g_text_renderer.font_count = 0;    if (g_text_renderer.ttf_available)    {        // Carrega as fontes do diretório resources        const char *fontPaths[] = {            "resources/fonts/arial.ttf",    // Regular            "resources/fonts/G_ari_bd.TTF", // Bold            "resources/fonts/G_ari_i.TTF",  // Italic            "resources/fonts/ARIBL0.ttf"    // Bold Italic        };        const int fontSizes[] = {12, 16, 24};        // Tenta carregar cada fonte        for (int i = 0; i < 4 && g_text_renderer.font_count < 16; i++)        {            for (int j = 0; j < 3 && g_text_renderer.font_count < 16; j++)            {                TTF_Font *font = TTF_OpenFont(fontPaths[i], fontSizes[j]);                if (!font)                {                    printf("Aviso: Não foi possível carregar a fonte %s (tamanho %d)\n",                           fontPaths[i], fontSizes[j]);                    continue;                }                int styleIndex = g_text_renderer.font_count++;                g_text_renderer.fonts[styleIndex].size = j;                g_text_renderer.fonts[styleIndex].style_flags = (1 << i);                g_text_renderer.fonts[styleIndex].font = font;            }        }        // Se nenhuma fonte foi carregada, desativa o TTF        if (g_text_renderer.font_count == 0)        {            printf("Aviso: Nenhuma fonte TTF foi carregada. Usando fallback.\n");            g_text_renderer.ttf_available = false;            TTF_Quit();        }    }#endif    g_text_renderer.initialized = true;    return true;}/** * @brief Finaliza o sistema de renderização de texto */void text_renderer_shutdown(void){    if (!g_text_renderer.initialized)    {        return;    }    // Libera recursos    if (g_text_renderer.font_texture)    {        SDL_DestroyTexture(g_text_renderer.font_texture);        g_text_renderer.font_texture = NULL;    }    if (g_text_renderer.bitmap_font)    {        SDL_FreeSurface(g_text_renderer.bitmap_font);        g_text_renderer.bitmap_font = NULL;    }#ifdef USE_SDL2_TTF    // Libera as fontes TTF    for (int i = 0; i < g_text_renderer.font_count; i++)    {        if (g_text_renderer.fonts[i].font)        {            TTF_CloseFont(g_text_renderer.fonts[i].font);            g_text_renderer.fonts[i].font = NULL;        }    }    g_text_renderer.font_count = 0;    if (g_text_renderer.ttf_available)    {        TTF_Quit();        g_text_renderer.ttf_available = false;    }#endif    g_text_renderer.initialized = false;}/** * @brief Verifica se o sistema TTF está disponível */bool text_renderer_has_ttf(void){#ifdef USE_SDL2_TTF    return g_text_renderer.ttf_available;#else    return false;#endif}#ifdef USE_SDL2_TTF/** * @brief Encontra a fonte apropriada para o estilo */static TTF_Font *find_font(text_style_t style){    // Procura uma fonte que corresponda ao tamanho e estilo    for (int i = 0; i < g_text_renderer.font_count; i++)    {        if (g_text_renderer.fonts[i].size == style.size &&            g_text_renderer.fonts[i].style_flags == style.flags)        {            return g_text_renderer.fonts[i].font;        }    }    // Tenta encontrar uma fonte com o tamanho certo    for (int i = 0; i < g_text_renderer.font_count; i++)    {        if (g_text_renderer.fonts[i].size == style.size)        {            // Configura os atributos da fonte            int ttf_style = TTF_STYLE_NORMAL;            if (style.flags & TEXT_STYLE_BOLD)            {                ttf_style |= TTF_STYLE_BOLD;            }            if (style.flags & TEXT_STYLE_ITALIC)            {                ttf_style |= TTF_STYLE_ITALIC;            }            if (style.flags & TEXT_STYLE_UNDERLINE)            {                ttf_style |= TTF_STYLE_UNDERLINE;            }            TTF_SetFontStyle(g_text_renderer.fonts[i].font, ttf_style);            return g_text_renderer.fonts[i].font;        }    }    // Se não encontrar, retorna a primeira    if (g_text_renderer.font_count > 0)    {        return g_text_renderer.fonts[0].font;    }    return NULL;}#endif/** * @brief Renderiza um caractere usando a fonte bitmap */static void render_simple_char(char c, int x, int y, SDL_Color color){    if (!g_text_renderer.initialized || !g_text_renderer.font_texture)    {        return;    }    int index = find_char_index(c);    int src_x = (index % 32) * g_text_renderer.glyph_width;    int src_y = (index / 32) * g_text_renderer.glyph_height;    SDL_Rect src = {        src_x, src_y,        g_text_renderer.glyph_width, g_text_renderer.glyph_height};    SDL_Rect dst = {        x, y,        g_text_renderer.glyph_width, g_text_renderer.glyph_height};    // Configura a cor    SDL_SetTextureColorMod(g_text_renderer.font_texture, color.r, color.g, color.b);    SDL_SetTextureAlphaMod(g_text_renderer.font_texture, color.a);    // Renderiza    SDL_RenderCopy(g_text_renderer.renderer, g_text_renderer.font_texture, &src, &dst);}/** * @brief Renderiza texto usando a fonte bitmap */static void render_simple_text(const char *text, int x, int y, SDL_Color color){    int currentX = x;    int currentY = y;    for (const char *p = text; *p; p++)    {        if (*p == '\n')        {            currentX = x;            currentY += g_text_renderer.glyph_height;            continue;        }        render_simple_char(*p, currentX, currentY, color);        currentX += g_text_renderer.glyph_width;    }}/** * @brief Renderiza texto na tela */bool text_renderer_render(const char *text, int x, int y, text_style_t style){    if (!g_text_renderer.initialized || !text)    {        return false;    }    // Ajusta a posição de acordo com o alinhamento    int text_width = 0;    text_renderer_measure(text, style, &text_width, NULL);    if (style.alignment == TEXT_ALIGN_CENTER)    {        x -= text_width / 2;    }    else if (style.alignment == TEXT_ALIGN_RIGHT)    {        x -= text_width;    }#ifdef USE_SDL2_TTF    if (g_text_renderer.ttf_available)    {        TTF_Font *font = find_font(style);        if (font)        {            SDL_Surface *textSurface = TTF_RenderText_Blended(font, text, style.color);            if (textSurface)            {                SDL_Texture *textTexture = SDL_CreateTextureFromSurface(g_text_renderer.renderer, textSurface);                if (textTexture)                {                    SDL_Rect dst = {x, y, textSurface->w, textSurface->h};                    SDL_RenderCopy(g_text_renderer.renderer, textTexture, NULL, &dst);                    SDL_DestroyTexture(textTexture);                }                SDL_FreeSurface(textSurface);                return true;            }        }    }#endif    // Fallback para a fonte bitmap    render_simple_text(text, x, y, style.color);    return true;}/** * @brief Renderiza texto com quebra de linha automática */bool text_renderer_draw_wrapped(const char *text, int x, int y,                                int max_width, text_style_t style){    if (!g_text_renderer.initialized || !text)    {        return false;    }    // Copia o texto para poder modificá-lo    size_t text_len = strlen(text);    char *temp_text = (char *)malloc(text_len + 1);    if (!temp_text)    {        return false;    }    strcpy(temp_text, text);    // Quebra o texto em linhas    int current_y = y;    char *line_start = temp_text;    char *line_end = temp_text;    char *word_break = NULL;    int line_width = 0;    int word_width = 0;    while (*line_end)    {        if (*line_end == ' ' || *line_end == '\n' || *line_end == '\t')        {            word_break = line_end;            // Calcula a largura da palavra            char temp_char = *word_break;            *word_break = '\0';            text_renderer_measure(line_start, style, &word_width, NULL);            *word_break = temp_char;            line_width += word_width;            // Verifica se excede a largura máxima            if (line_width > max_width)            {                // Volta para o último espaço                if (word_break > line_start)                {                    *word_break = '\0';                    text_renderer_render(line_start, x, current_y, style);                    *word_break = ' ';                    line_start = word_break + 1;                    current_y += g_text_renderer.glyph_height;                    line_width = 0;                }            }            // Se for quebra de linha, avança            if (*line_end == '\n')            {                *line_end = '\0';                text_renderer_render(line_start, x, current_y, style);                line_start = line_end + 1;                current_y += g_text_renderer.glyph_height;                line_width = 0;            }        }        line_end++;    }    // Renderiza o texto restante    if (*line_start)    {        text_renderer_render(line_start, x, current_y, style);    }    free(temp_text);    return true;}/** * @brief Mede o tamanho que um texto ocuparia se renderizado */bool text_renderer_measure(const char *text, text_style_t style, int *width, int *height){    if (!g_text_renderer.initialized || !text)    {        return false;    }#ifdef USE_SDL2_TTF    if (g_text_renderer.ttf_available)    {        TTF_Font *font = find_font(style);        if (font)        {            int w, h;            if (TTF_SizeText(font, text, &w, &h) == 0)            {                if (width)                    *width = w;                if (height)                    *height = h;                return true;            }        }    }#endif    // Fallback para medição simples usando a fonte bitmap    int len = strlen(text);    if (width)        *width = len * g_text_renderer.glyph_width;    if (height)        *height = g_text_renderer.glyph_height;    return true;}/** * @brief Alias para text_renderer_measure */void text_renderer_get_size(const char *text, text_style_t style, int *width, int *height){    text_renderer_measure(text, style, width, height);}