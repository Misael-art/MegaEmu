#include "sdl_game_renderer.h"#include <stdio.h>// Função auxiliar para criar texturasstatic SDL_Texture *create_game_texture(SDL_Renderer *renderer, int width, int height){    SDL_Texture *texture = SDL_CreateTexture(        renderer,        SDL_PIXELFORMAT_ARGB8888,  // Formato de pixel ARGB para compatibilidade com a paleta NES        SDL_TEXTUREACCESS_STREAMING,        width, height);    if (!texture) {        fprintf(stderr, "Erro ao criar textura: %s\n", SDL_GetError());    } else {        printf("Textura criada com sucesso: %dx%d formato=SDL_PIXELFORMAT_ARGB8888\n", width, height);    }    return texture;}bool sdl_game_renderer_init(sdl_game_renderer_t *renderer, const sdl_renderer_config_t *config){    if (!renderer || !config)        return false;    // Copiar configuração    renderer->config = *config;    renderer->initialized = false;    // Inicializar SDL se necessário    if (SDL_WasInit(SDL_INIT_VIDEO) == 0)    {        if (SDL_Init(SDL_INIT_VIDEO) < 0)        {            fprintf(stderr, "Erro ao inicializar SDL: %s\n", SDL_GetError());            return false;        }    }    // Criar janela    Uint32 window_flags = SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE;    if (config->fullscreen)    {        window_flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;    }    renderer->window = SDL_CreateWindow(        "Mega_Emu",        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,        config->window_width, config->window_height,        window_flags);    if (!renderer->window)    {        fprintf(stderr, "Erro ao criar janela SDL: %s\n", SDL_GetError());        return false;    }    // Criar renderer    Uint32 renderer_flags = SDL_RENDERER_ACCELERATED;    if (config->vsync_enabled)    {        renderer_flags |= SDL_RENDERER_PRESENTVSYNC;    }    renderer->renderer = SDL_CreateRenderer(renderer->window, -1, renderer_flags);    if (!renderer->renderer)    {        fprintf(stderr, "Erro ao criar renderer SDL: %s\n", SDL_GetError());        SDL_DestroyWindow(renderer->window);        renderer->window = NULL;        return false;    }    // Configurar qualidade de escala    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY,                config->smooth_scaling ? "linear" : "nearest");    // Configurar escala inteira    SDL_RenderSetIntegerScale(renderer->renderer,                              config->integer_scaling ? SDL_TRUE : SDL_FALSE);    // Criar texturas    renderer->texture = create_game_texture(        renderer->renderer,        config->game_width,        config->game_height);    if (!renderer->texture)    {        fprintf(stderr, "Erro ao criar textura do jogo: %s\n", SDL_GetError());        SDL_DestroyRenderer(renderer->renderer);        SDL_DestroyWindow(renderer->window);        renderer->renderer = NULL;        renderer->window = NULL;        return false;    }    // Alocar frame buffer    renderer->frame_buffer = (uint32_t *)malloc(config->game_width * config->game_height * sizeof(uint32_t));    if (!renderer->frame_buffer)    {        fprintf(stderr, "Erro ao alocar frame buffer\n");        SDL_DestroyTexture(renderer->texture);        SDL_DestroyRenderer(renderer->renderer);        SDL_DestroyWindow(renderer->window);        renderer->texture = NULL;        renderer->renderer = NULL;        renderer->window = NULL;        return false;    }    // Configurar dimensões do jogo    renderer->game_width = config->game_width;    renderer->game_height = config->game_height;    renderer->overlay_texture = create_game_texture(        renderer->renderer,        config->window_width,        config->window_height);    if (!renderer->overlay_texture)    {        fprintf(stderr, "Erro ao criar textura de overlay: %s\n", SDL_GetError());        SDL_DestroyTexture(renderer->texture);        SDL_DestroyRenderer(renderer->renderer);        SDL_DestroyWindow(renderer->window);        renderer->texture = NULL;        renderer->renderer = NULL;        renderer->window = NULL;        return false;    }    renderer->initialized = true;    return true;}void sdl_game_renderer_shutdown(sdl_game_renderer_t *renderer){    if (!renderer)        return;    if (renderer->overlay_texture)    {        SDL_DestroyTexture(renderer->overlay_texture);        renderer->overlay_texture = NULL;    }    if (renderer->texture)    {        SDL_DestroyTexture(renderer->texture);        renderer->texture = NULL;    }    if (renderer->frame_buffer)    {        free(renderer->frame_buffer);        renderer->frame_buffer = NULL;    }    if (renderer->renderer)    {        SDL_DestroyRenderer(renderer->renderer);        renderer->renderer = NULL;    }    if (renderer->window)    {        SDL_DestroyWindow(renderer->window);        renderer->window = NULL;    }    renderer->initialized = false;}bool sdl_game_renderer_begin_frame(sdl_game_renderer_t *renderer){    if (!renderer || !renderer->initialized)        return false;    SDL_SetRenderDrawColor(renderer->renderer, 0, 0, 0, 255);    SDL_RenderClear(renderer->renderer);    return true;}bool sdl_game_renderer_end_frame(sdl_game_renderer_t *renderer){    if (!renderer || !renderer->initialized)        return false;    SDL_RenderPresent(renderer->renderer);    return true;}bool sdl_game_renderer_update_game_texture(sdl_game_renderer_t *renderer, const uint32_t *pixels){    if (!renderer || !renderer->initialized || !pixels)        return false;    void *texture_pixels;    int pitch;    if (SDL_LockTexture(renderer->texture, NULL, &texture_pixels, &pitch) < 0)    {        fprintf(stderr, "Erro ao bloquear textura: %s\n", SDL_GetError());        return false;    }    // Copia os pixels para a textura    const int bytes_per_pixel = 4;    const int row_size = renderer->game_width * bytes_per_pixel;    uint8_t *dst = (uint8_t *)texture_pixels;    const uint8_t *src = (const uint8_t *)pixels;    // Cópia direta, já que agora ambos estão no formato ARGB    for (int y = 0; y < renderer->game_height; y++)    {        memcpy(dst, src, row_size);        dst += pitch;        src += row_size;    }    // Debug das primeiras cores em hexadecimal    printf("Debug primeiros pixels: [0]=0x%08X [1]=0x%08X [2]=0x%08X [3]=0x%08X\n",           pixels[0], pixels[1], pixels[2], pixels[3]);    SDL_UnlockTexture(renderer->texture);    return true;}bool sdl_game_renderer_draw_frame(sdl_game_renderer_t *renderer){    if (!renderer || !renderer->initialized)        return false;    // Limpa o renderer    SDL_SetRenderDrawColor(renderer->renderer, 0, 0, 0, 255);    SDL_RenderClear(renderer->renderer);    // Calcula o retângulo de destino mantendo a proporção    SDL_Rect dst_rect;    int window_width, window_height;    SDL_GetRendererOutputSize(renderer->renderer, &window_width, &window_height);    float scale_x = (float)window_width / renderer->game_width;    float scale_y = (float)window_height / renderer->game_height;    float scale = renderer->config.integer_scaling ? floorf(fminf(scale_x, scale_y)) : fminf(scale_x, scale_y);    dst_rect.w = (int)(renderer->game_width * scale);    dst_rect.h = (int)(renderer->game_height * scale);    dst_rect.x = (window_width - dst_rect.w) / 2;    dst_rect.y = (window_height - dst_rect.h) / 2;    // Configura a qualidade de escala    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY,                renderer->config.smooth_scaling ? "linear" : "nearest");    // Renderiza a textura do jogo    SDL_RenderCopy(renderer->renderer, renderer->texture, NULL, &dst_rect);    // Renderiza overlay se existir    if (renderer->overlay_texture)    {        SDL_RenderCopy(renderer->renderer, renderer->overlay_texture, NULL, NULL);    }    return true;}bool sdl_game_renderer_present(sdl_game_renderer_t *renderer){    if (!renderer || !renderer->initialized)        return false;    SDL_RenderPresent(renderer->renderer);    return true;}bool sdl_game_renderer_draw_overlay(sdl_game_renderer_t *renderer, const uint32_t *pixels){    if (!renderer || !renderer->initialized || !pixels)        return false;    void *texture_pixels;    int pitch;    if (SDL_LockTexture(renderer->overlay_texture, NULL, &texture_pixels, &pitch) < 0)    {        fprintf(stderr, "Erro ao bloquear textura de overlay: %s\n", SDL_GetError());        return false;    }    const int bytes_per_pixel = 4;    const int row_size = renderer->config.window_width * bytes_per_pixel;    uint8_t *dst = (uint8_t *)texture_pixels;    const uint8_t *src = (const uint8_t *)pixels;    for (int y = 0; y < renderer->config.window_height; y++)    {        memcpy(dst, src, row_size);        dst += pitch;        src += row_size;    }    SDL_UnlockTexture(renderer->overlay_texture);    // Renderizar textura de overlay    SDL_RenderCopy(renderer->renderer, renderer->overlay_texture, NULL, NULL);    return true;}bool sdl_game_renderer_set_config(sdl_game_renderer_t *renderer, const sdl_renderer_config_t *config){    if (!renderer || !config)        return false;    // Salvar configuração antiga    sdl_renderer_config_t old_config = renderer->config;    renderer->config = *config;    // Recriar texturas se necessário    if (old_config.game_width != config->game_width ||        old_config.game_height != config->game_height)    {        SDL_DestroyTexture(renderer->texture);        renderer->texture = create_game_texture(            renderer->renderer,            config->game_width,            config->game_height);        if (!renderer->texture)        {            renderer->config = old_config;            return false;        }    }    if (old_config.window_width != config->window_width ||        old_config.window_height != config->window_height)    {        SDL_DestroyTexture(renderer->overlay_texture);        renderer->overlay_texture = create_game_texture(            renderer->renderer,            config->window_width,            config->window_height);        if (!renderer->overlay_texture)        {            renderer->config = old_config;            return false;        }        SDL_SetWindowSize(renderer->window,                          config->window_width,                          config->window_height);    }    // Atualizar flags de renderização    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY,                config->smooth_scaling ? "linear" : "nearest");    SDL_RenderSetIntegerScale(renderer->renderer,                              config->integer_scaling ? SDL_TRUE : SDL_FALSE);    return true;}void sdl_game_renderer_get_config(const sdl_game_renderer_t *renderer, sdl_renderer_config_t *config){    if (!renderer || !config)        return;    *config = renderer->config;}bool sdl_game_renderer_toggle_fullscreen(sdl_game_renderer_t *renderer){    if (!renderer || !renderer->initialized)        return false;    bool is_fullscreen = SDL_GetWindowFlags(renderer->window) & SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(renderer->window,                                is_fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP) < 0)    {        return false;    }    renderer->config.fullscreen = !is_fullscreen;    return true;}bool sdl_game_renderer_set_scale(sdl_game_renderer_t *renderer, float scale){    if (!renderer || !renderer->initialized || scale <= 0)        return false;    renderer->config.scale_factor = scale;    if (!renderer->config.fullscreen)    {        SDL_SetWindowSize(renderer->window,                          (int)(renderer->config.game_width * scale),                          (int)(renderer->config.game_height * scale));    }    return true;}void sdl_game_renderer_get_output_size(const sdl_game_renderer_t *renderer, int *width, int *height){    if (!renderer || !renderer->initialized)        return;    SDL_GetRendererOutputSize(renderer->renderer, width, height);}void sdl_game_renderer_get_game_rect(const sdl_game_renderer_t *renderer, SDL_Rect *rect){    if (!renderer || !renderer->initialized || !rect)        return;    int window_width, window_height;    SDL_GetRendererOutputSize(renderer->renderer, &window_width, &window_height);    float game_aspect = (float)renderer->config.game_width / renderer->config.game_height;    float window_aspect = (float)window_width / window_height;    if (game_aspect > window_aspect)    {        // Ajustar pela largura        rect->w = window_width;        rect->h = (int)(window_width / game_aspect);        rect->x = 0;        rect->y = (window_height - rect->h) / 2;    }    else    {        // Ajustar pela altura        rect->h = window_height;        rect->w = (int)(window_height * game_aspect);        rect->x = (window_width - rect->w) / 2;        rect->y = 0;    }}bool sdl_game_renderer_handle_resize(sdl_game_renderer_t *renderer, int width, int height){    if (!renderer || !renderer->initialized)        return false;    renderer->config.window_width = width;    renderer->config.window_height = height;    // Recriar textura de overlay com novo tamanho    SDL_DestroyTexture(renderer->overlay_texture);    renderer->overlay_texture = create_game_texture(        renderer->renderer,        width,        height);    return renderer->overlay_texture != NULL;}