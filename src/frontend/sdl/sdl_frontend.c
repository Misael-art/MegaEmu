/** * @file sdl_frontend.c * @brief Implementação do frontend baseado em SDL (compatível com SDL2 e SDL3) */#include <SDL2/SDL.h>#include <SDL2/SDL_gamecontroller.h>#include <stdbool.h>#include <stdint.h>#include <stdio.h>#include <string.h>#include <stdlib.h>#ifdef _WIN32#include <windows.h>#endif#include "frontend/common/frontend_config.h"#include "frontend/sdl/sdl_game_renderer.h"#include "frontend/sdl/sdl_frontend_state.h"#include "frontend/sdl/sdl_frontend.h"#include "core/core.h"#include "frontend/common/frontend.h"#include "utils/log_utils.h"#include "utils/enhanced_log.h"#include "utils/log_categories.h"#include "utils/log_modules.h"// Definições para compatibilidade SDL2/SDL3#define SDL_MAIN_HANDLED// Estado global do frontendstatic sdl_frontend_state_t g_state;// Tentar carregar SDL3 primeiro, se não disponível, tenta SDL2#ifdef _WIN32#define SDL3_DLL_NAME "SDL3.dll"#define SDL2_DLL_NAME "SDL2.dll"// Flag global para indicar qual versão do SDL está sendo usadastatic int g_using_sdl3 = 0;/** * @brief Verifica se a DLL do SDL está disponível * * @return 1 se disponível, 0 caso contrário */int check_sdl_dll(void){    HMODULE hModule = LoadLibraryA(SDL3_DLL_NAME);    if (hModule != NULL)    {        printf("SDL3.dll carregada com sucesso: %p\n", hModule);        FreeLibrary(hModule);        g_using_sdl3 = 1;        return 1;    }    // Tentar carregar SDL2 como fallback    hModule = LoadLibraryA(SDL2_DLL_NAME);    if (hModule != NULL)    {        printf("SDL2.dll carregada com sucesso: %p\n", hModule);        FreeLibrary(hModule);        g_using_sdl3 = 0;        return 1;    }    DWORD error = GetLastError();    printf("Erro ao carregar SDL.dll: %lu\n", error);    // Verificar se os arquivos existem    FILE *f = fopen(SDL3_DLL_NAME, "rb");    if (f)    {        printf("Arquivo SDL3.dll existe, mas não pode ser carregado\n");        fclose(f);    }    else    {        printf("Arquivo SDL3.dll não encontrado\n");    }    f = fopen(SDL2_DLL_NAME, "rb");    if (f)    {        printf("Arquivo SDL2.dll existe, mas não pode ser carregado\n");        fclose(f);    }    else    {        printf("Arquivo SDL2.dll não encontrado\n");    }    // Verificar diretório atual    char current_dir[MAX_PATH];    GetCurrentDirectoryA(MAX_PATH, current_dir);    printf("Diretório atual: %s\n", current_dir);    return 0;}#elseint check_sdl_dll(void){    return 1; // Assume success on non-Windows platforms}#endif// Definir macro UNUSED se não estiver definida#ifndef UNUSED#define UNUSED(x) (void)(x)#endif// Macros de log para o frontend#define FRONTEND_LOG_ERROR(...) EMU_LOG_ERROR(EMU_LOG_CAT_FRONTEND, __VA_ARGS__)#define FRONTEND_LOG_WARN(...) EMU_LOG_WARN(EMU_LOG_CAT_FRONTEND, __VA_ARGS__)#define FRONTEND_LOG_INFO(...) EMU_LOG_INFO(EMU_LOG_CAT_FRONTEND, __VA_ARGS__)#define FRONTEND_LOG_DEBUG(...) EMU_LOG_DEBUG(EMU_LOG_CAT_FRONTEND, __VA_ARGS__)// Configuração padrão local para o SDL frontendstatic const emu_frontend_config_t SDL_DEFAULT_FRONTEND_CONFIG = {    // Vídeo    .window_width = 800,    .window_height = 600,    .game_width = 256,    .game_height = 240,    .scale_factor = 2.0f,    .vsync_enabled = true,    .fullscreen = false,    .smooth_scaling = false,    .integer_scaling = true,    // Áudio    .audio_sample_rate = 44100,    .audio_buffer_size = 2048,    .audio_enabled = true,    // Entrada    .keyboard_enabled = true,    .gamepad_enabled = true,    // Interface    .show_fps = true,    .debug_overlay = false};// Callback de áudiostatic void audio_callback(void *userdata, Uint8 *stream, int len){    sdl_frontend_state_t *state = (sdl_frontend_state_t *)userdata;    SDL_memcpy(state->audio_buffer, stream, len);}/** * @brief Mostra uma mensagem de erro na linha de comando */void show_sdl_missing_error(void){    printf("\n\n");    printf("*** ERRO: Biblioteca SDL não encontrada ou não está acessível ***\n");    printf("Para corrigir este problema:\n");    printf("1. Certifique-se de que o SDL3 ou SDL2 está instalado no seu sistema\n");    printf("2. Copie o arquivo SDL3.dll ou SDL2.dll para o diretório do executável\n");    printf("   (o arquivo deve estar em: D:\\Steamapps\\Dev\\PC Engines Projects\\Mega_Emu\\Debug\\)\n");    printf("\n");    printf("O emulador continuará em modo de texto sem interface gráfica.\n");    printf("\n\n");}/** * @brief Sistema de log robusto para o SDL * * @param categoria Categoria da mensagem * @param prioridade Prioridade da mensagem (debug, info, warning, error) * @param mensagem A mensagem de log */void sdl_log_callback(void *userdata, int categoria, SDL_LogPriority prioridade, const char *mensagem){    UNUSED(userdata);    emu_log_level_t level;    emu_log_category_t cat;    // Mapear prioridade SDL para nível de log    switch (prioridade)    {    case SDL_LOG_PRIORITY_VERBOSE:        level = EMU_LOG_LEVEL_DEBUG;        break;    case SDL_LOG_PRIORITY_DEBUG:        level = EMU_LOG_LEVEL_DEBUG;        break;    case SDL_LOG_PRIORITY_INFO:        level = EMU_LOG_LEVEL_INFO;        break;    case SDL_LOG_PRIORITY_WARN:        level = EMU_LOG_LEVEL_WARNING;        break;    case SDL_LOG_PRIORITY_ERROR:        level = EMU_LOG_LEVEL_ERROR;        break;    case SDL_LOG_PRIORITY_CRITICAL:        level = EMU_LOG_LEVEL_ERROR;        break;    default:        level = EMU_LOG_LEVEL_INFO;    }    // Mapear categoria SDL para categoria de log    switch (categoria)    {    case SDL_LOG_CATEGORY_APPLICATION:        cat = EMU_LOG_CAT_CORE;        break;    case SDL_LOG_CATEGORY_ERROR:        cat = EMU_LOG_CAT_CORE;        break;    case SDL_LOG_CATEGORY_ASSERT:        cat = EMU_LOG_CAT_CORE;        break;    case SDL_LOG_CATEGORY_SYSTEM:        cat = EMU_LOG_CAT_CORE;        break;    case SDL_LOG_CATEGORY_AUDIO:        cat = EMU_LOG_CAT_AUDIO;        break;    case SDL_LOG_CATEGORY_VIDEO:        cat = EMU_LOG_CAT_VIDEO;        break;    case SDL_LOG_CATEGORY_RENDER:        cat = EMU_LOG_CAT_VIDEO;        break;    case SDL_LOG_CATEGORY_INPUT:        cat = EMU_LOG_CAT_INPUT;        break;    case SDL_LOG_CATEGORY_TEST:        cat = EMU_LOG_CAT_CORE;        break;    default:        cat = EMU_LOG_CAT_CORE;    }    emu_log_message(level, cat, __FILE__, __LINE__, "%s", mensagem);}// Funções de inicialização e finalizaçãobool sdl_frontend_init(const emu_frontend_config_t *config){    // Inicializar o estado global    memset(&g_state, 0, sizeof(sdl_frontend_state_t));    FRONTEND_LOG_INFO("Inicializando frontend SDL");    printf("Inicializando frontend SDL...\n");    // Verificar DLL do SDL    if (!check_sdl_dll())    {        show_sdl_missing_error();        return false;    }    // Usar configuração padrão se não fornecida    if (config)    {        memcpy(&g_state.config, config, sizeof(emu_frontend_config_t));    }    else    {        memcpy(&g_state.config, &SDL_DEFAULT_FRONTEND_CONFIG, sizeof(emu_frontend_config_t));    }    // Configurar callback de log do SDL    SDL_LogSetOutputFunction(sdl_log_callback, NULL);    // Inicializar SDL    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_GAMECONTROLLER) < 0)    {        FRONTEND_LOG_ERROR("Erro ao inicializar SDL: %s", SDL_GetError());        return false;    }    // Inicializar renderizador    sdl_renderer_config_t renderer_config = {        .window_width = g_state.config.window_width,        .window_height = g_state.config.window_height,        .game_width = g_state.config.game_width,        .game_height = g_state.config.game_height,        .scale_factor = g_state.config.scale_factor,        .vsync_enabled = g_state.config.vsync_enabled,        .fullscreen = g_state.config.fullscreen,        .smooth_scaling = g_state.config.smooth_scaling,        .integer_scaling = g_state.config.integer_scaling};    if (!sdl_game_renderer_init(&g_state.renderer, &renderer_config))    {        FRONTEND_LOG_ERROR("Erro ao inicializar renderizador");        SDL_Quit();        return false;    }    // Configurar áudio    SDL_AudioSpec want, have;    SDL_memset(&want, 0, sizeof(want));    want.freq = g_state.config.audio_sample_rate;    want.format = AUDIO_S16;    want.channels = 2;    want.samples = g_state.config.audio_buffer_size;    want.callback = audio_callback;    want.userdata = &g_state;    g_state.audio_device = SDL_OpenAudioDevice(NULL, 0, &want, &have, 0);    if (g_state.audio_device == 0)    {        FRONTEND_LOG_ERROR("Erro ao abrir dispositivo de áudio: %s", SDL_GetError());        sdl_game_renderer_shutdown(&g_state.renderer);        SDL_Quit();        return false;    }    SDL_PauseAudioDevice(g_state.audio_device, 0);    // Inicializar controles    SDL_GameControllerEventState(SDL_ENABLE);    for (int i = 0; i < SDL_NumJoysticks(); i++)    {        if (SDL_IsGameController(i))        {            g_state.gamepad = SDL_GameControllerOpen(i);            if (g_state.gamepad)            {                FRONTEND_LOG_INFO("Controle conectado: %s", SDL_GameControllerName(g_state.gamepad));                break;            }        }    }    g_state.running = true;    g_state.show_fps = true;    return true;}void sdl_frontend_shutdown(void){    if (g_state.gamepad)    {        SDL_GameControllerClose(g_state.gamepad);        g_state.gamepad = NULL;    }    if (g_state.audio_device)    {        SDL_CloseAudioDevice(g_state.audio_device);        g_state.audio_device = 0;    }    sdl_game_renderer_shutdown(&g_state.renderer);    SDL_Quit();}// Funções de controlebool sdl_frontend_process_events(void){    SDL_Event event;    while (SDL_PollEvent(&event))    {        switch (event.type)        {        case SDL_QUIT:            g_state.running = false;            break;        case SDL_KEYDOWN:            if (event.key.keysym.sym == SDLK_ESCAPE)            {                g_state.running = false;            }            else if (event.key.keysym.sym == SDLK_F11)            {                g_state.show_fps = !g_state.show_fps;            }            else if (event.key.keysym.sym == SDLK_F12)            {                g_state.show_menu = !g_state.show_menu;            }            break;        case SDL_CONTROLLERDEVICEADDED:            if (!g_state.gamepad)            {                g_state.gamepad = SDL_GameControllerOpen(event.cdevice.which);                if (g_state.gamepad)                {                    FRONTEND_LOG_INFO("Controle conectado: %s", SDL_GameControllerName(g_state.gamepad));                }            }            break;        case SDL_CONTROLLERDEVICEREMOVED:            if (g_state.gamepad && event.cdevice.which == SDL_JoystickInstanceID(SDL_GameControllerGetJoystick(g_state.gamepad)))            {                SDL_GameControllerClose(g_state.gamepad);                g_state.gamepad = NULL;                FRONTEND_LOG_INFO("Controle desconectado");            }            break;        }    }    return g_state.running;}void sdl_frontend_render_frame(const uint32_t *framebuffer, const int16_t *audio_samples, int num_samples){    if (!g_state.running)        return;    // Atualizar áudio    if (audio_samples && num_samples > 0)    {        SDL_QueueAudio(g_state.audio_device, audio_samples, num_samples * sizeof(int16_t) * 2);    }    // Renderizar frame    sdl_game_renderer_begin_frame(&g_state.renderer);    if (framebuffer)    {        sdl_game_renderer_update_game_texture(&g_state.renderer, framebuffer);        sdl_game_renderer_draw_frame(&g_state.renderer);    }    sdl_game_renderer_end_frame(&g_state.renderer);    // Calcular FPS    Uint32 current_time = SDL_GetTicks();    if (current_time > g_state.last_fps_update + 1000)    {        g_state.fps = g_state.frames_since_last_fps;        g_state.frames_since_last_fps = 0;        g_state.last_fps_update = current_time;    }    g_state.frames_since_last_fps++;}bool sdl_frontend_is_running(void){    return g_state.running;}uint8_t sdl_frontend_get_controller_state(int controller){    if (controller < 0 || controller >= 4)        return 0;    return g_state.controller_states[controller];}void sdl_frontend_toggle_fullscreen(void){    sdl_game_renderer_toggle_fullscreen(&g_state.renderer);}void sdl_frontend_set_title(const char *title){    SDL_SetWindowTitle(SDL_RenderGetWindow(g_state.renderer.renderer), title);}float sdl_frontend_get_fps(void){    return g_state.fps;}