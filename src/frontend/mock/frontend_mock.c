/** * @file frontend_mock.c * @brief Implementação mock do frontend para testes */#include "frontend_mock.h"#include "utils/error_handling.h"#include "utils/enhanced_log.h"#include <stdlib.h>#include <string.h>/* Estrutura do frontend mock */typedef struct{    bool initialized;    uint32_t *framebuffer;    size_t framebuffer_size;    uint32_t width;    uint32_t height;    void *window_handle;} emu_frontend_mock_t;/* Instância global do frontend mock */static emu_frontend_mock_t g_frontend_mock = {0};/* Funções de interface */bool emu_frontend_init(void){    if (g_frontend_mock.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_FRONTEND, "Frontend mock já inicializado");        return false;    }    g_frontend_mock.initialized = true;    g_frontend_mock.width = 256;    g_frontend_mock.height = 240;    g_frontend_mock.framebuffer_size = g_frontend_mock.width * g_frontend_mock.height * sizeof(uint32_t);    g_frontend_mock.framebuffer = calloc(1, g_frontend_mock.framebuffer_size);    g_frontend_mock.window_handle = (void *)0x12345678; // Handle mock    if (!g_frontend_mock.framebuffer)    {        EMU_LOG_ERROR(EMU_LOG_CAT_FRONTEND, "Falha ao alocar framebuffer");        return false;    }    EMU_LOG_INFO(EMU_LOG_CAT_FRONTEND, "Frontend mock inicializado com sucesso");    return true;}void emu_frontend_shutdown(void){    if (!g_frontend_mock.initialized)    {        EMU_LOG_WARNING(EMU_LOG_CAT_FRONTEND, "Frontend mock não inicializado");        return;    }    free(g_frontend_mock.framebuffer);    memset(&g_frontend_mock, 0, sizeof(emu_frontend_mock_t));    EMU_LOG_INFO(EMU_LOG_CAT_FRONTEND, "Frontend mock finalizado");}bool emu_frontend_process_events(void){    if (!g_frontend_mock.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_FRONTEND, "Frontend mock não inicializado");        return false;    }    return true;}bool emu_frontend_render_frame(const uint32_t *framebuffer){    if (!g_frontend_mock.initialized || !framebuffer)    {        EMU_LOG_ERROR(EMU_LOG_CAT_FRONTEND, "Frontend mock não inicializado ou framebuffer inválido");        return false;    }    memcpy(g_frontend_mock.framebuffer, framebuffer, g_frontend_mock.framebuffer_size);    return true;}bool emu_frontend_update_window(void){    if (!g_frontend_mock.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_FRONTEND, "Frontend mock não inicializado");        return false;    }    return true;}/* Funções específicas do mock */uint32_t *emu_frontend_mock_get_framebuffer(void){    return g_frontend_mock.framebuffer;}void *emu_frontend_mock_get_window_handle(void){    return g_frontend_mock.window_handle;}uint32_t emu_frontend_mock_get_width(void){    return g_frontend_mock.width;}uint32_t emu_frontend_mock_get_height(void){    return g_frontend_mock.height;}bool emu_frontend_mock_is_initialized(void){    return g_frontend_mock.initialized;}