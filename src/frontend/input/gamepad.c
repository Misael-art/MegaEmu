#include <SDL2/SDL.h>#include <stdio.h>#include <string.h>#include <stdbool.h>#include "gamepad.h"#include "../../utils/enhanced_log.h"// Número máximo de gamepads suportados#define MAX_GAMEPADS 4// Número máximo de botões por gamepad#define MAX_BUTTONS 16// Estrutura para mapear botões do gamepad para botões do sistema emuladotypedef struct{    int sdl_button;   // Código do botão SDL    int emu_button;   // Código do botão do emulador    const char *name; // Nome do botão para o usuário} button_mapping_t;// Estrutura para mapear direcionais analógicostypedef struct{    int sdl_axis;     // Eixo SDL    int direction;    // Direção (+1 ou -1)    int emu_button;   // Botão correspondente no emulador    const char *name; // Nome para o usuário} analog_mapping_t;// Estrutura para armazenar estado de um gamepadtypedef struct{    SDL_GameController *controller; // Ponteiro para o controlador SDL    int player_index;               // Índice do jogador (0-3)    char name[64];                  // Nome do controlador    bool is_connected;              // Se está conectado    // Mapeamento customizado    button_mapping_t button_mapping[MAX_BUTTONS];    analog_mapping_t analog_mapping[6]; // Suporte para 3 eixos em ambas direções    // Estado atual    uint16_t current_state; // Estado atual dos botões (como bitmap)} gamepad_t;// Array de gamepadsstatic gamepad_t g_gamepads[MAX_GAMEPADS];// Número de gamepads ativosstatic int g_active_gamepads = 0;// Indicador de inicializaçãostatic bool g_is_initialized = false;// Log específico para gamepad#define GAMEPAD_LOG_INFO(msg, ...) EMU_LOG_INFO(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)#define GAMEPAD_LOG_ERROR(msg, ...) EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)#define GAMEPAD_LOG_WARN(msg, ...) EMU_LOG_WARN(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)#define GAMEPAD_LOG_DEBUG(msg, ...) EMU_LOG_DEBUG(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)// Mapeamento padrão para NESstatic const button_mapping_t g_default_nes_mapping[] = {    {SDL_CONTROLLER_BUTTON_A, GAMEPAD_NES_A, "A"},    {SDL_CONTROLLER_BUTTON_B, GAMEPAD_NES_B, "B"},    {SDL_CONTROLLER_BUTTON_START, GAMEPAD_NES_START, "Start"},    {SDL_CONTROLLER_BUTTON_BACK, GAMEPAD_NES_SELECT, "Select"},    {SDL_CONTROLLER_BUTTON_DPAD_UP, GAMEPAD_NES_UP, "Up"},    {SDL_CONTROLLER_BUTTON_DPAD_DOWN, GAMEPAD_NES_DOWN, "Down"},    {SDL_CONTROLLER_BUTTON_DPAD_LEFT, GAMEPAD_NES_LEFT, "Left"},    {SDL_CONTROLLER_BUTTON_DPAD_RIGHT, GAMEPAD_NES_RIGHT, "Right"},    {-1, -1, NULL} // Terminador};// Mapeamento padrão para analógicos (estiques) no NESstatic const analog_mapping_t g_default_nes_analog_mapping[] = {    {SDL_CONTROLLER_AXIS_LEFTX, 1, GAMEPAD_NES_RIGHT, "Stick Esquerdo (Direita)"},    {SDL_CONTROLLER_AXIS_LEFTX, -1, GAMEPAD_NES_LEFT, "Stick Esquerdo (Esquerda)"},    {SDL_CONTROLLER_AXIS_LEFTY, 1, GAMEPAD_NES_DOWN, "Stick Esquerdo (Baixo)"},    {SDL_CONTROLLER_AXIS_LEFTY, -1, GAMEPAD_NES_UP, "Stick Esquerdo (Cima)"},    {-1, 0, -1, NULL} // Terminador};// Aplicar mapeamento padrãostatic void apply_default_mapping(gamepad_t *gamepad){    int i;    // Copiar mapeamento de botões    for (i = 0; g_default_nes_mapping[i].name != NULL; i++)    {        gamepad->button_mapping[i] = g_default_nes_mapping[i];    }    // Adicionar terminador    gamepad->button_mapping[i].sdl_button = -1;    gamepad->button_mapping[i].emu_button = -1;    gamepad->button_mapping[i].name = NULL;    // Copiar mapeamento analógico    for (i = 0; g_default_nes_analog_mapping[i].name != NULL; i++)    {        gamepad->analog_mapping[i] = g_default_nes_analog_mapping[i];    }    // Adicionar terminador    gamepad->analog_mapping[i].sdl_axis = -1;    gamepad->analog_mapping[i].direction = 0;    gamepad->analog_mapping[i].emu_button = -1;    gamepad->analog_mapping[i].name = NULL;}// Carregar mapeamento customizadostatic void load_custom_mapping(gamepad_t *gamepad, const char *config_file){    // TODO: Implementar carregamento de configuração de um arquivo    // Por enquanto, usa o mapeamento padrão    apply_default_mapping(gamepad);}// Inicializar o sistema de gamepadbool gamepad_init(void){    if (g_is_initialized)    {        GAMEPAD_LOG_WARN("Sistema de gamepad já inicializado");        return true;    }    // Inicializar array de gamepads    memset(g_gamepads, 0, sizeof(g_gamepads));    g_active_gamepads = 0;    // Garantir que o subsistema de joystick está inicializado    if (SDL_InitSubSystem(SDL_INIT_JOYSTICK | SDL_INIT_GAMECONTROLLER) < 0)    {        GAMEPAD_LOG_ERROR("Falha ao inicializar subsistema de gamepad: %s", SDL_GetError());        return false;    }    // Habilitar eventos de gamepad    SDL_GameControllerEventState(SDL_ENABLE);    // Tentar detectar gamepads já conectados    gamepad_detect_devices();    g_is_initialized = true;    GAMEPAD_LOG_INFO("Sistema de gamepad inicializado");    return true;}// Finalizar o sistema de gamepadvoid gamepad_shutdown(void){    if (!g_is_initialized)    {        return;    }    // Fechar todos os controladores abertos    for (int i = 0; i < MAX_GAMEPADS; i++)    {        if (g_gamepads[i].controller)        {            SDL_GameControllerClose(g_gamepads[i].controller);            g_gamepads[i].controller = NULL;            g_gamepads[i].is_connected = false;        }    }    g_is_initialized = false;    g_active_gamepads = 0;    GAMEPAD_LOG_INFO("Sistema de gamepad finalizado");}// Detectar gamepads conectadosvoid gamepad_detect_devices(void){    if (!g_is_initialized)    {        GAMEPAD_LOG_ERROR("Sistema de gamepad não inicializado");        return;    }    int num_joysticks = SDL_NumJoysticks();    GAMEPAD_LOG_INFO("Detectando gamepads... %d dispositivos encontrados", num_joysticks);    // Fechar controladores existentes    for (int i = 0; i < MAX_GAMEPADS; i++)    {        if (g_gamepads[i].controller)        {            SDL_GameControllerClose(g_gamepads[i].controller);            g_gamepads[i].controller = NULL;            g_gamepads[i].is_connected = false;        }    }    // Resetar contador    g_active_gamepads = 0;    // Abrir novos controladores    for (int i = 0; i < num_joysticks && g_active_gamepads < MAX_GAMEPADS; i++)    {        if (SDL_IsGameController(i))        {            SDL_GameController *controller = SDL_GameControllerOpen(i);            if (controller)            {                // Encontrar slot disponível                int slot = g_active_gamepads++;                // Configurar gamepad                g_gamepads[slot].controller = controller;                g_gamepads[slot].is_connected = true;                g_gamepads[slot].player_index = slot;                g_gamepads[slot].current_state = 0;                // Obter nome                const char *name = SDL_GameControllerName(controller);                if (name)                {                    strncpy(g_gamepads[slot].name, name, sizeof(g_gamepads[slot].name) - 1);                }                else                {                    snprintf(g_gamepads[slot].name, sizeof(g_gamepads[slot].name), "Gamepad %d", slot + 1);                }                // Aplicar mapeamento padrão                apply_default_mapping(&g_gamepads[slot]);                GAMEPAD_LOG_INFO("Gamepad conectado [%d]: %s", slot, g_gamepads[slot].name);            }        }    }    GAMEPAD_LOG_INFO("Total de gamepads ativos: %d", g_active_gamepads);}// Processar evento de gamepadbool gamepad_process_event(SDL_Event *event){    if (!g_is_initialized || !event)    {        return false;    }    // Evento de conexão/desconexão de dispositivo    if (event->type == SDL_CONTROLLERDEVICEADDED ||        event->type == SDL_CONTROLLERDEVICEREMOVED)    {        // Redetectar dispositivos        gamepad_detect_devices();        return true;    }    // Evento de botão    if (event->type == SDL_CONTROLLERBUTTONDOWN ||        event->type == SDL_CONTROLLERBUTTONUP)    {        SDL_ControllerButtonEvent *button_event = &event->cbutton;        int device_index = button_event->which;        int button = button_event->button;        bool pressed = (event->type == SDL_CONTROLLERBUTTONDOWN);        // Encontrar gamepad correspondente        for (int i = 0; i < g_active_gamepads; i++)        {            SDL_JoystickID joy_id = SDL_JoystickInstanceID(                SDL_GameControllerGetJoystick(g_gamepads[i].controller));            if (joy_id == device_index)            {                // Mapear o botão SDL para o botão do emulador                for (int j = 0; g_gamepads[i].button_mapping[j].sdl_button != -1; j++)                {                    if (g_gamepads[i].button_mapping[j].sdl_button == button)                    {                        int emu_button = g_gamepads[i].button_mapping[j].emu_button;                        // Atualizar estado                        if (pressed)                        {                            g_gamepads[i].current_state |= (1 << emu_button);                        }                        else                        {                            g_gamepads[i].current_state &= ~(1 << emu_button);                        }                        GAMEPAD_LOG_DEBUG("Botão %s do gamepad %d %s (emu botão: %d)",                                          g_gamepads[i].button_mapping[j].name, i,                                          pressed ? "pressionado" : "liberado", emu_button);                        return true;                    }                }                break;            }        }    }    // Evento de analógico    if (event->type == SDL_CONTROLLERAXISMOTION)    {        SDL_ControllerAxisEvent *axis_event = &event->caxis;        int device_index = axis_event->which;        int axis = axis_event->axis;        int value = axis_event->value;        // Definir limite para considerar movimento significativo (zona morta)        const int AXIS_THRESHOLD = 16384; // ~50% da amplitude total (32768)        // Encontrar gamepad correspondente        for (int i = 0; i < g_active_gamepads; i++)        {            SDL_JoystickID joy_id = SDL_JoystickInstanceID(                SDL_GameControllerGetJoystick(g_gamepads[i].controller));            if (joy_id == device_index)            {                // Verificar mapeamentos analógicos                for (int j = 0; g_gamepads[i].analog_mapping[j].sdl_axis != -1; j++)                {                    if (g_gamepads[i].analog_mapping[j].sdl_axis == axis)                    {                        int direction = g_gamepads[i].analog_mapping[j].direction;                        int emu_button = g_gamepads[i].analog_mapping[j].emu_button;                        // Verificar direção                        bool is_active = false;                        if (direction > 0 && value > AXIS_THRESHOLD)                        {                            is_active = true;                        }                        else if (direction < 0 && value < -AXIS_THRESHOLD)                        {                            is_active = true;                        }                        // Atualizar estado                        if (is_active)                        {                            g_gamepads[i].current_state |= (1 << emu_button);                        }                        else                        {                            g_gamepads[i].current_state &= ~(1 << emu_button);                        }                    }                }                break;            }        }    }    return false;}// Obter o estado atual de um gamepaduint16_t gamepad_get_state(int player_index){    if (!g_is_initialized || player_index < 0 || player_index >= MAX_GAMEPADS)    {        return 0;    }    // Se não houver controles conectados, retorna 0    if (g_active_gamepads == 0)    {        return 0;    }    // Se o índice é maior que o número de controles, usa o último    if (player_index >= g_active_gamepads)    {        player_index = g_active_gamepads - 1;    }    return g_gamepads[player_index].current_state;}// Verificar se um gamepad está conectadobool gamepad_is_connected(int player_index){    if (!g_is_initialized || player_index < 0 || player_index >= MAX_GAMEPADS)    {        return false;    }    return g_gamepads[player_index].is_connected;}// Obter o número de gamepads conectadosint gamepad_get_count(void){    return g_active_gamepads;}// Obter o nome de um gamepadconst char *gamepad_get_name(int player_index){    if (!g_is_initialized || player_index < 0 || player_index >= MAX_GAMEPADS)    {        return NULL;    }    if (!g_gamepads[player_index].is_connected)    {        return NULL;    }    return g_gamepads[player_index].name;}// Aplicar rumble (vibração) em um gamepadbool gamepad_rumble(int player_index, float intensity, uint32_t duration_ms){    // Implementação de vibração - requer SDL 2.0.9+#if SDL_VERSION_ATLEAST(2, 0, 9)    if (!g_is_initialized || player_index < 0 || player_index >= MAX_GAMEPADS)    {        return false;    }    if (!g_gamepads[player_index].is_connected || !g_gamepads[player_index].controller)    {        return false;    }    // Converter intensidade (0.0-1.0) para valores de SDL (0-65535)    if (intensity < 0.0f)        intensity = 0.0f;    if (intensity > 1.0f)        intensity = 1.0f;    uint16_t low_freq = (uint16_t)(intensity * 65535.0f);    uint16_t high_freq = (uint16_t)(intensity * 65535.0f * 0.75f); // Alta freq. menos intensa    return (SDL_GameControllerRumble(g_gamepads[player_index].controller,                                     low_freq, high_freq, duration_ms) == 0);#else    return false; // Não suportado nesta versão do SDL#endif}