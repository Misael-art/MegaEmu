#include <stdint.h>/** * @file render_system.hpp * @brief Define a classe base para o sistema de renderização * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-10 */#pragma once#include <SDL2/SDL.h>#include <string>#include <map>#include <vector>#include <memory>#include "window.hpp"#include "gui_includes.h"namespace MegaEmu{    namespace Frontend    {        /**         * @brief Estrutura que representa uma sprite         */        struct Sprite        {            SDL_Texture *texture;   ///< Textura da sprite            int32_t width;          ///< Largura da sprite            int32_t height;         ///< Altura da sprite            int32_t frameWidth;     ///< Largura de um frame da sprite            int32_t frameHeight;    ///< Altura de um frame da sprite            int32_t numFrames;      ///< Número de frames da sprite            int32_t currentFrame;   ///< Frame atual da sprite            bool animated;          ///< Se a sprite é animada            int32_t animationSpeed; ///< Velocidade da animação em frames por segundo            Uint32 lastUpdateTime;  ///< Último momento em que a sprite foi atualizada        };        /**         * @brief Classe que gerencia o sistema de renderização         */        class RenderSystem        {        public:            RenderSystem();            ~RenderSystem();            bool Initialize(const char *title, int width, int height);            void Shutdown();            void Clear();            void Present();            void DrawTexture(SDL_Texture *texture, const SDL_Rect *src, const SDL_Rect *dst);            void DrawRect(const SDL_Rect *rect, const SDL_Color &color);            void DrawText(const char *text, int x, int y, const SDL_Color &color);            SDL_Renderer *GetRenderer() { return renderer; }            SDL_Window *GetWindow() { return window; }            /**             * @brief Carrega uma textura a partir de um arquivo             * @param id Identificador da textura             * @param filename Nome do arquivo             * @return true se a textura foi carregada com sucesso             */            bool loadTexture(const std::string &id, const std::string &filename)            {                SDL_Surface *surface = SDL_LoadBMP(filename.c_str());                if (!surface)                {                    return false;                }                SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, surface);                SDL_FreeSurface(surface);                if (!texture)                {                    return false;                }                // Remover textura anterior se existir                if (textures[id])                {                    SDL_DestroyTexture(textures[id]);                }                textures[id] = texture;                return true;            }            /**             * @brief Carrega uma sprite a partir de um arquivo             * @param id Identificador da sprite             * @param filename Nome do arquivo             * @param frameWidth Largura de um frame da sprite             * @param frameHeight Altura de um frame da sprite             * @param numFrames Número de frames da sprite             * @param animated Se a sprite é animada             * @param animationSpeed Velocidade da animação em frames por segundo             * @return true se a sprite foi carregada com sucesso             */            bool loadSprite(                const std::string &id,                const std::string &filename,                int32_t frameWidth,                int32_t frameHeight,                int32_t numFrames = 1,                bool animated = false,                int32_t animationSpeed = 10)            {                SDL_Surface *surface = SDL_LoadBMP(filename.c_str());                if (!surface)                {                    return false;                }                SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, surface);                int32_t width = surface->w;                int32_t height = surface->h;                SDL_FreeSurface(surface);                if (!texture)                {                    return false;                }                // Remover sprite anterior se existir                if (sprites.find(id) != sprites.end() && sprites[id].texture)                {                    SDL_DestroyTexture(sprites[id].texture);                }                Sprite sprite = {                    texture,                    width,                    height,                    frameWidth,                    frameHeight,                    numFrames,                    0, // currentFrame                    animated,                    animationSpeed,                    SDL_GetTicks() // lastUpdateTime                };                sprites[id] = sprite;                return true;            }            /**             * @brief Renderiza uma textura             * @param id Identificador da textura             * @param x Posição X             * @param y Posição Y             * @param width Largura (opcional)             * @param height Altura (opcional)             * @return true se a textura foi renderizada com sucesso             */            bool renderTexture(                const std::string &id,                int32_t x,                int32_t y,                int32_t width = 0,                int32_t height = 0)            {                if (textures.find(id) == textures.end() || !textures[id])                {                    return false;                }                SDL_Rect destRect = {x, y, width, height};                if (width == 0 || height == 0)                {                    // Obter dimensões da textura                    SDL_QueryTexture(textures[id], nullptr, nullptr, &destRect.w, &destRect.h);                }                SDL_RenderCopy(renderer, textures[id], nullptr, &destRect);                return true;            }            /**             * @brief Renderiza uma sprite             * @param id Identificador da sprite             * @param x Posição X             * @param y Posição Y             * @param scale Escala (1.0 = tamanho original)             * @return true se a sprite foi renderizada com sucesso             */            bool renderSprite(                const std::string &id,                int32_t x,                int32_t y,                float scale = 1.0f)            {                if (sprites.find(id) == sprites.end() || !sprites[id].texture)                {                    return false;                }                Sprite &sprite = sprites[id];                // Atualizar animação se necessário                if (sprite.animated)                {                    Uint32 currentTime = SDL_GetTicks();                    Uint32 elapsed = currentTime - sprite.lastUpdateTime;                    if (elapsed > 1000 / sprite.animationSpeed)                    {                        sprite.currentFrame = (sprite.currentFrame + 1) % sprite.numFrames;                        sprite.lastUpdateTime = currentTime;                    }                }                // Calcular retângulo fonte                int32_t frameX = (sprite.currentFrame % (sprite.width / sprite.frameWidth)) * sprite.frameWidth;                int32_t frameY = (sprite.currentFrame / (sprite.width / sprite.frameWidth)) * sprite.frameHeight;                SDL_Rect srcRect = {                    frameX,                    frameY,                    sprite.frameWidth,                    sprite.frameHeight};                // Calcular retângulo destino                SDL_Rect destRect = {                    x,                    y,                    static_cast<int32_t>(sprite.frameWidth * scale),                    static_cast<int32_t>(sprite.frameHeight * scale)};                SDL_RenderCopy(renderer, sprite.texture, &srcRect, &destRect);                return true;            }            /**             * @brief Desenha um retângulo             * @param x Posição X             * @param y Posição Y             * @param width Largura             * @param height Altura             * @param r Componente vermelha (0-255)             * @param g Componente verde (0-255)             * @param b Componente azul (0-255)             * @param a Componente alfa (0-255)             * @param filled Se o retângulo deve ser preenchido             */            void drawRect(                int32_t x,                int32_t y,                int32_t width,                int32_t height,                Uint8 r,                Uint8 g,                Uint8 b,                Uint8 a = 255,                bool filled = true)            {                SDL_Rect rect = {x, y, width, height};                SDL_SetRenderDrawColor(renderer, r, g, b, a);                if (filled)                {                    SDL_RenderFillRect(renderer, &rect);                }                else                {                    SDL_RenderDrawRect(renderer, &rect);                }            }            /**             * @brief Desenha uma linha             * @param x1 Posição X inicial             * @param y1 Posição Y inicial             * @param x2 Posição X final             * @param y2 Posição Y final             * @param r Componente vermelha (0-255)             * @param g Componente verde (0-255)             * @param b Componente azul (0-255)             * @param a Componente alfa (0-255)             */            void drawLine(                int32_t x1,                int32_t y1,                int32_t x2,                int32_t y2,                Uint8 r,                Uint8 g,                Uint8 b,                Uint8 a = 255)            {                SDL_SetRenderDrawColor(renderer, r, g, b, a);                SDL_RenderDrawLine(renderer, x1, y1, x2, y2);            }            /**             * @brief Desenha um círculo             * @param centerX Centro X             * @param centerY Centro Y             * @param radius Raio             * @param r Componente vermelha (0-255)             * @param g Componente verde (0-255)             * @param b Componente azul (0-255)             * @param a Componente alfa (0-255)             * @param filled Se o círculo deve ser preenchido             */            void drawCircle(                int32_t centerX,                int32_t centerY,                int32_t radius,                Uint8 r,                Uint8 g,                Uint8 b,                Uint8 a = 255,                bool filled = true)            {                SDL_SetRenderDrawColor(renderer, r, g, b, a);                if (filled)                {                    // Algoritmo de Bresenham para círculo preenchido                    for (int32_t w = 0; w < radius * 2; w++)                    {                        for (int32_t h = 0; h < radius * 2; h++)                        {                            int32_t dx = radius - w;                            int32_t dy = radius - h;                            if ((dx * dx + dy * dy) <= (radius * radius))                            {                                SDL_RenderDrawPoint(renderer, centerX + dx, centerY + dy);                            }                        }                    }                }                else                {                    // Algoritmo de Bresenham para círculo                    int32_t x = radius - 1;                    int32_t y = 0;                    int32_t tx = 1;                    int32_t ty = 1;                    int32_t error = tx - (radius << 1);                    while (x >= y)                    {                        // Cada ponto do algoritmo gera 8 pontos do círculo                        SDL_RenderDrawPoint(renderer, centerX + x, centerY - y);                        SDL_RenderDrawPoint(renderer, centerX + x, centerY + y);                        SDL_RenderDrawPoint(renderer, centerX - x, centerY - y);                        SDL_RenderDrawPoint(renderer, centerX - x, centerY + y);                        SDL_RenderDrawPoint(renderer, centerX + y, centerY - x);                        SDL_RenderDrawPoint(renderer, centerX + y, centerY + x);                        SDL_RenderDrawPoint(renderer, centerX - y, centerY - x);                        SDL_RenderDrawPoint(renderer, centerX - y, centerY + x);                        if (error <= 0)                        {                            y++;                            error += ty;                            ty += 2;                        }                        if (error > 0)                        {                            x--;                            tx += 2;                            error += tx - (radius << 1);                        }                    }                }            }            /**             * @brief Define a cor de fundo             * @param r Componente vermelha (0-255)             * @param g Componente verde (0-255)             * @param b Componente azul (0-255)             * @param a Componente alfa (0-255)             */            void setBackgroundColor(Uint8 r, Uint8 g, Uint8 b, Uint8 a = 255)            {                backgroundColor = {r, g, b, a};            }        private:            SDL_Window *window;            SDL_Renderer *renderer;            bool initialized;            std::map<std::string, SDL_Texture *> textures; ///< Mapa de texturas            std::map<std::string, Sprite> sprites;         ///< Mapa de sprites            SDL_Color backgroundColor = {0, 0, 0, 255};    ///< Cor de fundo        };    } // namespace Frontend} // namespace MegaEmu