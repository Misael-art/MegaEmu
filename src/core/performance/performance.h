/** * @file performance.h * @brief Sistema de medição e otimização de performance * * Este módulo fornece ferramentas para monitorar, analisar e otimizar * o desempenho do emulador. Inclui contadores, timers, medidores de FPS, * rastreamento de memória e geração de relatórios. * * @note Parte do subsistema core/performance */#ifndef EMU_PERFORMANCE_H#define EMU_PERFORMANCE_H#ifdef __cplusplusextern "C" {#endif#include "core/core_types.h"#include <stdbool.h>#include <stdint.h>#include <time.h>/** * @defgroup PerfLimits Limites de Performance * @brief Limites e constantes para o sistema de performance * @{ *//** * @brief Número máximo de contadores de performance que podem ser criados */#define EMU_PERF_MAX_COUNTERS 128/** * @brief Tamanho máximo para nome de um contador de performance */#define EMU_PERF_MAX_NAME_LEN 64/** * @brief Máximo de histórico para cada contador (para média móvel) */#define EMU_PERF_HISTORY_SIZE 60/** @} *//** * @brief Tipos de contadores de performance * * Cada tipo de contador é especializado para medir um tipo específico * de métrica de desempenho. */typedef enum {    EMU_PERF_TYPE_TIMER,         /**< Medição de tempo de execução */    EMU_PERF_TYPE_COUNTER,       /**< Contador incremental (eventos) */    EMU_PERF_TYPE_VALUE,         /**< Valor arbitrário (float) */    EMU_PERF_TYPE_MEMORY,        /**< Uso de memória (alocações) */    EMU_PERF_TYPE_FRAMETIME,     /**< Tempo de frame/FPS */    EMU_PERF_TYPE_CUSTOM         /**< Tipo personalizado */} emu_perf_counter_type_t;/** * @brief Categorias de contadores de performance * * Categorias ajudam a organizar contadores por área funcional * do emulador. */typedef enum {    EMU_PERF_CAT_SYSTEM,         /**< Sistema geral */    EMU_PERF_CAT_CPU,            /**< Processador emulado */    EMU_PERF_CAT_GPU,            /**< Renderização/vídeo */    EMU_PERF_CAT_MEMORY,         /**< Gerenciamento de memória */    EMU_PERF_CAT_IO,             /**< Entrada/Saída */    EMU_PERF_CAT_AUDIO,          /**< Sistema de áudio */    EMU_PERF_CAT_NETWORK,        /**< Funcionalidades de rede */    EMU_PERF_CAT_EMULATION,      /**< Emulação específica */    EMU_PERF_CAT_DEBUG,          /**< Debug e diagnóstico */    EMU_PERF_CAT_CUSTOM          /**< Categoria personalizada */} emu_perf_category_t;/** * @brief Estrutura para um contador de performance * * Esta estrutura é o elemento central do sistema de performance, * armazenando informações sobre um contador específico e seus valores. * Dependendo do tipo, diferentes campos da union são utilizados. */typedef struct {    char name[EMU_PERF_MAX_NAME_LEN];  /**< Nome identificador */    emu_perf_counter_type_t type;      /**< Tipo do contador */    emu_perf_category_t category;      /**< Categoria */    /**     * @brief Dados específicos por tipo de contador     *     * Esta union contém estruturas especializadas para cada tipo     * de contador, economizando memória ao armazenar apenas os     * dados relevantes para o tipo específico.     */    union {        /**         * @brief Dados para contador tipo timer         *         * Armazena tempos de início, fim, médias e histórico         * para medir precisamente intervalos de tempo.         */        struct {            uint64_t start_time;                 /**< Tempo de início */            uint64_t total_time;                 /**< Tempo acumulado */            uint64_t last_lap;                   /**< Última medição de lap */            uint64_t min_time;                   /**< Tempo mínimo registrado */            uint64_t max_time;                   /**< Tempo máximo registrado */            double avg_time;                     /**< Tempo médio */            uint64_t history[EMU_PERF_HISTORY_SIZE]; /**< Histórico de medições */            int32_t history_index;                   /**< Índice atual no histórico */            int32_t samples;                         /**< Número de amostras coletadas */            bool is_running;                     /**< Se o timer está em execução */        } timer;        /**         * @brief Dados para contador incremental         *         * Usado para contar eventos, como número de frames,         * instruções executadas, etc.         */        struct {            uint64_t value;                      /**< Valor atual */            uint64_t min_value;                  /**< Valor mínimo registrado */            uint64_t max_value;                  /**< Valor máximo registrado */            double avg_value;                    /**< Valor médio */            uint64_t history[EMU_PERF_HISTORY_SIZE]; /**< Histórico de valores */            int32_t history_index;                   /**< Índice atual no histórico */            int32_t samples;                         /**< Número de amostras coletadas */        } counter;        /**         * @brief Dados para valor arbitrário         *         * Armazena um valor de ponto flutuante, útil para         * métricas como taxas, porcentagens, etc.         */        struct {            double value;                        /**< Valor atual */            double min_value;                    /**< Valor mínimo registrado */            double max_value;                    /**< Valor máximo registrado */            double avg_value;                    /**< Valor médio */            double history[EMU_PERF_HISTORY_SIZE]; /**< Histórico de valores */            int32_t history_index;                   /**< Índice atual no histórico */            int32_t samples;                         /**< Número de amostras coletadas */        } value;        /**         * @brief Dados para rastreamento de memória         *         * Monitora alocações e liberações de memória,         * permitindo detectar vazamentos e uso excessivo.         */        struct {            size_t current;                      /**< Uso atual de memória */            size_t peak;                         /**< Pico de uso de memória */            size_t allocated;                    /**< Total alocado desde o início */            size_t freed;                        /**< Total liberado desde o início */            int32_t allocations;                     /**< Número de alocações */            int32_t deallocations;                   /**< Número de liberações */        } memory;        /**         * @brief Dados para monitoramento de tempo de frame/FPS         *         * Especializado em medir fps e tempo entre frames,         * essencial para análise de desempenho de renderização.         */        struct {            uint64_t last_time;                  /**< Timestamp do último frame */            uint64_t frame_times[EMU_PERF_HISTORY_SIZE]; /**< Histórico de tempos */            float fps;                           /**< FPS atual */            float min_fps;                       /**< FPS mínimo registrado */            float max_fps;                       /**< FPS máximo registrado */            float avg_fps;                       /**< FPS médio */            int32_t frame_index;                     /**< Índice atual no histórico */            int32_t frame_count;                     /**< Contador total de frames */        } frametime;        /**         * @brief Dados para contador personalizado         *         * Permite extensibilidade para tipos não previstos.         */        struct {            void *data;                          /**< Dados personalizados */            size_t data_size;                    /**< Tamanho dos dados */        } custom;    };    void *user_data;                             /**< Dados definidos pelo usuário */    bool enabled;                                /**< Se o contador está habilitado */    int32_t id;                                      /**< ID único do contador */} emu_perf_counter_t;/** * @brief Estrutura para relatório de performance * * Agrupa múltiplos contadores e metadados para gerar relatórios * completos sobre o desempenho do sistema. */typedef struct {    char title[EMU_PERF_MAX_NAME_LEN];       /**< Título do relatório */    time_t timestamp;                        /**< Timestamp de criação */    int32_t num_counters;                        /**< Número de contadores */    emu_perf_counter_t **counters;           /**< Lista de contadores */    char *summary;                           /**< Resumo textual */    void *user_data;                         /**< Dados definidos pelo usuário */} emu_perf_report_t;/** * @defgroup PerfCore API Principal * @brief Funções principais do sistema de performance * @{ *//** * @brief Inicializa o sistema de performance * @return Código de erro (EMU_ERROR_NONE se sucesso) */int32_t emu_perf_init(void);/** * @brief Finaliza o sistema de performance e libera recursos */void emu_perf_shutdown(void);/** * @brief Cria um novo contador do tipo timer * @param name Nome identificador para o contador * @param category Categoria do contador * @return ID do contador criado, ou valor negativo em caso de erro */int32_t emu_perf_create_timer(const char *name, emu_perf_category_t category);/** * @brief Cria um novo contador incremental * @param name Nome identificador para o contador * @param category Categoria do contador * @return ID do contador criado, ou valor negativo em caso de erro */int32_t emu_perf_create_counter(const char *name, emu_perf_category_t category);/** * @brief Cria um novo contador de valor arbitrário * @param name Nome identificador para o contador * @param category Categoria do contador * @return ID do contador criado, ou valor negativo em caso de erro */int32_t emu_perf_create_value(const char *name, emu_perf_category_t category);/** * @brief Cria um novo rastreador de memória * @param name Nome identificador para o contador * @return ID do contador criado, ou valor negativo em caso de erro */int32_t emu_perf_create_memory_tracker(const char *name);/** * @brief Cria um novo rastreador de tempo de frame * @param name Nome identificador para o contador * @return ID do contador criado, ou valor negativo em caso de erro */int32_t emu_perf_create_frametime_tracker(const char *name);/** * @brief Cria um novo contador de tipo personalizado * @param name Nome identificador para o contador * @param category Categoria do contador * @param data Dados personalizados * @param data_size Tamanho dos dados * @return ID do contador criado, ou valor negativo em caso de erro */int32_t emu_perf_create_custom(const char *name, emu_perf_category_t category, void *data, size_t data_size);/** * @brief Destrói um contador e libera seus recursos * @param counter_id ID do contador a ser destruído */void emu_perf_destroy_counter(int32_t counter_id);/** @} *//** * @defgroup PerfTimer API de Timer * @brief Funções para contadores do tipo timer * @{ *//** * @brief Inicia um timer * @param counter_id ID do contador */void emu_perf_timer_start(int32_t counter_id);/** * @brief Para um timer e registra o tempo decorrido * @param counter_id ID do contador */void emu_perf_timer_stop(int32_t counter_id);/** * @brief Marca um lap/volta no timer sem pará-lo * @param counter_id ID do contador */void emu_perf_timer_lap(int32_t counter_id);/** * @brief Zera um timer * @param counter_id ID do contador */void emu_perf_timer_reset(int32_t counter_id);/** * @brief Obtém o tempo decorrido de um timer em ns * @param counter_id ID do contador * @return Tempo decorrido em nanosegundos */uint64_t emu_perf_timer_get_elapsed(int32_t counter_id);/** @} *//** * @defgroup PerfCounter API de Contador * @brief Funções para contadores incrementais * @{ *//** * @brief Incrementa um contador em 1 * @param counter_id ID do contador */void emu_perf_counter_increment(int32_t counter_id);/** * @brief Adiciona um valor a um contador * @param counter_id ID do contador * @param value Valor a ser adicionado */void emu_perf_counter_add(int32_t counter_id, uint64_t value);/** * @brief Define o valor de um contador * @param counter_id ID do contador * @param value Novo valor */void emu_perf_counter_set(int32_t counter_id, uint64_t value);/** * @brief Zera um contador * @param counter_id ID do contador */void emu_perf_counter_reset(int32_t counter_id);/** * @brief Obtém o valor atual de um contador * @param counter_id ID do contador * @return Valor atual */uint64_t emu_perf_counter_get(int32_t counter_id);/** @} *//** * @defgroup PerfValue API de Valor * @brief Funções para contadores de valor arbitrário * @{ *//** * @brief Define o valor de um contador de valor * @param counter_id ID do contador * @param value Novo valor */void emu_perf_value_set(int32_t counter_id, double value);/** * @brief Zera um contador de valor * @param counter_id ID do contador */void emu_perf_value_reset(int32_t counter_id);/** * @brief Obtém o valor atual de um contador de valor * @param counter_id ID do contador * @return Valor atual */double emu_perf_value_get(int32_t counter_id);/** @} *//** * @defgroup PerfMemory API de Memória * @brief Funções para rastreamento de memória * @{ *//** * @brief Registra uma alocação de memória * @param counter_id ID do contador * @param size Tamanho alocado em bytes */void emu_perf_memory_alloc(int32_t counter_id, size_t size);/** * @brief Registra uma liberação de memória * @param counter_id ID do contador * @param size Tamanho liberado em bytes */void emu_perf_memory_free(int32_t counter_id, size_t size);/** * @brief Zera as estatísticas de memória * @param counter_id ID do contador */void emu_perf_memory_reset(int32_t counter_id);/** * @brief Obtém o uso atual de memória * @param counter_id ID do contador * @return Uso atual em bytes */size_t emu_perf_memory_get_current(int32_t counter_id);/** * @brief Obtém o pico de uso de memória * @param counter_id ID do contador * @return Pico de uso em bytes */size_t emu_perf_memory_get_peak(int32_t counter_id);/** @} *//** * @defgroup PerfFrametime API de Frametime * @brief Funções para tempo de frame/FPS * @{ *//** * @brief Marca o fim de um frame * @param counter_id ID do contador */void emu_perf_frametime_mark(int32_t counter_id);/** * @brief Obtém o FPS atual * @param counter_id ID do contador * @return FPS atual */float emu_perf_frametime_get_fps(int32_t counter_id);/** * @brief Obtém o tempo do último frame em ms * @param counter_id ID do contador * @return Tempo em milissegundos */uint64_t emu_perf_frametime_get_ms(int32_t counter_id);/** @} *//** * @defgroup PerfControl API de Controle * @brief Funções para busca e controle de contadores * @{ *//** * @brief Obtém um ponteiro para um contador * @param counter_id ID do contador * @return Ponteiro para o contador, ou NULL se não encontrado */emu_perf_counter_t *emu_perf_get_counter(int32_t counter_id);/** * @brief Encontra um contador pelo nome * @param name Nome do contador * @return ID do contador, ou valor negativo se não encontrado */int32_t emu_perf_find_counter(const char *name);/** * @brief Habilita um contador * @param counter_id ID do contador */void emu_perf_enable_counter(int32_t counter_id);/** * @brief Desabilita um contador * @param counter_id ID do contador */void emu_perf_disable_counter(int32_t counter_id);/** * @brief Verifica se um contador está habilitado * @param counter_id ID do contador * @return true se habilitado, false caso contrário */bool emu_perf_is_counter_enabled(int32_t counter_id);/** @} *//** * @defgroup PerfReport API de Relatório * @brief Funções para relatórios de performance * @{ *//** * @brief Cria um novo relatório * @param title Título do relatório * @return Ponteiro para o relatório, ou NULL em caso de erro */emu_perf_report_t *emu_perf_create_report(const char *title);/** * @brief Destrói um relatório e libera recursos * @param report Ponteiro para o relatório */void emu_perf_destroy_report(emu_perf_report_t *report);/** * @brief Adiciona um contador a um relatório * @param report Ponteiro para o relatório * @param counter_id ID do contador a adicionar * @return Código de erro (EMU_ERROR_NONE se sucesso) */int32_t emu_perf_add_counter_to_report(emu_perf_report_t *report, int32_t counter_id);/** * @brief Converte um relatório para string formatada * @param report Ponteiro para o relatório * @return String formatada (deve ser liberada pelo chamador), ou NULL em caso de erro */char *emu_perf_report_to_string(emu_perf_report_t *report);/** * @brief Salva um relatório em um arquivo de texto * @param report Ponteiro para o relatório * @param filename Nome do arquivo * @return Código de erro (EMU_ERROR_NONE se sucesso) */int32_t emu_perf_save_report_to_file(emu_perf_report_t *report, const char *filename);/** * @brief Salva um relatório em formato JSON * @param report Ponteiro para o relatório * @param filename Nome do arquivo * @return Código de erro (EMU_ERROR_NONE se sucesso) */int32_t emu_perf_save_report_to_json(emu_perf_report_t *report, const char *filename);/** @} *//** * @defgroup PerfBenchmark API de Benchmark * @brief Funções para benchmarks * @{ *//** * @brief Executa um benchmark * @param name Nome do benchmark * @param num_iterations Número de iterações * @param benchmark_func Função a ser executada * @param user_data Dados para a função * @return Código de erro (EMU_ERROR_NONE se sucesso) */int32_t emu_perf_run_benchmark(const char *name, int32_t num_iterations, void (*benchmark_func)(void *), void *user_data);/** * @brief Compara dois benchmarks * @param benchmark1 Nome do primeiro benchmark * @param benchmark2 Nome do segundo benchmark * @return Diferença em porcentagem (positivo se benchmark1 é mais rápido) */int32_t emu_perf_compare_benchmarks(const char *benchmark1, const char *benchmark2);/** @} *//** * @defgroup PerfUtils API de Utilitários * @brief Funções utilitárias * @{ *//** * @brief Zera todos os contadores */void emu_perf_reset_all_counters(void);/** * @brief Habilita todos os contadores */void emu_perf_enable_all_counters(void);/** * @brief Desabilita todos os contadores */void emu_perf_disable_all_counters(void);/** * @brief Obtém o tempo atual em milissegundos * @return Tempo em ms desde uma referência arbitrária */double emu_perf_get_time_ms(void);/** * @brief Obtém o tempo atual em nanosegundos * @return Tempo em ns desde uma referência arbitrária */uint64_t emu_perf_get_time_ns(void);/** @} */#endif /* EMU_PERFORMANCE_H */