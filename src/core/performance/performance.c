/** * @file performance.c * @brief Implementação do sistema de otimização de performance */#include "performance.h"#include "utils/enhanced_log.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>// Número máximo de métricas que podem ser registradas#define PERF_MAX_METRICS 32// Número máximo de snapshots simultâneos#define PERF_MAX_SNAPSHOTS 16// Estrutura para estatísticas de save statetypedef struct{    // Operações de salvamento    int save_count;    int save_total_time_us;    int save_min_time_us;    int save_max_time_us;    size_t save_total_size;    // Operações de carregamento    int load_count;    int load_total_time_us;    int load_min_time_us;    int load_max_time_us;    size_t load_total_size;} perf_savestate_stats_t;// Estrutura do contexto de performancestruct performance_t{    perf_config_t config;    // Métricas registradas    perf_metric_t metrics[PERF_MAX_METRICS];    int num_metrics;    // Snapshots ativos    perf_snapshot_t snapshots[PERF_MAX_SNAPSHOTS];    bool snapshot_active[PERF_MAX_SNAPSHOTS];    int num_snapshots;    // Estatísticas específicas para operações de save state    perf_savestate_stats_t savestate_stats;    // Callback de aviso    void (*warning_callback)(perf_metric_type_t type, float value, void *user_data);    float warning_threshold;    void *warning_user_data;    // Estado de inicialização    bool initialized;    // Timestamp da última coleta    uint64_t last_collect_time;};// Funções estáticasstatic void performance_collect_metrics(performance_t *perf);static int performance_find_metric_index(performance_t *perf, perf_metric_type_t type, const char *name);static int performance_find_available_snapshot(performance_t *perf);static void performance_check_warnings(performance_t *perf, int metric_id);/** * @brief Inicializa o sistema de performance */performance_t *performance_init(const perf_config_t *config){    // Aloca estrutura    performance_t *perf = (performance_t *)malloc(sizeof(performance_t));    if (!perf)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Falha ao alocar contexto");        return NULL;    }    // Inicializa estrutura    memset(perf, 0, sizeof(performance_t));    // Define configuração padrão    if (config)    {        memcpy(&perf->config, config, sizeof(perf_config_t));    }    else    {        // Valores padrão        perf->config.enabled = 1;        perf->config.log_level = EMU_LOG_LEVEL_INFO;        perf->config.collect_interval = 1000; // 1 segundo        perf->config.output_file = NULL;    }    // Inicializa estatísticas de save state    perf->savestate_stats.save_min_time_us = INT_MAX;    perf->savestate_stats.load_min_time_us = INT_MAX;    // Marca como inicializado    perf->initialized = true;    // Registra timestamp inicial    perf->last_collect_time = performance_get_time_ns();    LOG_INFO(EMU_LOG_CAT_SYSTEM, "Performance: Sistema inicializado");    return perf;}/** * @brief Finaliza o sistema de performance e libera recursos */void performance_shutdown(performance_t *perf){    if (!perf)        return;    // Gera relatório final, se configurado    if (perf->config.output_file)    {        performance_generate_report(perf, perf->config.output_file);    }    LOG_INFO(EMU_LOG_CAT_SYSTEM, "Performance: Sistema finalizado");    // Libera estrutura    free(perf);}/** * @brief Registra uma métrica para monitoramento */int performance_register_metric(    performance_t *perf,    perf_metric_type_t type,    const char *name){    if (!perf || !perf->initialized)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Sistema não inicializado");        return PERF_ERROR_NOT_INITIALIZED;    }    // Verifica se já existe uma métrica do mesmo tipo    if (type != PERF_METRIC_CUSTOM)    {        for (int i = 0; i < perf->num_metrics; i++)        {            if (perf->metrics[i].type == type)            {                LOG_WARN(EMU_LOG_CAT_SYSTEM, "Performance: Métrica de tipo %d já registrada", type);                return i; // Retorna o índice da métrica existente            }        }    }    else if (name)    {        // Para métricas personalizadas, verifica pelo nome        for (int i = 0; i < perf->num_metrics; i++)        {            if (perf->metrics[i].type == PERF_METRIC_CUSTOM &&                strcmp(perf->metrics[i].name, name) == 0)            {                LOG_WARN(EMU_LOG_CAT_SYSTEM, "Performance: Métrica personalizada '%s' já registrada", name);                return i; // Retorna o índice da métrica existente            }        }    }    // Verifica se há espaço para mais uma métrica    if (perf->num_metrics >= PERF_MAX_METRICS)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Número máximo de métricas atingido");        return PERF_ERROR_INVALID_PARAMETER;    }    // Registra a métrica    int index = perf->num_metrics++;    perf_metric_t *metric = &perf->metrics[index];    metric->type = type;    metric->current_value = 0;    metric->min_value = FLT_MAX;    metric->max_value = -FLT_MAX;    metric->avg_value = 0;    metric->sample_count = 0;    // Define o nome da métrica    if (type == PERF_METRIC_CUSTOM)    {        if (!name)        {            LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Nome obrigatório para métrica personalizada");            perf->num_metrics--; // Desfaz o registro            return PERF_ERROR_INVALID_PARAMETER;        }        strncpy(metric->name, name, sizeof(metric->name) - 1);    }    else    {        // Nomes padrão para métricas conhecidas        const char *default_names[] = {            "CPU Usage",            "Memory Usage",            "Frame Time",            "FPS",            "SaveState Time"};        if (type < sizeof(default_names) / sizeof(default_names[0]))        {            strncpy(metric->name, default_names[type], sizeof(metric->name) - 1);        }        else        {            snprintf(metric->name, sizeof(metric->name), "Metric %d", type);        }    }    LOG_INFO(EMU_LOG_CAT_SYSTEM, "Performance: Métrica '%s' registrada com ID %d",             metric->name, index);    return index;}/** * @brief Atualiza o valor de uma métrica */int performance_update_metric(    performance_t *perf,    int metric_id,    float value){    if (!perf || !perf->initialized)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Sistema não inicializado");        return PERF_ERROR_NOT_INITIALIZED;    }    // Verifica se o ID da métrica é válido    if (metric_id < 0 || metric_id >= perf->num_metrics)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: ID de métrica inválido: %d", metric_id);        return PERF_ERROR_INVALID_PARAMETER;    }    // Atualiza a métrica    perf_metric_t *metric = &perf->metrics[metric_id];    metric->current_value = value;    metric->min_value = (value < metric->min_value) ? value : metric->min_value;    metric->max_value = (value > metric->max_value) ? value : metric->max_value;    // Atualiza média móvel    if (metric->sample_count == 0)    {        metric->avg_value = value;    }    else    {        // Média móvel exponencial (alpha = 0.1)        metric->avg_value = 0.9f * metric->avg_value + 0.1f * value;    }    metric->sample_count++;    // Verifica se deve notificar sobre problemas de performance    performance_check_warnings(perf, metric_id);    LOG_DEBUG(EMU_LOG_CAT_SYSTEM, "Performance: Métrica '%s' atualizada para %.2f",              metric->name, value);    return PERF_ERROR_NONE;}/** * @brief Obtém uma métrica */int performance_get_metric(    performance_t *perf,    int metric_id,    perf_metric_t *metric){    if (!perf || !perf->initialized || !metric)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Parâmetros inválidos");        return PERF_ERROR_INVALID_PARAMETER;    }    // Verifica se o ID da métrica é válido    if (metric_id < 0 || metric_id >= perf->num_metrics)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: ID de métrica inválido: %d", metric_id);        return PERF_ERROR_INVALID_PARAMETER;    }    // Copia os dados da métrica    memcpy(metric, &perf->metrics[metric_id], sizeof(perf_metric_t));    return PERF_ERROR_NONE;}/** * @brief Inicia um snapshot para medir o tempo de execução */int performance_start_snapshot(    performance_t *perf,    const char *name){    if (!perf || !perf->initialized)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Sistema não inicializado");        return PERF_ERROR_NOT_INITIALIZED;    }    // Procura um slot disponível para o snapshot    int index = performance_find_available_snapshot(perf);    if (index < 0)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Número máximo de snapshots atingido");        return PERF_ERROR_INVALID_PARAMETER;    }    // Registra o snapshot    perf_snapshot_t *snapshot = &perf->snapshots[index];    snapshot->name = name ? name : "Unnamed";    snapshot->start_time = performance_get_time_ns();    snapshot->end_time = 0;    perf->snapshot_active[index] = true;    LOG_DEBUG(EMU_LOG_CAT_SYSTEM, "Performance: Snapshot '%s' iniciado", snapshot->name);    return index;}/** * @brief Finaliza um snapshot e calcula o tempo decorrido */int performance_end_snapshot(    performance_t *perf,    int snapshot_id){    if (!perf || !perf->initialized)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Sistema não inicializado");        return PERF_ERROR_NOT_INITIALIZED;    }    // Verifica se o ID do snapshot é válido    if (snapshot_id < 0 || snapshot_id >= PERF_MAX_SNAPSHOTS || !perf->snapshot_active[snapshot_id])    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: ID de snapshot inválido: %d", snapshot_id);        return PERF_ERROR_INVALID_PARAMETER;    }    // Finaliza o snapshot    perf_snapshot_t *snapshot = &perf->snapshots[snapshot_id];    snapshot->end_time = performance_get_time_ns();    // Calcula o tempo decorrido em microssegundos    uint64_t elapsed_ns = snapshot->end_time - snapshot->start_time;    int elapsed_us = (int)(elapsed_ns / 1000);    LOG_DEBUG(EMU_LOG_CAT_SYSTEM, "Performance: Snapshot '%s' finalizado: %d µs",              snapshot->name, elapsed_us);    // Marca o snapshot como disponível    perf->snapshot_active[snapshot_id] = false;    return elapsed_us;}/** * @brief Obtém o tempo decorrido para um snapshot */int performance_get_snapshot_time(    performance_t *perf,    int snapshot_id){    if (!perf || !perf->initialized)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Sistema não inicializado");        return PERF_ERROR_NOT_INITIALIZED;    }    // Verifica se o ID do snapshot é válido    if (snapshot_id < 0 || snapshot_id >= PERF_MAX_SNAPSHOTS)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: ID de snapshot inválido: %d", snapshot_id);        return PERF_ERROR_INVALID_PARAMETER;    }    perf_snapshot_t *snapshot = &perf->snapshots[snapshot_id];    // Verifica se o snapshot está finalizado    if (snapshot->end_time == 0)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Snapshot não finalizado: %d", snapshot_id);        return PERF_ERROR_INVALID_PARAMETER;    }    // Calcula o tempo decorrido em microssegundos    uint64_t elapsed_ns = snapshot->end_time - snapshot->start_time;    int elapsed_us = (int)(elapsed_ns / 1000);    return elapsed_us;}/** * @brief Registra o tempo de uma operação de save state */int performance_record_savestate_operation(    performance_t *perf,    bool is_save,    size_t size_bytes,    int time_us){    if (!perf || !perf->initialized)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Sistema não inicializado");        return PERF_ERROR_NOT_INITIALIZED;    }    if (time_us <= 0)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Tempo inválido: %d µs", time_us);        return PERF_ERROR_INVALID_PARAMETER;    }    // Atualiza estatísticas    if (is_save)    {        // Operação de salvamento        perf->savestate_stats.save_count++;        perf->savestate_stats.save_total_time_us += time_us;        perf->savestate_stats.save_total_size += size_bytes;        if (time_us < perf->savestate_stats.save_min_time_us)            perf->savestate_stats.save_min_time_us = time_us;        if (time_us > perf->savestate_stats.save_max_time_us)            perf->savestate_stats.save_max_time_us = time_us;        LOG_INFO(EMU_LOG_CAT_SYSTEM, "Performance: Save state (%zu bytes) em %d µs (%.2f MB/s)",                 size_bytes, time_us, (float)size_bytes / time_us);    }    else    {        // Operação de carregamento        perf->savestate_stats.load_count++;        perf->savestate_stats.load_total_time_us += time_us;        perf->savestate_stats.load_total_size += size_bytes;        if (time_us < perf->savestate_stats.load_min_time_us)            perf->savestate_stats.load_min_time_us = time_us;        if (time_us > perf->savestate_stats.load_max_time_us)            perf->savestate_stats.load_max_time_us = time_us;        LOG_INFO(EMU_LOG_CAT_SYSTEM, "Performance: Load state (%zu bytes) em %d µs (%.2f MB/s)",                 size_bytes, time_us, (float)size_bytes / time_us);    }    // Registra ou atualiza a métrica de save state    int metric_id = performance_find_metric_index(perf, PERF_METRIC_SAVESTATE_TIME, NULL);    if (metric_id < 0)    {        // Registra uma nova métrica        metric_id = performance_register_metric(perf, PERF_METRIC_SAVESTATE_TIME, NULL);        if (metric_id < 0)            return PERF_ERROR_INVALID_PARAMETER;    }    // Atualiza a métrica com o tempo atual    performance_update_metric(perf, metric_id, (float)time_us);    return PERF_ERROR_NONE;}/** * @brief Gera um relatório de performance */int performance_generate_report(    performance_t *perf,    const char *filename){    if (!perf || !perf->initialized)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Sistema não inicializado");        return PERF_ERROR_NOT_INITIALIZED;    }    // Se nenhum arquivo for especificado, apenas loga as informações    if (!filename)    {        LOG_INFO(EMU_LOG_CAT_SYSTEM, "=== Relatório de Performance ===");        // Métricas gerais        for (int i = 0; i < perf->num_metrics; i++)        {            perf_metric_t *metric = &perf->metrics[i];            LOG_INFO(EMU_LOG_CAT_SYSTEM, "Métrica: %s", metric->name);            LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Atual: %.2f", metric->current_value);            LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Média: %.2f", metric->avg_value);            LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Mínimo: %.2f", metric->min_value);            LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Máximo: %.2f", metric->max_value);            LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Amostras: %d", metric->sample_count);        }        // Estatísticas de save state        if (perf->savestate_stats.save_count > 0 || perf->savestate_stats.load_count > 0)        {            LOG_INFO(EMU_LOG_CAT_SYSTEM, "=== Estatísticas de Save State ===");            // Operações de salvamento            if (perf->savestate_stats.save_count > 0)            {                int avg_time = perf->savestate_stats.save_total_time_us / perf->savestate_stats.save_count;                float avg_size = (float)perf->savestate_stats.save_total_size / perf->savestate_stats.save_count;                float avg_speed = (float)perf->savestate_stats.save_total_size / perf->savestate_stats.save_total_time_us;                LOG_INFO(EMU_LOG_CAT_SYSTEM, "Save: %d operações", perf->savestate_stats.save_count);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Tempo médio: %d µs", avg_time);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Tempo mínimo: %d µs", perf->savestate_stats.save_min_time_us);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Tempo máximo: %d µs", perf->savestate_stats.save_max_time_us);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Tamanho médio: %.2f KB", avg_size / 1024);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Velocidade média: %.2f MB/s", avg_speed);            }            // Operações de carregamento            if (perf->savestate_stats.load_count > 0)            {                int avg_time = perf->savestate_stats.load_total_time_us / perf->savestate_stats.load_count;                float avg_size = (float)perf->savestate_stats.load_total_size / perf->savestate_stats.load_count;                float avg_speed = (float)perf->savestate_stats.load_total_size / perf->savestate_stats.load_total_time_us;                LOG_INFO(EMU_LOG_CAT_SYSTEM, "Load: %d operações", perf->savestate_stats.load_count);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Tempo médio: %d µs", avg_time);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Tempo mínimo: %d µs", perf->savestate_stats.load_min_time_us);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Tempo máximo: %d µs", perf->savestate_stats.load_max_time_us);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Tamanho médio: %.2f KB", avg_size / 1024);                LOG_INFO(EMU_LOG_CAT_SYSTEM, "  Velocidade média: %.2f MB/s", avg_speed);            }        }        return PERF_ERROR_NONE;    }    // Abre o arquivo para escrita    FILE *file = fopen(filename, "w");    if (!file)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Falha ao abrir arquivo: %s", filename);        return PERF_ERROR_INVALID_PARAMETER;    }    // Escreve cabeçalho    fprintf(file, "# Relatório de Performance\n");    fprintf(file, "# Gerado em: %s\n\n", ctime(NULL));    // Métricas gerais    fprintf(file, "## Métricas\n\n");    fprintf(file, "| Métrica | Atual | Média | Mínimo | Máximo | Amostras |\n");    fprintf(file, "|---------|-------|-------|--------|--------|----------|\n");    for (int i = 0; i < perf->num_metrics; i++)    {        perf_metric_t *metric = &perf->metrics[i];        fprintf(file, "| %s | %.2f | %.2f | %.2f | %.2f | %d |\n",                metric->name, metric->current_value, metric->avg_value,                metric->min_value, metric->max_value, metric->sample_count);    }    // Estatísticas de save state    if (perf->savestate_stats.save_count > 0 || perf->savestate_stats.load_count > 0)    {        fprintf(file, "\n## Estatísticas de Save State\n\n");        // Operações de salvamento        if (perf->savestate_stats.save_count > 0)        {            int avg_time = perf->savestate_stats.save_total_time_us / perf->savestate_stats.save_count;            float avg_size = (float)perf->savestate_stats.save_total_size / perf->savestate_stats.save_count;            float avg_speed = (float)perf->savestate_stats.save_total_size / perf->savestate_stats.save_total_time_us;            fprintf(file, "### Operações de Salvamento\n\n");            fprintf(file, "- Número de operações: %d\n", perf->savestate_stats.save_count);            fprintf(file, "- Tempo médio: %d µs\n", avg_time);            fprintf(file, "- Tempo mínimo: %d µs\n", perf->savestate_stats.save_min_time_us);            fprintf(file, "- Tempo máximo: %d µs\n", perf->savestate_stats.save_max_time_us);            fprintf(file, "- Tamanho médio: %.2f KB\n", avg_size / 1024);            fprintf(file, "- Velocidade média: %.2f MB/s\n", avg_speed);        }        // Operações de carregamento        if (perf->savestate_stats.load_count > 0)        {            int avg_time = perf->savestate_stats.load_total_time_us / perf->savestate_stats.load_count;            float avg_size = (float)perf->savestate_stats.load_total_size / perf->savestate_stats.load_count;            float avg_speed = (float)perf->savestate_stats.load_total_size / perf->savestate_stats.load_total_time_us;            fprintf(file, "\n### Operações de Carregamento\n\n");            fprintf(file, "- Número de operações: %d\n", perf->savestate_stats.load_count);            fprintf(file, "- Tempo médio: %d µs\n", avg_time);            fprintf(file, "- Tempo mínimo: %d µs\n", perf->savestate_stats.load_min_time_us);            fprintf(file, "- Tempo máximo: %d µs\n", perf->savestate_stats.load_max_time_us);            fprintf(file, "- Tamanho médio: %.2f KB\n", avg_size / 1024);            fprintf(file, "- Velocidade média: %.2f MB/s\n", avg_speed);        }    }    fclose(file);    LOG_INFO(EMU_LOG_CAT_SYSTEM, "Performance: Relatório salvo em %s", filename);    return PERF_ERROR_NONE;}/** * @brief Define uma função de callback para notificar problemas de performance */void performance_set_warning_callback(    performance_t *perf,    void (*callback)(perf_metric_type_t type, float value, void *user_data),    float threshold,    void *user_data){    if (!perf || !perf->initialized)    {        LOG_ERROR(EMU_LOG_CAT_SYSTEM, "Performance: Sistema não inicializado");        return;    }    perf->warning_callback = callback;    perf->warning_threshold = threshold;    perf->warning_user_data = user_data;    LOG_INFO(EMU_LOG_CAT_SYSTEM, "Performance: Callback de aviso configurado com limiar %.2f", threshold);}/** * @brief Função utilitária para obter o tempo atual em nanossegundos */uint64_t performance_get_time_ns(void){    struct timespec ts;#ifdef _WIN32    // Em Windows, usa QueryPerformanceCounter    LARGE_INTEGER counter, frequency;    QueryPerformanceCounter(&counter);    QueryPerformanceFrequency(&frequency);    // Converte para nanossegundos    return (uint64_t)(counter.QuadPart * 1e9 / frequency.QuadPart);#else    // Em sistemas compatíveis com POSIX, usa clock_gettime    clock_gettime(CLOCK_MONOTONIC, &ts);    return (uint64_t)ts.tv_sec * 1000000000ULL + (uint64_t)ts.tv_nsec;#endif}/** * @brief Coleta métricas do sistema */static void performance_collect_metrics(performance_t *perf){    if (!perf || !perf->initialized || !perf->config.enabled)        return;    // Verifica se é hora de coletar métricas    uint64_t now = performance_get_time_ns();    uint64_t elapsed_ms = (now - perf->last_collect_time) / 1000000ULL;    if (perf->config.collect_interval > 0 && elapsed_ms < (uint64_t)perf->config.collect_interval)        return;    // Atualiza timestamp    perf->last_collect_time = now;    // Coleta métricas do sistema    // Na implementação real, isso envolveria obter dados do sistema operacional    // ou do hardware para métricas como CPU e memória    // Exemplo: coleta de FPS    int fps_metric = performance_find_metric_index(perf, PERF_METRIC_FPS, NULL);    if (fps_metric >= 0)    {        // Calcula FPS baseado no tempo decorrido        float fps = 1000.0f / elapsed_ms; // Aproximado        performance_update_metric(perf, fps_metric, fps);    }}/** * @brief Encontra o índice de uma métrica pelo tipo ou nome */static int performance_find_metric_index(performance_t *perf, perf_metric_type_t type, const char *name){    if (!perf || !perf->initialized)        return -1;    for (int i = 0; i < perf->num_metrics; i++)    {        if (type != PERF_METRIC_CUSTOM)        {            if (perf->metrics[i].type == type)                return i;        }        else if (name)        {            if (perf->metrics[i].type == PERF_METRIC_CUSTOM &&                strcmp(perf->metrics[i].name, name) == 0)                return i;        }    }    return -1;}/** * @brief Encontra um slot disponível para um novo snapshot */static int performance_find_available_snapshot(performance_t *perf){    if (!perf || !perf->initialized)        return -1;    // Procura um slot não ativo    for (int i = 0; i < PERF_MAX_SNAPSHOTS; i++)    {        if (!perf->snapshot_active[i])            return i;    }    return -1;}/** * @brief Verifica se uma métrica está acima do limiar de aviso */static void performance_check_warnings(performance_t *perf, int metric_id){    if (!perf || !perf->initialized || !perf->warning_callback)        return;    if (metric_id < 0 || metric_id >= perf->num_metrics)        return;    perf_metric_t *metric = &perf->metrics[metric_id];    // Verifica se está acima do limiar    // A lógica exata depende do tipo de métrica    bool above_threshold = false;    switch (metric->type)    {    case PERF_METRIC_CPU_USAGE:    case PERF_METRIC_MEMORY_USAGE:        // Para uso de CPU ou memória, verifica se está acima do limiar        above_threshold = (metric->current_value > perf->warning_threshold);        break;    case PERF_METRIC_FRAME_TIME:        // Para tempo de frame, verifica se está acima do limiar (mais lento)        above_threshold = (metric->current_value > perf->warning_threshold);        break;    case PERF_METRIC_FPS:        // Para FPS, verifica se está abaixo do limiar (mais baixo)        above_threshold = (metric->current_value < perf->warning_threshold);        break;    case PERF_METRIC_SAVESTATE_TIME:        // Para tempo de save state, verifica se está acima do limiar (mais lento)        above_threshold = (metric->current_value > perf->warning_threshold);        break;    case PERF_METRIC_CUSTOM:        // Para métricas personalizadas, assume limiar superior        above_threshold = (metric->current_value > perf->warning_threshold);        break;    }    // Se está acima do limiar, chama o callback    if (above_threshold)    {        LOG_WARN(EMU_LOG_CAT_SYSTEM, "Performance: Métrica '%s' acima do limiar: %.2f",                 metric->name, metric->current_value);        perf->warning_callback(metric->type, metric->current_value, perf->warning_user_data);    }}