#include "input_interface.h"#include "../../utils/error_handling.h"#include "../../utils/enhanced_log.h"#include "../../utils/log_categories.h"#include <stdlib.h>#include <string.h>// Constantes do sistema de entrada#define INPUT_TYPE_NONE 0#define INPUT_TYPE_3BUTTON 1#define INPUT_TYPE_6BUTTON 2// Funções do sistema de entradaemu_input_instance_t *emu_input_create(void){    // Alocar sistema de entrada    emu_input_instance_t *input = (emu_input_instance_t *)malloc(sizeof(emu_input_instance_t));    if (input == NULL)    {        emu_error_set(EMU_ERROR_NULL_POINTER, "Falha ao alocar sistema de entrada", __FILE__, __LINE__);        return NULL;    }    // Inicializar campos    memset(input, 0, sizeof(emu_input_instance_t));    input->num_controllers = 2; // Padrão: 2 controles    // Alocar memória para botões e eixos    input->buttons = (uint8_t *)malloc(INPUT_MAX_BUTTONS * sizeof(uint8_t));    input->axes = (int8_t *)malloc(INPUT_MAX_BUTTONS * sizeof(int8_t));    if (!input->buttons || !input->axes)    {        emu_error_set(EMU_ERROR_OUT_OF_MEMORY, "Falha ao alocar memória para botões/eixos", __FILE__, __LINE__);        if (input->buttons)            free(input->buttons);        if (input->axes)            free(input->axes);        free(input);        return NULL;    }    // Inicializar controles    for (int i = 0; i < INPUT_MAX_CONTROLLERS; i++)    {        input->controllers[i].buttons = 0;        input->controllers[i].buttons_prev = 0;        input->controllers[i].connected = (i < 2) ? 1 : 0; // Conectar apenas os 2 primeiros        input->controllers[i].type = INPUT_TYPE_3BUTTON;    }    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Criado sistema de entrada");    return input;}void emu_input_destroy(emu_input_instance_t *input){    if (!input)    {        return;    }    // Liberar memória alocada    if (input->buttons)    {        free(input->buttons);    }    if (input->axes)    {        free(input->axes);    }    // Liberar sistema de entrada    free(input);    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Destruído sistema de entrada");}int emu_input_init(emu_input_instance_t *input){    EMU_CHECK_NULL(input, "Ponteiro de entrada inválido");    memset(input, 0, sizeof(emu_input_instance_t));    input->initialized = true;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Sistema de entrada inicializado");    return 0;}void emu_input_shutdown(emu_input_instance_t *input){    if (!input)    {        return;    }    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Sistema de entrada desligado");    memset(input, 0, sizeof(emu_input_instance_t));}int emu_input_reset(emu_input_instance_t *input){    EMU_CHECK_NULL(input, "Ponteiro de entrada inválido");    if (!input->initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Sistema de entrada não inicializado");        return -1;    }    // Resetar estado dos botões    memset(input->buttons, 0, sizeof(input->buttons));    memset(input->axes, 0, sizeof(input->axes));    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Sistema de entrada resetado");    return 0;}void emu_input_set_userdata(emu_input_instance_t *input, void *userdata){    if (!input)    {        return;    }    input->userdata = userdata;}void *emu_input_get_userdata(emu_input_instance_t *input){    if (!input)    {        return NULL;    }    return input->userdata;}// Funções de acesso ao sistema de entradavoid emu_input_set_button(emu_input_instance_t *input, int controller, input_button_t button, int pressed){    if (!input || controller < 0 || controller >= INPUT_MAX_CONTROLLERS || button < 0 || button >= INPUT_MAX_BUTTONS)    {        return;    }    // Verificar se o controle está conectado    if (!input->controllers[controller].connected)    {        return;    }    // Atualizar estado do botão    if (pressed)    {        input->controllers[controller].buttons |= (1 << button);    }    else    {        input->controllers[controller].buttons &= ~(1 << button);    }}int emu_input_get_button(emu_input_instance_t *input, int controller, input_button_t button){    if (!input || controller < 0 || controller >= INPUT_MAX_CONTROLLERS || button < 0 || button >= INPUT_MAX_BUTTONS)    {        return 0;    }    // Verificar se o controle está conectado    if (!input->controllers[controller].connected)    {        return 0;    }    return (input->controllers[controller].buttons & (1 << button)) ? 1 : 0;}int emu_input_get_button_pressed(emu_input_instance_t *input, int controller, input_button_t button){    if (!input || controller < 0 || controller >= INPUT_MAX_CONTROLLERS || button < 0 || button >= INPUT_MAX_BUTTONS)    {        return 0;    }    // Verificar se o controle está conectado    if (!input->controllers[controller].connected)    {        return 0;    }    // Verificar se o botão foi pressionado neste frame    return ((input->controllers[controller].buttons & (1 << button)) &&            !(input->controllers[controller].buttons_prev & (1 << button)))               ? 1               : 0;}int emu_input_get_button_released(emu_input_instance_t *input, int controller, input_button_t button){    if (!input || controller < 0 || controller >= INPUT_MAX_CONTROLLERS || button < 0 || button >= INPUT_MAX_BUTTONS)    {        return 0;    }    // Verificar se o controle está conectado    if (!input->controllers[controller].connected)    {        return 0;    }    // Verificar se o botão foi liberado neste frame    return (!(input->controllers[controller].buttons & (1 << button)) &&            (input->controllers[controller].buttons_prev & (1 << button)))               ? 1               : 0;}void emu_input_set_controller_connected(emu_input_instance_t *input, int controller, int connected){    if (!input || controller < 0 || controller >= INPUT_MAX_CONTROLLERS)    {        return;    }    input->controllers[controller].connected = connected ? 1 : 0;}int emu_input_get_controller_connected(emu_input_instance_t *input, int controller){    if (!input || controller < 0 || controller >= INPUT_MAX_CONTROLLERS)    {        return 0;    }    return input->controllers[controller].connected;}void emu_input_set_controller_type(emu_input_instance_t *input, int controller, int type){    if (!input || controller < 0 || controller >= INPUT_MAX_CONTROLLERS)    {        return;    }    input->controllers[controller].type = type;}int emu_input_get_controller_type(emu_input_instance_t *input, int controller){    if (!input || controller < 0 || controller >= INPUT_MAX_CONTROLLERS)    {        return INPUT_TYPE_NONE;    }    return input->controllers[controller].type;}int emu_input_update(emu_input_instance_t *input){    if (!input)    {        return -1;    }    // Atualizar estado anterior dos botões    for (int i = 0; i < INPUT_MAX_CONTROLLERS; i++)    {        input->controllers[i].buttons_prev = input->controllers[i].buttons;    }    return 0;}