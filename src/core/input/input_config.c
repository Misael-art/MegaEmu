/** * @file input_config.c * @brief Implementação para configuração de controles em tempo real */#include "input_config.h"#include "input_config_interface.h"#include "input_config_types.h"#include "../../utils/error_handling.h"#include "../../utils/enhanced_log.h"#include "../../utils/log_categories.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include <math.h>// Definições para teclas especiais#define KEY_F1 0x3b#define KEY_F2 0x3c#define KEY_F3 0x3d#define KEY_F4 0x3e#define KEY_F5 0x3f#define KEY_F6 0x40#define KEY_F7 0x41#define KEY_F8 0x42#define KEY_F9 0x43#define KEY_F10 0x44#define KEY_F11 0x57#define KEY_F12 0x58#define KEY_LSHIFT 0x2a#define KEY_RSHIFT 0x36#define KEY_LCTRL 0x1d#define KEY_RCTRL 0x1d // Mesma tecla, diferenciada pelo código estendido#define KEY_LALT 0x38#define KEY_RALT 0x38 // Mesma tecla, diferenciada pelo código estendido// Modificadores#define MOD_SHIFT 0x01#define MOD_CTRL 0x02#define MOD_ALT 0x04// Definições adicionais para configurações avançadas#define INPUT_MAX_PROFILES 10#define INPUT_MAX_AXES 8#define INPUT_CALIBRATION_SAMPLES 100#define INPUT_PROFILE_FILE_EXTENSION ".input"// Estrutura interna para configuração de entradatypedef struct{    emu_key_mapping_t *mappings;    uint32_t num_mappings;    bool initialized;} input_config_internal_t;static input_config_internal_t *g_config = NULL;emu_input_config_t emu_input_config_create(void){    input_config_internal_t *config = (input_config_internal_t *)malloc(sizeof(input_config_internal_t));    if (!config)    {        EMU_THROW(EMU_ERROR_OUT_OF_MEMORY, "Falha ao alocar configuração de entrada");        return NULL;    }    config->mappings = NULL;    config->num_mappings = 0;    config->initialized = false;    return (emu_input_config_t)config;}void emu_input_config_destroy(emu_input_config_t config){    if (!config)        return;    input_config_internal_t *internal = (input_config_internal_t *)config;    if (internal->mappings)    {        free(internal->mappings);    }    free(internal);}bool emu_input_config_init(emu_input_config_t config){    if (!config)    {        EMU_THROW(EMU_ERROR_NULL_POINTER, "Ponteiro de configuração inválido");        return false;    }    input_config_internal_t *internal = (input_config_internal_t *)config;    if (internal->initialized)    {        EMU_THROW(EMU_ERROR_ALREADY_INITIALIZED, "Configuração já inicializada");        return false;    }    internal->initialized = true;    return true;}bool emu_input_config_add_mapping(emu_input_config_t config, uint8_t key_code, uint8_t button_id){    if (!config)    {        EMU_THROW(EMU_ERROR_NULL_POINTER, "Ponteiro de configuração inválido");        return false;    }    input_config_internal_t *internal = (input_config_internal_t *)config;    if (!internal->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Configuração não inicializada");        return false;    }    // Verificar se o mapeamento já existe    for (uint32_t i = 0; i < internal->num_mappings; i++)    {        if (internal->mappings[i].key_code == key_code)        {            internal->mappings[i].button_id = button_id;            return true;        }    }    // Alocar mais espaço se necessário    emu_key_mapping_t *new_mappings = (emu_key_mapping_t *)realloc(        internal->mappings,        (internal->num_mappings + 1) * sizeof(emu_key_mapping_t));    if (!new_mappings)    {        EMU_THROW(EMU_ERROR_OUT_OF_MEMORY, "Falha ao realocar mapeamentos");        return false;    }    internal->mappings = new_mappings;    internal->mappings[internal->num_mappings].key_code = key_code;    internal->mappings[internal->num_mappings].button_id = button_id;    internal->num_mappings++;    return true;}bool emu_input_config_remove_mapping(emu_input_config_t config, uint8_t key_code){    if (!config)    {        EMU_THROW(EMU_ERROR_NULL_POINTER, "Ponteiro de configuração inválido");        return false;    }    input_config_internal_t *internal = (input_config_internal_t *)config;    if (!internal->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Configuração não inicializada");        return false;    }    for (uint32_t i = 0; i < internal->num_mappings; i++)    {        if (internal->mappings[i].key_code == key_code)        {            if (i < internal->num_mappings - 1)            {                memmove(&internal->mappings[i], &internal->mappings[i + 1],                        (internal->num_mappings - i - 1) * sizeof(emu_key_mapping_t));            }            internal->num_mappings--;            return true;        }    }    return false;}uint8_t emu_input_config_get_button(emu_input_config_t config, uint8_t key_code){    if (!config)    {        EMU_THROW(EMU_ERROR_NULL_POINTER, "Ponteiro de configuração inválido");        return 0;    }    input_config_internal_t *internal = (input_config_internal_t *)config;    if (!internal->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Configuração não inicializada");        return 0;    }    for (uint32_t i = 0; i < internal->num_mappings; i++)    {        if (internal->mappings[i].key_code == key_code)        {            return internal->mappings[i].button_id;        }    }    return 0;}