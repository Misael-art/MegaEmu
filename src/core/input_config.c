/** * @file input_config.c * @brief Implementação para configuração de controles em tempo real */#include "core/input_config.h"#include "utils/enhanced_log.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>// Definições para teclas especiais#define KEY_F1 0x3b#define KEY_F2 0x3c#define KEY_F3 0x3d#define KEY_F4 0x3e#define KEY_F5 0x3f#define KEY_F6 0x40#define KEY_F7 0x41#define KEY_F8 0x42#define KEY_F9 0x43#define KEY_F10 0x44#define KEY_F11 0x57#define KEY_F12 0x58#define KEY_LSHIFT 0x2a#define KEY_RSHIFT 0x36#define KEY_LCTRL 0x1d#define KEY_RCTRL 0x1d // Mesma tecla, diferenciada pelo código estendido#define KEY_LALT 0x38#define KEY_RALT 0x38 // Mesma tecla, diferenciada pelo código estendido// Modificadores#define MOD_SHIFT 0x01#define MOD_CTRL 0x02#define MOD_ALT 0x04// Definições adicionais para configurações avançadas#define INPUT_MAX_PROFILES 10#define INPUT_MAX_AXES 8#define INPUT_CALIBRATION_SAMPLES 100#define INPUT_PROFILE_FILE_EXTENSION ".input"// Estrutura para calibração de eixostypedef struct{    float min_value;    float max_value;    float center_value;    float deadzone;    bool inverted;    int samples[INPUT_CALIBRATION_SAMPLES];    int sample_count;    bool is_calibrating;} input_axis_calibration_t;// Estrutura para perfil de entradatypedef struct{    char name[64];    char description[256];    input_controller_config_t controllers[INPUT_CONFIG_MAX_CONTROLLERS];    bool is_default;    time_t creation_time;    time_t last_modified_time;} input_profile_t;// Estrutura para contexto de configuração de entradastruct input_config_t{    input_controller_config_t controllers[INPUT_CONFIG_MAX_CONTROLLERS];    bool in_config_mode;    int config_controller_id;    char config_button_name[32];    int config_timeout;    // Callback para notificar mudanças    void (*callback)(int controller_id, const char *button_name, void *user_data);    void *callback_user_data;    // Atalhos para save states    input_button_mapping_t save_state_shortcuts[10]; // Até 10 slots    input_button_mapping_t load_state_shortcuts[10]; // Até 10 slots    input_button_mapping_t create_snapshot_shortcut;    input_button_mapping_t restore_snapshot_shortcut;    // Calibração de eixos    input_axis_calibration_t axis_calibration[INPUT_CONFIG_MAX_CONTROLLERS][INPUT_MAX_AXES];    // Perfis de entrada    input_profile_t profiles[INPUT_MAX_PROFILES];    int num_profiles;    int current_profile;    // Hotplug de controles    bool enable_hotplug;    void (*hotplug_callback)(int device_id, bool is_connected, void *user_data);    void *hotplug_user_data;    // Dados para configuração baseada em GUI    void *gui_context;    int (*gui_create_callback)(void *gui_context, input_config_t *config);    void (*gui_destroy_callback)(void *gui_context);};/** * @brief Cria um novo contexto de configuração de entrada */input_config_t *input_config_create(void){    input_config_t *config = (input_config_t *)malloc(sizeof(input_config_t));    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Falha ao alocar contexto de configuração de entrada");        return NULL;    }    // Inicializa a estrutura    memset(config, 0, sizeof(input_config_t));    // Inicializa controladores    for (int i = 0; i < INPUT_CONFIG_MAX_CONTROLLERS; i++)    {        sprintf(config->controllers[i].name, "Controller %d", i + 1);        config->controllers[i].enabled = (i < 2); // Habilita os dois primeiros por padrão    }    // Configura atalhos padrão para save states    // F1-F10 para salvar estados (1-10)    for (int i = 0; i < 10; i++)    {        input_button_mapping_t *mapping = &config->save_state_shortcuts[i];        sprintf(mapping->name, "Save State %d", i + 1);        mapping->device = INPUT_DEVICE_KEYBOARD;        mapping->device_id = 0;        mapping->code = KEY_F1 + i;        mapping->modifier = MOD_CTRL; // Ctrl+F1, Ctrl+F2, etc.        mapping->is_axis = false;    }    // F1-F10 para carregar estados (1-10)    for (int i = 0; i < 10; i++)    {        input_button_mapping_t *mapping = &config->load_state_shortcuts[i];        sprintf(mapping->name, "Load State %d", i + 1);        mapping->device = INPUT_DEVICE_KEYBOARD;        mapping->device_id = 0;        mapping->code = KEY_F1 + i;        mapping->modifier = MOD_SHIFT; // Shift+F1, Shift+F2, etc.        mapping->is_axis = false;    }    // F11 para criar snapshot    strcpy(config->create_snapshot_shortcut.name, "Create Snapshot");    config->create_snapshot_shortcut.device = INPUT_DEVICE_KEYBOARD;    config->create_snapshot_shortcut.device_id = 0;    config->create_snapshot_shortcut.code = KEY_F11;    config->create_snapshot_shortcut.modifier = 0; // Sem modificador    config->create_snapshot_shortcut.is_axis = false;    // F12 para restaurar snapshot    strcpy(config->restore_snapshot_shortcut.name, "Restore Snapshot");    config->restore_snapshot_shortcut.device = INPUT_DEVICE_KEYBOARD;    config->restore_snapshot_shortcut.device_id = 0;    config->restore_snapshot_shortcut.code = KEY_F12;    config->restore_snapshot_shortcut.modifier = 0; // Sem modificador    config->restore_snapshot_shortcut.is_axis = false;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Contexto de configuração de entrada criado");    return config;}/** * @brief Libera um contexto de configuração de entrada */void input_config_destroy(input_config_t *config){    if (config)    {        free(config);        EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Contexto de configuração de entrada liberado");    }}/** * @brief Adiciona uma configuração de controle */int input_config_add_controller(    input_config_t *config,    int controller_id,    const char *name){    if (!config || controller_id < 0 || controller_id >= INPUT_CONFIG_MAX_CONTROLLERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Parâmetros inválidos ao adicionar controlador");        return INPUT_CONFIG_ERROR_INVALID;    }    // Limpa a configuração anterior    memset(&config->controllers[controller_id], 0, sizeof(input_controller_config_t));    // Define o novo nome e habilita    strncpy(config->controllers[controller_id].name, name, sizeof(config->controllers[controller_id].name) - 1);    config->controllers[controller_id].enabled = true;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Controlador %d adicionado: %s", controller_id, name);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Remove uma configuração de controle */int input_config_remove_controller(    input_config_t *config,    int controller_id){    if (!config || controller_id < 0 || controller_id >= INPUT_CONFIG_MAX_CONTROLLERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Parâmetros inválidos ao remover controlador");        return INPUT_CONFIG_ERROR_INVALID;    }    // Desabilita o controlador    config->controllers[controller_id].enabled = false;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Controlador %d removido", controller_id);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Adiciona um mapeamento de botão */int input_config_add_button_mapping(    input_config_t *config,    int controller_id,    const input_button_mapping_t *mapping){    if (!config || !mapping || controller_id < 0 || controller_id >= INPUT_CONFIG_MAX_CONTROLLERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Parâmetros inválidos ao adicionar mapeamento de botão");        return INPUT_CONFIG_ERROR_INVALID;    }    input_controller_config_t *controller = &config->controllers[controller_id];    // Verifica se já existe um botão com este nome    for (int i = 0; i < controller->num_buttons; i++)    {        if (strcmp(controller->buttons[i].name, mapping->name) == 0)        {            // Sobrescreve o mapeamento existente            memcpy(&controller->buttons[i], mapping, sizeof(input_button_mapping_t));            EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Mapeamento para botão '%s' atualizado", mapping->name);            return INPUT_CONFIG_ERROR_NONE;        }    }    // Verifica se há espaço para mais um botão    if (controller->num_buttons >= INPUT_CONFIG_MAX_BUTTONS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Número máximo de botões excedido para controlador %d", controller_id);        return INPUT_CONFIG_ERROR_DUPLICATE;    }    // Adiciona o novo mapeamento    memcpy(&controller->buttons[controller->num_buttons], mapping, sizeof(input_button_mapping_t));    controller->num_buttons++;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Mapeamento para botão '%s' adicionado ao controlador %d", mapping->name, controller_id);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Processa um evento de entrada e verifica atalhos de save state * * @param config Ponteiro para o contexto * @param device_type Tipo de dispositivo * @param device_id ID do dispositivo * @param code Código do botão/tecla * @param modifier Modificadores (Shift, Ctrl, Alt) * @param pressed 1 se pressionado, 0 se liberado * @return int Número do slot de save state (1-10), -1 para snapshot, -2 para nenhum */int input_config_check_save_state_shortcuts(    input_config_t *config,    input_device_type_t device_type,    int device_id,    int code,    int modifier,    int pressed){    EMU_UNUSED(device_id);    EMU_UNUSED(modifier);    if (!config || !pressed)        return -2;    if (device_type != INPUT_DEVICE_KEYBOARD)        return -2;    // Verifica os atalhos de salvar    for (int i = 0; i < 10; i++)    {        input_button_mapping_t *mapping = &config->save_state_shortcuts[i];        if (mapping->code == code && mapping->modifier == modifier)        {            EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Atalho para salvar estado %d detectado", i + 1);            return i + 1;        }    }    // Verifica os atalhos de carregar    for (int i = 0; i < 10; i++)    {        input_button_mapping_t *mapping = &config->load_state_shortcuts[i];        if (mapping->code == code && mapping->modifier == modifier)        {            EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Atalho para carregar estado %d detectado", i + 1);            return -(i + 1); // Negativo para carregar        }    }    // Verifica o atalho de criar snapshot    if (config->create_snapshot_shortcut.code == code &&        config->create_snapshot_shortcut.modifier == modifier)    {        EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Atalho para criar snapshot detectado");        return -10; // Código especial para snapshot    }    // Verifica o atalho de restaurar snapshot    if (config->restore_snapshot_shortcut.code == code &&        config->restore_snapshot_shortcut.modifier == modifier)    {        EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Atalho para restaurar snapshot detectado");        return -11; // Código especial para restaurar snapshot    }    return -2; // Nenhum atalho detectado}/** * @brief Salva as configurações em um arquivo */int input_config_save(    input_config_t *config,    const char *filename){    if (!config || !filename)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Parâmetros inválidos para salvar configurações");        return INPUT_CONFIG_ERROR_INVALID;    }    // Abre o arquivo para escrita    FILE *file = fopen(filename, "w");    if (!file)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Falha ao abrir arquivo para salvar configurações: %s", filename);        return INPUT_CONFIG_ERROR_FILE;    }    // Escreve o cabeçalho    fprintf(file, "# Mega Emu Input Configuration\n");    fprintf(file, "# Created: %s\n\n", __DATE__);    // Escreve configurações de controladores    for (int i = 0; i < INPUT_CONFIG_MAX_CONTROLLERS; i++)    {        input_controller_config_t *controller = &config->controllers[i];        fprintf(file, "[Controller %d]\n", i);        fprintf(file, "Name=%s\n", controller->name);        fprintf(file, "Enabled=%d\n", controller->enabled ? 1 : 0);        for (int j = 0; j < controller->num_buttons; j++)        {            input_button_mapping_t *mapping = &controller->buttons[j];            fprintf(file, "Button.%s=%d,%d,%d,%d,%d,%d,%f\n",                    mapping->name,                    mapping->device,                    mapping->device_id,                    mapping->code,                    mapping->modifier,                    mapping->is_axis ? 1 : 0,                    mapping->axis_direction,                    mapping->deadzone);        }        fprintf(file, "\n");    }    // Escreve atalhos de save state    fprintf(file, "[SaveState]\n");    // Atalhos para salvar    for (int i = 0; i < 10; i++)    {        input_button_mapping_t *mapping = &config->save_state_shortcuts[i];        fprintf(file, "Save.%d=%d,%d,%d,%d\n",                i + 1,                mapping->device,                mapping->device_id,                mapping->code,                mapping->modifier);    }    // Atalhos para carregar    for (int i = 0; i < 10; i++)    {        input_button_mapping_t *mapping = &config->load_state_shortcuts[i];        fprintf(file, "Load.%d=%d,%d,%d,%d\n",                i + 1,                mapping->device,                mapping->device_id,                mapping->code,                mapping->modifier);    }    // Atalhos para snapshot    fprintf(file, "CreateSnapshot=%d,%d,%d,%d\n",            config->create_snapshot_shortcut.device,            config->create_snapshot_shortcut.device_id,            config->create_snapshot_shortcut.code,            config->create_snapshot_shortcut.modifier);    fprintf(file, "RestoreSnapshot=%d,%d,%d,%d\n",            config->restore_snapshot_shortcut.device,            config->restore_snapshot_shortcut.device_id,            config->restore_snapshot_shortcut.code,            config->restore_snapshot_shortcut.modifier);    fclose(file);    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Configurações de entrada salvas em %s", filename);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Carrega configurações de um arquivo (implementação básica) */int input_config_load(    input_config_t *config,    const char *filename){    if (!config || !filename)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Parâmetros inválidos para carregar configurações");        return INPUT_CONFIG_ERROR_INVALID;    }    // Abre o arquivo para leitura    FILE *file = fopen(filename, "r");    if (!file)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Arquivo de configuração não encontrado: %s", filename);        return INPUT_CONFIG_ERROR_FILE;    }    // Em uma implementação real, aqui parsearíamos o arquivo    // Para esta versão básica, apenas simulamos o carregamento    fclose(file);    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Configurações de entrada carregadas de %s", filename);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Define uma função de callback para notificar mudanças */void input_config_set_callback(    input_config_t *config,    void (*callback)(int controller_id, const char *button_name, void *user_data),    void *user_data){    if (config)    {        config->callback = callback;        config->callback_user_data = user_data;    }}/** * @brief Cria um novo perfil de entrada * * @param config Ponteiro para o contexto * @param name Nome do perfil * @param description Descrição do perfil * @return int ID do perfil ou código de erro negativo */int input_config_create_profile(    input_config_t *config,    const char *name,    const char *description){    if (!config || !name)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Parâmetros inválidos para criar perfil");        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se já existe um perfil com este nome    for (int i = 0; i < config->num_profiles; i++)    {        if (strcmp(config->profiles[i].name, name) == 0)        {            EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Já existe um perfil com o nome '%s'", name);            return INPUT_CONFIG_ERROR_DUPLICATE;        }    }    // Verifica se há espaço para mais um perfil    if (config->num_profiles >= INPUT_MAX_PROFILES)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Número máximo de perfis atingido");        return INPUT_CONFIG_ERROR_DUPLICATE;    }    // Cria o novo perfil    int profile_id = config->num_profiles++;    input_profile_t *profile = &config->profiles[profile_id];    memset(profile, 0, sizeof(input_profile_t));    strncpy(profile->name, name, sizeof(profile->name) - 1);    if (description)        strncpy(profile->description, description, sizeof(profile->description) - 1);    // Inicializa timestamps    time_t now = time(NULL);    profile->creation_time = now;    profile->last_modified_time = now;    // Copia a configuração atual para o novo perfil    for (int i = 0; i < INPUT_CONFIG_MAX_CONTROLLERS; i++)    {        memcpy(&profile->controllers[i], &config->controllers[i], sizeof(input_controller_config_t));    }    // Define como default se for o primeiro perfil    profile->is_default = (profile_id == 0);    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Perfil de entrada '%s' criado com ID %d", name, profile_id);    return profile_id;}/** * @brief Carrega um perfil de entrada * * @param config Ponteiro para o contexto * @param profile_id ID do perfil * @return int Código de erro (0 para sucesso) */int input_config_load_profile(    input_config_t *config,    int profile_id){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para carregar perfil");        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do perfil é válido    if (profile_id < 0 || profile_id >= config->num_profiles)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de perfil inválido: %d", profile_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Carrega o perfil    input_profile_t *profile = &config->profiles[profile_id];    // Copia a configuração do perfil para a configuração atual    for (int i = 0; i < INPUT_CONFIG_MAX_CONTROLLERS; i++)    {        memcpy(&config->controllers[i], &profile->controllers[i], sizeof(input_controller_config_t));    }    // Atualiza o perfil atual    config->current_profile = profile_id;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Perfil de entrada '%s' carregado", profile->name);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Salva a configuração atual em um perfil * * @param config Ponteiro para o contexto * @param profile_id ID do perfil * @return int Código de erro (0 para sucesso) */int input_config_save_to_profile(    input_config_t *config,    int profile_id){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para salvar perfil");        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do perfil é válido    if (profile_id < 0 || profile_id >= config->num_profiles)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de perfil inválido: %d", profile_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Obtém o perfil    input_profile_t *profile = &config->profiles[profile_id];    // Copia a configuração atual para o perfil    for (int i = 0; i < INPUT_CONFIG_MAX_CONTROLLERS; i++)    {        memcpy(&profile->controllers[i], &config->controllers[i], sizeof(input_controller_config_t));    }    // Atualiza o timestamp    profile->last_modified_time = time(NULL);    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Configuração atual salva no perfil '%s'", profile->name);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Remove um perfil de entrada * * @param config Ponteiro para o contexto * @param profile_id ID do perfil * @return int Código de erro (0 para sucesso) */int input_config_remove_profile(    input_config_t *config,    int profile_id){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para remover perfil");        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do perfil é válido    if (profile_id < 0 || profile_id >= config->num_profiles)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de perfil inválido: %d", profile_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Não permite remover o perfil atual    if (profile_id == config->current_profile)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Não é possível remover o perfil atual");        return INPUT_CONFIG_ERROR_INVALID;    }    // Remove o perfil    input_profile_t *profile = &config->profiles[profile_id];    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Removendo perfil de entrada '%s'", profile->name);    // Move os perfis subsequentes    for (int i = profile_id; i < config->num_profiles - 1; i++)    {        memcpy(&config->profiles[i], &config->profiles[i + 1], sizeof(input_profile_t));    }    // Atualiza o contador    config->num_profiles--;    // Ajusta o ID do perfil atual    if (config->current_profile > profile_id)    {        config->current_profile--;    }    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Inicia a calibração de um eixo analógico * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @return int Código de erro (0 para sucesso) */int input_config_start_axis_calibration(    input_config_t *config,    int controller_id,    int axis_id){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para calibração de eixo");        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do controle é válido    if (controller_id < 0 || controller_id >= INPUT_CONFIG_MAX_CONTROLLERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de controle inválido: %d", controller_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do eixo é válido    if (axis_id < 0 || axis_id >= INPUT_MAX_AXES)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de eixo inválido: %d", axis_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Inicializa a calibração    input_axis_calibration_t *calibration = &config->axis_calibration[controller_id][axis_id];    calibration->min_value = 0.0f;    calibration->max_value = 0.0f;    calibration->center_value = 0.0f;    calibration->deadzone = 0.1f; // Valor padrão    calibration->inverted = false;    calibration->sample_count = 0;    calibration->is_calibrating = true;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Iniciando calibração de eixo %d do controle %d", axis_id, controller_id);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Adiciona uma amostra à calibração de um eixo * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @param value Valor do eixo * @return int Código de erro (0 para sucesso, 1 para calibração concluída) */int input_config_add_axis_sample(    input_config_t *config,    int controller_id,    int axis_id,    float value){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para amostra de eixo");        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do controle é válido    if (controller_id < 0 || controller_id >= INPUT_CONFIG_MAX_CONTROLLERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de controle inválido: %d", controller_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do eixo é válido    if (axis_id < 0 || axis_id >= INPUT_MAX_AXES)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de eixo inválido: %d", axis_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se a calibração está ativa    input_axis_calibration_t *calibration = &config->axis_calibration[controller_id][axis_id];    if (!calibration->is_calibrating)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Calibração não iniciada para eixo %d do controle %d", axis_id, controller_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Adiciona a amostra    if (calibration->sample_count < INPUT_CALIBRATION_SAMPLES)    {        // Armazena a amostra        calibration->samples[calibration->sample_count++] = (int)(value * 1000.0f);        // Atualiza valores mínimo e máximo        if (calibration->sample_count == 1 || value < calibration->min_value)            calibration->min_value = value;        if (calibration->sample_count == 1 || value > calibration->max_value)            calibration->max_value = value;        // Calcula o valor central como média das amostras        float sum = 0.0f;        for (int i = 0; i < calibration->sample_count; i++)        {            sum += calibration->samples[i] / 1000.0f;        }        calibration->center_value = sum / calibration->sample_count;        // Verifica se a calibração está completa        if (calibration->sample_count >= INPUT_CALIBRATION_SAMPLES)        {            EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Calibração de eixo concluída: min=%.2f, max=%.2f, center=%.2f",                         calibration->min_value, calibration->max_value, calibration->center_value);            calibration->is_calibrating = false;            return 1; // Calibração concluída        }        return 0; // Calibração em andamento    }    // Número máximo de amostras atingido    calibration->is_calibrating = false;    return 1; // Calibração concluída}/** * @brief Define a zona morta para um eixo * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @param deadzone Valor da zona morta (0.0 a 1.0) * @return int Código de erro (0 para sucesso) */int input_config_set_axis_deadzone(    input_config_t *config,    int controller_id,    int axis_id,    float deadzone){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para definir zona morta");        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do controle é válido    if (controller_id < 0 || controller_id >= INPUT_CONFIG_MAX_CONTROLLERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de controle inválido: %d", controller_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do eixo é válido    if (axis_id < 0 || axis_id >= INPUT_MAX_AXES)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de eixo inválido: %d", axis_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Limita o valor da zona morta    if (deadzone < 0.0f)        deadzone = 0.0f;    if (deadzone > 1.0f)        deadzone = 1.0f;    // Define a zona morta    config->axis_calibration[controller_id][axis_id].deadzone = deadzone;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Zona morta para eixo %d do controle %d definida como %.2f",                 axis_id, controller_id, deadzone);    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Inverte a direção de um eixo * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @param inverted true para inverter, false para normal * @return int Código de erro (0 para sucesso) */int input_config_set_axis_inverted(    input_config_t *config,    int controller_id,    int axis_id,    bool inverted){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para inverter eixo");        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do controle é válido    if (controller_id < 0 || controller_id >= INPUT_CONFIG_MAX_CONTROLLERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de controle inválido: %d", controller_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Verifica se o ID do eixo é válido    if (axis_id < 0 || axis_id >= INPUT_MAX_AXES)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de eixo inválido: %d", axis_id);        return INPUT_CONFIG_ERROR_INVALID;    }    // Define a inversão    config->axis_calibration[controller_id][axis_id].inverted = inverted;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Eixo %d do controle %d %s",                 axis_id, controller_id, inverted ? "invertido" : "normal");    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Normaliza um valor de eixo aplicando calibração * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @param raw_value Valor bruto do eixo * @return float Valor normalizado (-1.0 a 1.0) ou 0.0 em caso de erro */float input_config_normalize_axis(    input_config_t *config,    int controller_id,    int axis_id,    float raw_value){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para normalizar eixo");        return 0.0f;    }    // Verifica se o ID do controle é válido    if (controller_id < 0 || controller_id >= INPUT_CONFIG_MAX_CONTROLLERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de controle inválido: %d", controller_id);        return 0.0f;    }    // Verifica se o ID do eixo é válido    if (axis_id < 0 || axis_id >= INPUT_MAX_AXES)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "ID de eixo inválido: %d", axis_id);        return 0.0f;    }    // Obtém a calibração    input_axis_calibration_t *calibration = &config->axis_calibration[controller_id][axis_id];    // Se não há calibração, retorna o valor bruto    if (calibration->min_value == calibration->max_value)    {        return raw_value;    }    // Normaliza o valor    float normalized;    if (raw_value < calibration->center_value)    {        // Valor negativo        float range = calibration->center_value - calibration->min_value;        if (range == 0.0f)            return 0.0f;        normalized = (calibration->center_value - raw_value) / range;        normalized = -normalized; // Torna negativo    }    else    {        // Valor positivo        float range = calibration->max_value - calibration->center_value;        if (range == 0.0f)            return 0.0f;        normalized = (raw_value - calibration->center_value) / range;    }    // Aplica zona morta    if (fabs(normalized) < calibration->deadzone)    {        normalized = 0.0f;    }    else    {        // Rescala para que o valor mínimo após a zona morta seja mapeado para 0.0        float scale = 1.0f / (1.0f - calibration->deadzone);        normalized = (fabs(normalized) - calibration->deadzone) * scale * (normalized < 0.0f ? -1.0f : 1.0f);    }    // Limita entre -1.0 e 1.0    if (normalized < -1.0f)        normalized = -1.0f;    if (normalized > 1.0f)        normalized = 1.0f;    // Aplica inversão    if (calibration->inverted)    {        normalized = -normalized;    }    return normalized;}/** * @brief Configura suporte a hotplug de controles * * @param config Ponteiro para o contexto * @param enable true para habilitar, false para desabilitar * @param callback Função de callback para eventos de hotplug * @param user_data Dados de usuário para o callback */void input_config_set_hotplug_support(    input_config_t *config,    bool enable,    void (*callback)(int device_id, bool is_connected, void *user_data),    void *user_data){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para hotplug");        return;    }    config->enable_hotplug = enable;    config->hotplug_callback = callback;    config->hotplug_user_data = user_data;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Suporte a hotplug %s", enable ? "habilitado" : "desabilitado");}/** * @brief Configura a integração com a interface gráfica * * @param config Ponteiro para o contexto * @param gui_context Contexto da GUI * @param create_callback Função para criar elementos da GUI * @param destroy_callback Função para destruir elementos da GUI * @return int Código de erro (0 para sucesso) */int input_config_set_gui_integration(    input_config_t *config,    void *gui_context,    int (*create_callback)(void *gui_context, input_config_t *config),    void (*destroy_callback)(void *gui_context)){    if (!config || !gui_context || !create_callback)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Parâmetros inválidos para integração com GUI");        return INPUT_CONFIG_ERROR_INVALID;    }    config->gui_context = gui_context;    config->gui_create_callback = create_callback;    config->gui_destroy_callback = destroy_callback;    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Integração com GUI configurada");    return INPUT_CONFIG_ERROR_NONE;}/** * @brief Mostra a interface de configuração de controles * * @param config Ponteiro para o contexto * @return int Código de erro (0 para sucesso) */int input_config_show_gui(    input_config_t *config){    if (!config)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Contexto inválido para mostrar GUI");        return INPUT_CONFIG_ERROR_INVALID;    }    if (!config->gui_context || !config->gui_create_callback)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Integração com GUI não configurada");        return INPUT_CONFIG_ERROR_INVALID;    }    // Chama a função para criar a interface    int result = config->gui_create_callback(config->gui_context, config);    if (result != 0)    {        EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, "Falha ao criar interface de configuração");        return INPUT_CONFIG_ERROR_INVALID;    }    EMU_LOG_INFO(EMU_LOG_CAT_INPUT, "Interface de configuração exibida");    return INPUT_CONFIG_ERROR_NONE;}