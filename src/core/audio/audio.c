#include "audio_interface.h"#include "../../utils/error_handling.h"#include <stdlib.h>#include <string.h>#include <math.h>#include "../../utils/enhanced_log.h"#include "../../utils/log_categories.h"// Constantes do PSG#define PSG_CLOCK 3579545#define PSG_NOISE_SHIFT_REGISTER 0x8000// Funções auxiliaresstatic int16_t psg_generate_sample(emu_audio_t audio, int channel){    psg_channel_t *ch = &audio->channels[channel];    // Canal desativado ou mudo    if (!ch->enabled || ch->muted)    {        return 0;    }    // Volume    int16_t volume = ch->volume;    if (volume > PSG_MAX_VOLUME)    {        volume = PSG_MAX_VOLUME;    }    // Canais de ruído    if (channel >= 3 && channel < 6)    {        // Gerar ruído        uint16_t noise = audio->channels[channel].noise_shift;        uint16_t bit = ((noise >> ch->noise_tap) ^ noise) & 1;        noise = (noise >> 1) | (bit << ch->noise_shift);        audio->channels[channel].noise_shift = noise;        // Saída do ruído        return (noise & 1) ? volume * 100 : -volume * 100;    }    // Canais de tom    ch->counter++;    if (ch->counter >= ch->frequency)    {        ch->counter = 0;        ch->waveform ^= 1;    }    // Saída do tom    return ch->waveform ? volume * 100 : -volume * 100;}// Funções do PSGemu_audio_t emu_audio_create(void){    // Alocar PSG    emu_audio_instance_t *audio = (emu_audio_instance_t *)malloc(sizeof(emu_audio_instance_t));    if (audio == NULL)    {        emu_error_set(EMU_ERROR_NULL_POINTER, "Falha ao alocar PSG", __FILE__, __LINE__);        return NULL;    }    // Inicializar campos    memset(audio, 0, sizeof(emu_audio_instance_t));    audio->buffer_pos = 0;    audio->frame_count = 0;    audio->sample_count = 0;    audio->sample_rate = PSG_SAMPLE_RATE;    audio->buffer_size = PSG_BUFFER_SIZE;    audio->initialized = false;    // Inicializar canais    for (int i = 0; i < PSG_CHANNELS; i++)    {        audio->channels[i].frequency = 0;        audio->channels[i].counter = 0;        audio->channels[i].volume = 0;        audio->channels[i].waveform = 0;        audio->channels[i].noise_type = 0;        audio->channels[i].noise_shift = PSG_NOISE_SHIFT_REGISTER;        audio->channels[i].noise_tap = 1;        audio->channels[i].enabled = false;        audio->channels[i].muted = false;    }    LOG_INFO(EMU_LOG_CAT_AUDIO, "%s", "Criado PSG");    return audio;}void emu_audio_destroy(emu_audio_t audio){    if (!audio)    {        LOG_ERROR(EMU_LOG_CAT_AUDIO, "%s", "Tentativa de destruir PSG nulo");        return;    }    // Liberar PSG    free(audio);    LOG_INFO(EMU_LOG_CAT_AUDIO, "Destruído PSG");}int emu_audio_init(emu_audio_t audio){    EMU_CHECK_NULL(audio, "Ponteiro de áudio inválido");    memset(audio, 0, sizeof(emu_audio_instance_t));    audio->sample_rate = PSG_SAMPLE_RATE;    audio->buffer_size = PSG_BUFFER_SIZE;    // Alocar buffer de áudio    audio->buffer = (int16_t *)calloc(audio->buffer_size, sizeof(int16_t));    if (!audio->buffer)    {        EMU_LOG_ERROR(EMU_LOG_CAT_AUDIO, "Falha ao alocar buffer de áudio");        return false;    }    audio->initialized = true;    EMU_LOG_INFO(EMU_LOG_CAT_AUDIO, "Sistema de áudio inicializado: %d Hz", audio->sample_rate);    return true; // Sucesso}void emu_audio_shutdown(emu_audio_t audio){    if (!audio)    {        return;    }    // Liberar buffer de áudio    if (audio->buffer)    {        free(audio->buffer);        audio->buffer = NULL;    }    EMU_LOG_INFO(EMU_LOG_CAT_AUDIO, "Sistema de áudio desligado");    memset(audio, 0, sizeof(emu_audio_instance_t));}int emu_audio_reset(emu_audio_t audio){    EMU_CHECK_NULL(audio, "Ponteiro de áudio inválido");    if (!audio->initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_AUDIO, "Sistema de áudio não inicializado");        return false;    }    // Salvar ponteiro do buffer    int16_t *buffer = audio->buffer;    uint32_t buffer_size = audio->buffer_size;    bool initialized = audio->initialized;    // Resetar os canais    for (int i = 0; i < PSG_CHANNELS; i++)    {        audio->channels[i].enabled = false;        audio->channels[i].muted = false;        audio->channels[i].volume = 0;        audio->channels[i].frequency = 0;        audio->channels[i].counter = 0;        audio->channels[i].waveform = 0;        audio->channels[i].noise_shift = PSG_NOISE_SHIFT_REGISTER;        audio->channels[i].noise_tap = 0x0001;        audio->channels[i].noise_type = 0;    }    // Limpar registradores e buffer    memset(audio->registers, 0, sizeof(audio->registers));    memset(buffer, 0, buffer_size * sizeof(int16_t));    // Restaurar estado    audio->buffer = buffer;    audio->buffer_size = buffer_size;    audio->initialized = initialized;    EMU_LOG_INFO(EMU_LOG_CAT_AUDIO, "Sistema de áudio resetado");    return true; // Sucesso}bool emu_audio_update(emu_audio_t audio){    EMU_CHECK_NULL(audio, "Ponteiro de áudio inválido");    if (!audio->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Sistema de áudio não inicializado");    }    EMU_LOG_DEBUG(EMU_LOG_CAT_AUDIO, "Atualizando sistema de áudio");    return true;}int emu_audio_run_frame(emu_audio_t audio){    if (audio == NULL)    {        emu_error_set(EMU_ERROR_NULL_POINTER, "Audio instance is NULL", __FILE__, __LINE__);        return false;    }    // Calcular número de amostras por frame (60Hz)    int samples = PSG_SAMPLE_RATE / 60;    // Gerar amostras    int result = emu_audio_run_samples(audio, samples);    if (result != EMU_ERROR_NONE)    {        return result;    }    // Incrementar contador de frames    audio->frame_count++;    LOG_DEBUG(EMU_LOG_CAT_AUDIO, "Frame %d completado", audio->frame_count);    return EMU_ERROR_NONE;}int emu_audio_run_samples(emu_audio_t audio, int samples){    if (audio == NULL)    {        emu_error_set(EMU_ERROR_NULL_POINTER, "Audio instance is NULL", __FILE__, __LINE__);        return false;    }    if (samples <= 0)    {        emu_error_set(EMU_ERROR_INVALID_PARAM, "Invalid sample count", __FILE__, __LINE__);        return false;    }    // Verificar espaço no buffer    if (audio->buffer_pos + samples > PSG_BUFFER_SIZE)    {        EMU_THROW(EMU_ERROR_OUT_OF_BOUNDS, "Buffer de áudio cheio");    }    // Gerar amostras    for (int i = 0; i < samples; i++)    {        int16_t sample = 0;        // Somar saída de todos os canais        for (int j = 0; j < PSG_CHANNELS; j++)        {            sample += psg_generate_sample(audio, j);        }        // Limitar amplitude        if (sample > 32767)        {            sample = 32767;        }        else if (sample < -32768)        {            sample = -32768;        }        // Armazenar amostra no buffer        audio->buffer[audio->buffer_pos++] = sample;        audio->sample_count++;    }    return EMU_ERROR_NONE;}void emu_audio_set_userdata(emu_audio_t audio, void *userdata){    if (!audio)    {        return;    }    audio->userdata = userdata;}void *emu_audio_get_userdata(emu_audio_t audio){    if (!audio)    {        return NULL;    }    return audio->userdata;}void emu_audio_write_register(emu_audio_t audio, uint8_t reg, uint8_t value){    if (!audio)    {        return;    }    audio->registers[reg] = value;}uint8_t emu_audio_read_register(emu_audio_t audio, uint8_t reg){    if (!audio)    {        return 0;    }    return audio->registers[reg];}void emu_audio_set_channel_volume(emu_audio_t audio, int channel, uint8_t volume){    if (!audio || channel < 0 || channel >= PSG_CHANNELS)    {        return;    }    audio->channels[channel].volume = volume;}void emu_audio_set_channel_frequency(emu_audio_t audio, int channel, uint16_t frequency){    if (!audio || channel < 0 || channel >= PSG_CHANNELS)    {        return;    }    audio->channels[channel].frequency = frequency;}void emu_audio_set_channel_waveform(emu_audio_t audio, int channel, uint8_t waveform){    if (!audio || channel < 0 || channel >= PSG_CHANNELS)    {        return;    }    audio->channels[channel].waveform = waveform;}void emu_audio_set_channel_noise(emu_audio_t audio, int channel, uint8_t type, uint16_t shift, uint8_t tap){    if (!audio || channel < 0 || channel >= PSG_CHANNELS)    {        return;    }    audio->channels[channel].noise_type = type;    audio->channels[channel].noise_shift = shift;    audio->channels[channel].noise_tap = tap;    EMU_LOG_DEBUG(EMU_LOG_CAT_AUDIO, "Canal %d: tipo=%d, shift=0x%04X, tap=%d",                  channel, type, shift, tap);}void emu_audio_enable_channel(emu_audio_t audio, int channel, int enable){    if (!audio || channel < 0 || channel >= PSG_CHANNELS)    {        return;    }    audio->channels[channel].enabled = enable;}void emu_audio_mute_channel(emu_audio_t audio, int channel, int mute){    if (!audio || channel < 0 || channel >= PSG_CHANNELS)    {        return;    }    audio->channels[channel].muted = mute;}void emu_audio_get_buffer(emu_audio_t audio, int16_t *buffer){    if (!audio || !buffer)    {        return;    }    memcpy(buffer, audio->buffer, audio->buffer_size * sizeof(int16_t));}int emu_audio_get_frame_count(emu_audio_t audio){    if (!audio)    {        return 0;    }    return audio->frame_count;}int emu_audio_get_sample_count(emu_audio_t audio){    if (!audio)    {        return 0;    }    return audio->sample_count;}int emu_audio_get_buffer_pos(emu_audio_t audio){    if (!audio)    {        return 0;    }    return audio->buffer_pos;}