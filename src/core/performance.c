/** * @file performance.c * @brief Implementação do sistema de medição de performance *//* Incluir primeiramente as bibliotecas do sistema para evitar conflitos */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <float.h>#ifdef _WIN32#include <windows.h>#else#include <time.h>#include <sys/time.h>#endif/* Agora incluir os arquivos do projeto */#include "performance.h"#include "../utils/enhanced_log.h"/* Estrutura para armazenar informações de performance */typedef struct{    const char *name;    uint64_t start_time;    uint64_t total_time;    uint64_t calls;    float min_time;    float max_time;    bool active;} emu_perf_counter_t;/* Estado global do sistema de performance */static struct{    emu_perf_counter_t counters[EMU_PERF_MAX_COUNTERS];    size_t num_counters;    bool initialized;} g_perf = {    .num_counters = 0,    .initialized = false};bool emu_perf_init(void){    if (g_perf.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Sistema de performance já inicializado");        return false;    }    memset(&g_perf, 0, sizeof(g_perf));    g_perf.initialized = true;    EMU_LOG_INFO(EMU_LOG_CAT_CORE, "Sistema de performance inicializado");    return true;}void emu_perf_shutdown(void){    if (!g_perf.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Sistema de performance não inicializado");        return;    }    for (size_t i = 0; i < g_perf.num_counters; i++)    {        if (g_perf.counters[i].active)        {            EMU_LOG_WARN(EMU_LOG_CAT_CORE, "Contador '%s' ainda ativo durante shutdown", g_perf.counters[i].name);        }    }    memset(&g_perf, 0, sizeof(g_perf));    EMU_LOG_INFO(EMU_LOG_CAT_CORE, "Sistema de performance finalizado");}int emu_perf_register_counter(const char *name){    if (!g_perf.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Sistema de performance não inicializado");        return -1;    }    if (!name)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Nome do contador inválido");        return -1;    }    if (g_perf.num_counters >= EMU_PERF_MAX_COUNTERS)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Número máximo de contadores atingido");        return -1;    }    // Verifica se já existe um contador com o mesmo nome    for (size_t i = 0; i < g_perf.num_counters; i++)    {        if (strcmp(g_perf.counters[i].name, name) == 0)        {            EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Contador '%s' já existe", name);            return -1;        }    }    int id = (int)g_perf.num_counters++;    emu_perf_counter_t *counter = &g_perf.counters[id];    counter->name = name;    counter->start_time = 0;    counter->total_time = 0;    counter->calls = 0;    counter->min_time = FLT_MAX;    counter->max_time = 0.0f;    counter->active = false;    EMU_LOG_INFO(EMU_LOG_CAT_CORE, "Contador '%s' registrado com ID %d", name, id);    return id;}void emu_perf_start_counter(int id){    if (!g_perf.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Sistema de performance não inicializado");        return;    }    if (id < 0 || id >= (int)g_perf.num_counters)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "ID de contador inválido: %d", id);        return;    }    emu_perf_counter_t *counter = &g_perf.counters[id];    if (counter->active)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Contador '%s' já está ativo", counter->name);        return;    }    counter->start_time = emu_perf_get_time_ns();    counter->active = true;}void emu_perf_stop_counter(int id){    if (!g_perf.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Sistema de performance não inicializado");        return;    }    if (id < 0 || id >= (int)g_perf.num_counters)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "ID de contador inválido: %d", id);        return;    }    emu_perf_counter_t *counter = &g_perf.counters[id];    if (!counter->active)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Contador '%s' não está ativo", counter->name);        return;    }    uint64_t end_time = emu_perf_get_time_ns();    uint64_t elapsed = end_time - counter->start_time;    counter->total_time += elapsed;    counter->calls++;    float elapsed_ms = (float)elapsed / 1000000.0f;    if (elapsed_ms < counter->min_time)    {        counter->min_time = elapsed_ms;    }    if (elapsed_ms > counter->max_time)    {        counter->max_time = elapsed_ms;    }    counter->active = false;}void emu_perf_reset_counter(int id){    if (!g_perf.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Sistema de performance não inicializado");        return;    }    if (id < 0 || id >= (int)g_perf.num_counters)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "ID de contador inválido: %d", id);        return;    }    emu_perf_counter_t *counter = &g_perf.counters[id];    counter->start_time = 0;    counter->total_time = 0;    counter->calls = 0;    counter->min_time = FLT_MAX;    counter->max_time = 0.0f;    counter->active = false;}void emu_perf_reset_all(void){    if (!g_perf.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Sistema de performance não inicializado");        return;    }    for (size_t i = 0; i < g_perf.num_counters; i++)    {        emu_perf_reset_counter((int)i);    }}float emu_perf_get_average_time(int id){    if (!g_perf.initialized)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "Sistema de performance não inicializado");        return 0.0f;    }    if (id < 0 || id >= (int)g_perf.num_counters)    {        EMU_LOG_ERROR(EMU_LOG_CAT_CORE, "ID de contador inválido: %d", id);        return 0.0f;    }    emu_perf_counter_t *counter = &g_perf.counters[id];    if (counter->calls == 0)    {        return 0.0f;    }    return (float)counter->total_time / (float)counter->calls / 1000000.0f;}float emu_perf_get_min_time(int id){    if (!g_perf.initialized || id < 0 || id >= (int)g_perf.num_counters)    {        return 0.0f;    }    return g_perf.counters[id].min_time;}float emu_perf_get_max_time(int id){    if (!g_perf.initialized || id < 0 || id >= (int)g_perf.num_counters)    {        return 0.0f;    }    return g_perf.counters[id].max_time;}uint64_t emu_perf_get_total_time(int id){    if (!g_perf.initialized || id < 0 || id >= (int)g_perf.num_counters)    {        return 0;    }    return g_perf.counters[id].total_time;}uint64_t emu_perf_get_calls(int id){    if (!g_perf.initialized || id < 0 || id >= (int)g_perf.num_counters)    {        return 0;    }    return g_perf.counters[id].calls;}uint64_t emu_perf_get_time_ns(void){#ifdef _WIN32    LARGE_INTEGER freq, count;    QueryPerformanceFrequency(&freq);    QueryPerformanceCounter(&count);    return (uint64_t)(count.QuadPart * 1000000000ULL / freq.QuadPart);#else    struct timespec ts;    clock_gettime(CLOCK_MONOTONIC, &ts);    return (uint64_t)ts.tv_sec * 1000000000ULL + (uint64_t)ts.tv_nsec;#endif}