#include <stdint.h>/** * @file config_system.hpp * @brief Define a classe base para o sistema de configuração * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-10 */#pragma once#include <string>#include <map>#include <variant>#include <vector>#include <fstream>#include <sstream>#include <iostream>#include <filesystem>namespace MegaEmu{    namespace Core    {        /**         * @brief Tipo que representa um valor de configuração         */        using ConfigValue = std::variant<bool, int32_t, double, std::string>;        /**         * @brief Classe que gerencia o sistema de configuração         */        class ConfigSystem        {        public:            /**             * @brief Construtor             * @param configFileName Nome do arquivo de configuração             */            ConfigSystem(const std::string &configFileName = "settings.ini")                : configFileName(configFileName)            {                // Definir valores padrão                setDefaultValues();                // Carregar configurações do arquivo                loadConfig();            }            /**             * @brief Destrutor             */            ~ConfigSystem()            {                // Salvar configurações ao destruir                saveConfig();            }            /**             * @brief Define um valor de configuração             * @param key Chave da configuração             * @param value Valor da configuração             */            template <typename T>            void setValue(const std::string &key, const T &value)            {                // Verificar se a seção existe                std::string section = "General";                std::string actualKey = key;                // Verificar se a chave contém um separador de seção                size_t pos = key.find(".");                if (pos != std::string::npos)                {                    section = key.substr(0, pos);                    actualKey = key.substr(pos + 1);                }                configValues[section][actualKey] = value;            }            /**             * @brief Obtém um valor de configuração             * @param key Chave da configuração             * @param defaultValue Valor padrão caso a chave não exista             * @return Valor da configuração             */            template <typename T>            T getValue(const std::string &key, const T &defaultValue) const            {                // Verificar se a seção existe                std::string section = "General";                std::string actualKey = key;                // Verificar se a chave contém um separador de seção                size_t pos = key.find(".");                if (pos != std::string::npos)                {                    section = key.substr(0, pos);                    actualKey = key.substr(pos + 1);                }                // Verificar se a seção existe                auto sectionIt = configValues.find(section);                if (sectionIt == configValues.end())                {                    return defaultValue;                }                // Verificar se a chave existe na seção                auto keyIt = sectionIt->second.find(actualKey);                if (keyIt == sectionIt->second.end())                {                    return defaultValue;                }                // Tentar converter o valor para o tipo solicitado                try                {                    return std::get<T>(keyIt->second);                }                catch (const std::bad_variant_access &)                {                    return defaultValue;                }            }            /**             * @brief Carrega as configurações do arquivo             * @return true se as configurações foram carregadas com sucesso             */            bool loadConfig()            {                try                {                    std::ifstream file(configFileName);                    if (!file.is_open())                    {                        return false;                    }                    std::string line;                    std::string currentSection = "General";                    while (std::getline(file, line))                    {                        // Ignorar linhas em branco e comentários                        if (line.empty() || line[0] == '#' || line[0] == ';')                        {                            continue;                        }                        // Verificar se é uma seção                        if (line[0] == '[' && line[line.length() - 1] == ']')                        {                            currentSection = line.substr(1, line.length() - 2);                            continue;                        }                        // Verificar se é um par chave-valor                        size_t pos = line.find("=");                        if (pos != std::string::npos)                        {                            std::string key = line.substr(0, pos);                            std::string value = line.substr(pos + 1);                            // Remover espaços em branco                            key.erase(0, key.find_first_not_of(" \t"));                            key.erase(key.find_last_not_of(" \t") + 1);                            value.erase(0, value.find_first_not_of(" \t"));                            value.erase(value.find_last_not_of(" \t") + 1);                            // Tentar converter o valor para o tipo apropriado                            if (value == "true" || value == "false")                            {                                configValues[currentSection][key] = (value == "true");                            }                            else if (value.find('.') != std::string::npos)                            {                                try                                {                                    configValues[currentSection][key] = std::stod(value);                                }                                catch (...)                                {                                    configValues[currentSection][key] = value;                                }                            }                            else                            {                                try                                {                                    configValues[currentSection][key] = std::stoi(value);                                }                                catch (...)                                {                                    configValues[currentSection][key] = value;                                }                            }                        }                    }                    file.close();                    return true;                }                catch (const std::exception &e)                {                    std::cerr << "Erro ao carregar configurações: " << e.what() << std::endl;                    return false;                }            }            /**             * @brief Salva as configurações no arquivo             * @return true se as configurações foram salvas com sucesso             */            bool saveConfig() const            {                try                {                    // Verificar se o diretório existe                    std::filesystem::path path(configFileName);                    if (!std::filesystem::exists(path.parent_path()))                    {                        std::filesystem::create_directories(path.parent_path());                    }                    std::ofstream file(configFileName);                    if (!file.is_open())                    {                        return false;                    }                    // Escrever cabeçalho                    file << "# Mega_Emu Configuration File" << std::endl;                    file << "# Generated on " << getCurrentDateTime() << std::endl;                    file << std::endl;                    // Escrever valores                    for (const auto &section : configValues)                    {                        file << "[" << section.first << "]" << std::endl;                        for (const auto &entry : section.second)                        {                            file << entry.first << " = ";                            // Escrever valor com o tipo apropriado                            std::visit([&file](const auto &value)                                       {                        using T = std::decay_t<decltype(value)>;                        if constexpr (std::is_same_v<T, bool>) {                            file << (value ? "true" : "false");                        } else if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, double>) {                            file << value;                        } else if constexpr (std::is_same_v<T, std::string>) {                            file << value;                        } }, entry.second);                            file << std::endl;                        }                        file << std::endl;                    }                    file.close();                    return true;                }                catch (const std::exception &e)                {                    std::cerr << "Erro ao salvar configurações: " << e.what() << std::endl;                    return false;                }            }            /**             * @brief Reseta as configurações para os valores padrão             */            void resetToDefaults()            {                configValues.clear();                setDefaultValues();            }            /**             * @brief Obtém uma lista de seções             * @return Lista de seções             */            std::vector<std::string> getSections() const            {                std::vector<std::string> sections;                sections.reserve(configValues.size());                for (const auto &section : configValues)                {                    sections.push_back(section.first);                }                return sections;            }            /**             * @brief Obtém uma lista de chaves de uma seção             * @param section Nome da seção             * @return Lista de chaves             */            std::vector<std::string> getKeys(const std::string &section) const            {                std::vector<std::string> keys;                auto sectionIt = configValues.find(section);                if (sectionIt != configValues.end())                {                    keys.reserve(sectionIt->second.size());                    for (const auto &entry : sectionIt->second)                    {                        keys.push_back(entry.first);                    }                }                return keys;            }        private:            /**             * @brief Define os valores padrão das configurações             */            void setDefaultValues()            {                // Configurações gerais                configValues["General"]["FullScreen"] = false;                configValues["General"]["Resolution"] = "800x600";                configValues["General"]["VSync"] = true;                configValues["General"]["ShowFPS"] = true;                configValues["General"]["Language"] = "pt_BR";                // Configurações de áudio                configValues["Audio"]["Enabled"] = true;                configValues["Audio"]["Volume"] = 80;                configValues["Audio"]["MusicVolume"] = 70;                configValues["Audio"]["SFXVolume"] = 90;                configValues["Audio"]["SampleRate"] = 44100;                // Configurações de entrada                configValues["Input"]["UseGamepad"] = true;                configValues["Input"]["RumbleEnabled"] = true;                configValues["Input"]["DeadZone"] = 0.15;                // Configurações de emulação                configValues["Emulation"]["SpeedMultiplier"] = 1.0;                configValues["Emulation"]["FrameSkip"] = 0;                configValues["Emulation"]["SmoothFrames"] = true;                configValues["Emulation"]["AudioSync"] = true;                // Configurações de diretórios                configValues["Directories"]["ROMs"] = "roms";                configValues["Directories"]["SaveStates"] = "saves/states";                configValues["Directories"]["SaveRAM"] = "saves/ram";                configValues["Directories"]["Screenshots"] = "screenshots";                configValues["Directories"]["Recordings"] = "recordings";            }            /**             * @brief Obtém a data e hora atual como string             * @return String com a data e hora atual             */            std::string getCurrentDateTime() const            {                auto now = std::chrono::system_clock::now();                auto now_c = std::chrono::system_clock::to_time_t(now);                std::stringstream ss;                tm tm_buf;#ifdef _WIN32                localtime_s(&tm_buf, &now_c);#else                localtime_r(&now_c, &tm_buf);#endif                ss << std::put_time(&tm_buf, "%Y-%m-%d %H:%M:%S");                return ss.str();            }            std::string configFileName;                                             ///< Nome do arquivo de configuração            std::map<std::string, std::map<std::string, ConfigValue>> configValues; ///< Valores de configuração        };    } // namespace Core} // namespace MegaEmu