/** * @file component_manager.c * @brief Implementação do gerenciador de componentes * * Este arquivo implementa as funções para registro e gerenciamento * de componentes do emulador. */#include "../public/component_interfaces.h"#include "../../utils/error_handling.h"#include "../../utils/enhanced_log.h"#include <string.h>/** * @brief Estrutura para armazenar informações de componentes registrados */typedef struct{    void *interface;    void *context;    int initialized;} emu_component_entry_t;/** * @brief Estrutura interna da plataforma com os componentes registrados */typedef struct{    emu_component_entry_t components[EMU_COMPONENT_COUNT];} emu_platform_components_t;/** * @brief Converte nome do tipo de componente para texto legível */static const char *component_type_to_string(emu_component_type_t type){    switch (type)    {    case EMU_COMPONENT_CPU:        return "CPU";    case EMU_COMPONENT_MEMORY:        return "Memory";    case EMU_COMPONENT_VIDEO:        return "Video";    case EMU_COMPONENT_AUDIO:        return "Audio";    case EMU_COMPONENT_INPUT:        return "Input";    default:        return "Unknown";    }}/** * @brief Registra um componente na plataforma * * @param platform Ponteiro para a estrutura da plataforma * @param type Tipo de componente * @param interface Ponteiro para a interface do componente * @param context Ponteiro para o contexto do componente * @return int 0 em caso de sucesso, código de erro em caso de falha */int emu_register_component(void *platform, emu_component_type_t type, void *interface, void *context){    // Verificações de parâmetros    EMU_CHECK_NULL(platform, "Plataforma não pode ser nula");    EMU_CHECK_NULL(interface, "Interface do componente não pode ser nula");    EMU_CHECK_NULL(context, "Contexto do componente não pode ser nulo");    EMU_CHECK_BOUNDS((int)type, 0, EMU_COMPONENT_COUNT - 1, "Tipo de componente inválido");    // Obter estrutura interna    emu_platform_components_t *components = (emu_platform_components_t *)platform;    // Verificar se o componente já está registrado    if (components->components[type].interface != NULL)    {        emu_log(EMU_LOG_WARNING, "Componente %s já registrado, substituindo",                component_type_to_string(type));    }    // Registrar o componente    components->components[type].interface = interface;    components->components[type].context = context;    components->components[type].initialized = 0;    emu_log(EMU_LOG_INFO, "Componente %s registrado com sucesso",            component_type_to_string(type));    return 0;}/** * @brief Obtém um componente registrado * * @param platform Ponteiro para a estrutura da plataforma * @param type Tipo de componente * @return void* Ponteiro para o contexto do componente ou NULL se não encontrado */void *emu_get_component(void *platform, emu_component_type_t type){    // Verificações de parâmetros    if (platform == NULL)    {        emu_log(EMU_LOG_ERROR, "Plataforma não pode ser nula");        return NULL;    }    if ((int)type < 0 || (int)type >= EMU_COMPONENT_COUNT)    {        emu_log(EMU_LOG_ERROR, "Tipo de componente inválido: %d", (int)type);        return NULL;    }    // Obter estrutura interna    emu_platform_components_t *components = (emu_platform_components_t *)platform;    // Verificar se o componente está registrado    if (components->components[type].interface == NULL)    {        emu_log(EMU_LOG_WARNING, "Componente %s não registrado",                component_type_to_string(type));        return NULL;    }    return components->components[type].context;}/** * @brief Inicializa todos os componentes registrados * * @param platform Ponteiro para a estrutura da plataforma * @return int 0 em caso de sucesso, código de erro em caso de falha */int emu_init_all_components(void *platform){    // Verificações de parâmetros    EMU_CHECK_NULL(platform, "Plataforma não pode ser nula");    // Obter estrutura interna    emu_platform_components_t *components = (emu_platform_components_t *)platform;    // Inicializar todos os componentes    for (int i = 0; i < EMU_COMPONENT_COUNT; i++)    {        if (components->components[i].interface != NULL && !components->components[i].initialized)        {            emu_component_interface_t *interface =                (emu_component_interface_t *)components->components[i].interface;            if (interface->init != NULL)            {                int result = interface->init(components->components[i].context);                if (result != 0)                {                    emu_log(EMU_LOG_ERROR, "Falha ao inicializar componente %s: %d",                            component_type_to_string(i), result);                    return result;                }                components->components[i].initialized = 1;                emu_log(EMU_LOG_INFO, "Componente %s inicializado com sucesso",                        component_type_to_string(i));            }        }    }    return 0;}/** * @brief Finaliza todos os componentes registrados * * @param platform Ponteiro para a estrutura da plataforma */void emu_shutdown_all_components(void *platform){    // Verificações de parâmetros    if (platform == NULL)    {        emu_log(EMU_LOG_ERROR, "Plataforma não pode ser nula");        return;    }    // Obter estrutura interna    emu_platform_components_t *components = (emu_platform_components_t *)platform;    // Finalizar todos os componentes (em ordem inversa)    for (int i = EMU_COMPONENT_COUNT - 1; i >= 0; i--)    {        if (components->components[i].interface != NULL && components->components[i].initialized)        {            emu_component_interface_t *interface =                (emu_component_interface_t *)components->components[i].interface;            if (interface->shutdown != NULL)            {                interface->shutdown(components->components[i].context);                components->components[i].initialized = 0;                emu_log(EMU_LOG_INFO, "Componente %s finalizado com sucesso",                        component_type_to_string(i));            }        }    }}/** * @brief Reinicia todos os componentes registrados * * @param platform Ponteiro para a estrutura da plataforma */void emu_reset_all_components(void *platform){    // Verificações de parâmetros    if (platform == NULL)    {        emu_log(EMU_LOG_ERROR, "Plataforma não pode ser nula");        return;    }    // Obter estrutura interna    emu_platform_components_t *components = (emu_platform_components_t *)platform;    // Reiniciar todos os componentes    for (int i = 0; i < EMU_COMPONENT_COUNT; i++)    {        if (components->components[i].interface != NULL && components->components[i].initialized)        {            emu_component_interface_t *interface =                (emu_component_interface_t *)components->components[i].interface;            if (interface->reset != NULL)            {                interface->reset(components->components[i].context);                emu_log(EMU_LOG_INFO, "Componente %s reiniciado com sucesso",                        component_type_to_string(i));            }        }    }}