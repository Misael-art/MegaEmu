/** * @file save_state.c * @brief Implementação do sistema de save states do emulador */#include "save_state.h"#include "utils/enhanced_log.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>// Definição da categoria de log#define LOG_CAT_SAVE_STATE EMU_LOG_CAT_CORE// Assinatura para identificar arquivos de save state#define SAVE_STATE_SIGNATURE "MEGA_EMU_SAVE"#define SAVE_STATE_SIGNATURE_SIZE 13// Tamanho máximo de campos#define SAVE_STATE_MAX_FIELDS 256// Estrutura para armazenar um snapshot em memóriatypedef struct{    void *data;    uint32_t size;} save_state_snapshot_t;// Implementação concreta do contexto de save statestruct save_state_t{    uint32_t platform_id;    uint32_t rom_crc32;    char rom_name[256];    save_state_metadata_t metadata;    save_state_field_t fields[SAVE_STATE_MAX_FIELDS];    int field_count;    save_state_snapshot_t snapshot;    void (*callback)(void *user_data);    void *callback_user_data;};/** * @brief Calcula o CRC32 de um buffer de dados * * @param data Ponteiro para os dados * @param size Tamanho em bytes * @return uint32_t Valor do CRC32 */static uint32_t calculate_crc32(const void *data, size_t size){    // Implementação simples de CRC32    // Em uma versão real, usaríamos uma biblioteca ou implementação mais eficiente    uint32_t crc = 0xFFFFFFFF;    const uint8_t *bytes = (const uint8_t *)data;    static const uint32_t crc_table[256] = {        // Tabela de CRC32 - na implementação real incluiríamos todos os valores        0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,        0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,        0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,        0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,        // ... (valores omitidos para brevidade)    };    for (size_t i = 0; i < size; i++)    {        crc = crc_table[(crc ^ bytes[i]) & 0xFF] ^ (crc >> 8);    }    return ~crc;}/** * @brief Verifica se existe um campo com o nome especificado * * @param state Ponteiro para o contexto * @param name Nome do campo * @return int Índice do campo ou -1 se não encontrado */static int find_field_index(save_state_t *state, const char *name){    for (int i = 0; i < state->field_count; i++)    {        if (strcmp(state->fields[i].name, name) == 0)        {            return i;        }    }    return -1;}save_state_t *save_state_create(    uint32_t platform_id,    uint32_t rom_crc32,    const char *rom_name){    save_state_t *state = (save_state_t *)malloc(sizeof(save_state_t));    if (!state)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao alocar memória para save state");        return NULL;    }    // Inicializa a estrutura    memset(state, 0, sizeof(save_state_t));    state->platform_id = platform_id;    state->rom_crc32 = rom_crc32;    if (rom_name)    {        strncpy(state->rom_name, rom_name, sizeof(state->rom_name) - 1);        state->rom_name[sizeof(state->rom_name) - 1] = '\0';    }    // Inicializa os metadados    state->metadata.version = SAVE_STATE_VERSION;    state->metadata.platform_id = platform_id;    state->metadata.rom_crc32 = rom_crc32;    if (rom_name)    {        strncpy(state->metadata.rom_name, rom_name, sizeof(state->metadata.rom_name) - 1);        state->metadata.rom_name[sizeof(state->metadata.rom_name) - 1] = '\0';    }    state->metadata.timestamp = (uint64_t)time(NULL);    state->metadata.emulator_version = 0x00010000; // Versão 1.0.0    LOG_INFO(LOG_CAT_SAVE_STATE, "Contexto de save state criado para plataforma %u, ROM CRC32 %08X",             platform_id, rom_crc32);    return state;}void save_state_destroy(save_state_t *state){    if (!state)    {        return;    }    // Libera o snapshot se existir    if (state->snapshot.data)    {        free(state->snapshot.data);        state->snapshot.data = NULL;    }    // Libera a estrutura principal    free(state);    LOG_INFO(LOG_CAT_SAVE_STATE, "Contexto de save state liberado");}int save_state_add_field(    save_state_t *state,    const char *name,    save_state_type_t type,    void *data,    uint32_t size){    if (!state || !name || !data || size == 0)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Parâmetros inválidos para adicionar campo");        return SAVE_STATE_ERROR_INVALID;    }    // Verifica se já existe um campo com este nome    if (find_field_index(state, name) >= 0)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Campo '%s' já existe", name);        return SAVE_STATE_ERROR_INVALID;    }    // Verifica se atingiu o limite de campos    if (state->field_count >= SAVE_STATE_MAX_FIELDS)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Limite de campos atingido");        return SAVE_STATE_ERROR_MEMORY;    }    // Adiciona o campo    save_state_field_t *field = &state->fields[state->field_count];    strncpy(field->name, name, sizeof(field->name) - 1);    field->name[sizeof(field->name) - 1] = '\0';    field->type = type;    field->size = size;    field->data = data;    state->field_count++;    LOG_DEBUG(LOG_CAT_SAVE_STATE, "Campo '%s' adicionado, tipo %d, tamanho %u",              name, type, size);    return SAVE_STATE_ERROR_NONE;}int save_state_remove_field(save_state_t *state, const char *name){    if (!state || !name)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Parâmetros inválidos para remover campo");        return SAVE_STATE_ERROR_INVALID;    }    // Procura o campo    int index = find_field_index(state, name);    if (index < 0)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Campo '%s' não encontrado", name);        return SAVE_STATE_ERROR_INVALID;    }    // Remove o campo movendo os campos subsequentes    if (index < state->field_count - 1)    {        memmove(&state->fields[index], &state->fields[index + 1],                (state->field_count - index - 1) * sizeof(save_state_field_t));    }    state->field_count--;    LOG_DEBUG(LOG_CAT_SAVE_STATE, "Campo '%s' removido", name);    return SAVE_STATE_ERROR_NONE;}int save_state_save(    save_state_t *state,    const char *filename,    const char *description){    if (!state || !filename)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Parâmetros inválidos para salvar estado");        return SAVE_STATE_ERROR_INVALID;    }    FILE *file = fopen(filename, "wb");    if (!file)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao abrir arquivo '%s' para escrita", filename);        return SAVE_STATE_ERROR_FILE;    }    // Atualiza os metadados    state->metadata.timestamp = (uint64_t)time(NULL);    if (description)    {        strncpy(state->metadata.description, description, sizeof(state->metadata.description) - 1);        state->metadata.description[sizeof(state->metadata.description) - 1] = '\0';    }    // Escreve a assinatura    if (fwrite(SAVE_STATE_SIGNATURE, 1, SAVE_STATE_SIGNATURE_SIZE, file) != SAVE_STATE_SIGNATURE_SIZE)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao escrever assinatura");        fclose(file);        return SAVE_STATE_ERROR_FILE;    }    // Escreve os metadados    if (fwrite(&state->metadata, sizeof(save_state_metadata_t), 1, file) != 1)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao escrever metadados");        fclose(file);        return SAVE_STATE_ERROR_FILE;    }    // Escreve o número de campos    if (fwrite(&state->field_count, sizeof(int), 1, file) != 1)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao escrever número de campos");        fclose(file);        return SAVE_STATE_ERROR_FILE;    }    // Escreve os campos    for (int i = 0; i < state->field_count; i++)    {        save_state_field_t *field = &state->fields[i];        // Escreve o nome do campo        if (fwrite(field->name, sizeof(field->name), 1, file) != 1)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao escrever nome do campo %d", i);            fclose(file);            return SAVE_STATE_ERROR_FILE;        }        // Escreve o tipo do campo        if (fwrite(&field->type, sizeof(field->type), 1, file) != 1)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao escrever tipo do campo %d", i);            fclose(file);            return SAVE_STATE_ERROR_FILE;        }        // Escreve o tamanho do campo        if (fwrite(&field->size, sizeof(field->size), 1, file) != 1)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao escrever tamanho do campo %d", i);            fclose(file);            return SAVE_STATE_ERROR_FILE;        }        // Escreve os dados do campo        if (fwrite(field->data, 1, field->size, file) != field->size)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao escrever dados do campo %d", i);            fclose(file);            return SAVE_STATE_ERROR_FILE;        }    }    fclose(file);    LOG_INFO(LOG_CAT_SAVE_STATE, "Estado salvo em '%s', %d campos", filename, state->field_count);    // Notifica a alteração    if (state->callback)    {        state->callback(state->callback_user_data);    }    return SAVE_STATE_ERROR_NONE;}int save_state_load(save_state_t *state, const char *filename){    if (!state || !filename)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Parâmetros inválidos para carregar estado");        return SAVE_STATE_ERROR_INVALID;    }    FILE *file = fopen(filename, "rb");    if (!file)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao abrir arquivo '%s' para leitura", filename);        return SAVE_STATE_ERROR_FILE;    }    // Lê e verifica a assinatura    char signature[SAVE_STATE_SIGNATURE_SIZE];    if (fread(signature, 1, SAVE_STATE_SIGNATURE_SIZE, file) != SAVE_STATE_SIGNATURE_SIZE ||        memcmp(signature, SAVE_STATE_SIGNATURE, SAVE_STATE_SIGNATURE_SIZE) != 0)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Assinatura de arquivo inválida");        fclose(file);        return SAVE_STATE_ERROR_INVALID;    }    // Lê os metadados    save_state_metadata_t metadata;    if (fread(&metadata, sizeof(save_state_metadata_t), 1, file) != 1)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao ler metadados");        fclose(file);        return SAVE_STATE_ERROR_FILE;    }    // Verifica a versão    if (metadata.version > SAVE_STATE_VERSION)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Versão do save state (%u) maior que a suportada (%u)",                  metadata.version, SAVE_STATE_VERSION);        fclose(file);        return SAVE_STATE_ERROR_VERSION;    }    // Verifica a plataforma e ROM    if (metadata.platform_id != state->platform_id)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Plataforma do save state (%u) difere da atual (%u)",                  metadata.platform_id, state->platform_id);        fclose(file);        return SAVE_STATE_ERROR_INVALID;    }    if (metadata.rom_crc32 != state->rom_crc32)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "CRC32 da ROM do save state (%08X) difere da atual (%08X)",                  metadata.rom_crc32, state->rom_crc32);        fclose(file);        return SAVE_STATE_ERROR_INVALID;    }    // Atualiza os metadados    memcpy(&state->metadata, &metadata, sizeof(save_state_metadata_t));    // Lê o número de campos    int field_count;    if (fread(&field_count, sizeof(int), 1, file) != 1)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao ler número de campos");        fclose(file);        return SAVE_STATE_ERROR_FILE;    }    // Para cada campo    for (int i = 0; i < field_count; i++)    {        char name[32];        save_state_type_t type;        uint32_t size;        // Lê o nome do campo        if (fread(name, sizeof(name), 1, file) != 1)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao ler nome do campo %d", i);            fclose(file);            return SAVE_STATE_ERROR_FILE;        }        // Lê o tipo do campo        if (fread(&type, sizeof(type), 1, file) != 1)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao ler tipo do campo %d", i);            fclose(file);            return SAVE_STATE_ERROR_FILE;        }        // Lê o tamanho do campo        if (fread(&size, sizeof(size), 1, file) != 1)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao ler tamanho do campo %d", i);            fclose(file);            return SAVE_STATE_ERROR_FILE;        }        // Procura o campo no estado atual        int field_index = find_field_index(state, name);        if (field_index >= 0)        {            save_state_field_t *field = &state->fields[field_index];            // Verifica o tipo            if (field->type != type)            {                LOG_WARN(LOG_CAT_SAVE_STATE,                         "Tipo do campo '%s' no arquivo (%d) difere do atual (%d)",                         name, type, field->type);            }            // Verifica o tamanho            if (field->size != size)            {                LOG_WARN(LOG_CAT_SAVE_STATE,                         "Tamanho do campo '%s' no arquivo (%u) difere do atual (%u)",                         name, size, field->size);                // Lê no máximo o tamanho do campo atual                size = (size < field->size) ? size : field->size;            }            // Lê os dados do campo            if (fread(field->data, 1, size, file) != size)            {                LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao ler dados do campo %d", i);                fclose(file);                return SAVE_STATE_ERROR_FILE;            }            // Pula bytes restantes se o campo no arquivo for maior            if (size < field->size)            {                fseek(file, field->size - size, SEEK_CUR);            }        }        else        {            // Campo não encontrado, pula os dados            LOG_WARN(LOG_CAT_SAVE_STATE, "Campo '%s' não encontrado no estado atual", name);            fseek(file, size, SEEK_CUR);        }    }    fclose(file);    LOG_INFO(LOG_CAT_SAVE_STATE, "Estado carregado de '%s', %d campos", filename, field_count);    // Notifica a alteração    if (state->callback)    {        state->callback(state->callback_user_data);    }    return SAVE_STATE_ERROR_NONE;}int save_state_get_metadata(    const char *filename,    save_state_metadata_t *metadata){    if (!filename || !metadata)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Parâmetros inválidos para obter metadados");        return SAVE_STATE_ERROR_INVALID;    }    FILE *file = fopen(filename, "rb");    if (!file)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao abrir arquivo '%s' para leitura", filename);        return SAVE_STATE_ERROR_FILE;    }    // Lê e verifica a assinatura    char signature[SAVE_STATE_SIGNATURE_SIZE];    if (fread(signature, 1, SAVE_STATE_SIGNATURE_SIZE, file) != SAVE_STATE_SIGNATURE_SIZE ||        memcmp(signature, SAVE_STATE_SIGNATURE, SAVE_STATE_SIGNATURE_SIZE) != 0)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Assinatura de arquivo inválida");        fclose(file);        return SAVE_STATE_ERROR_INVALID;    }    // Lê os metadados    if (fread(metadata, sizeof(save_state_metadata_t), 1, file) != 1)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao ler metadados");        fclose(file);        return SAVE_STATE_ERROR_FILE;    }    fclose(file);    return SAVE_STATE_ERROR_NONE;}bool save_state_is_valid(    const char *filename,    uint32_t platform_id,    uint32_t rom_crc32){    if (!filename)    {        return false;    }    // Obtém os metadados    save_state_metadata_t metadata;    if (save_state_get_metadata(filename, &metadata) != SAVE_STATE_ERROR_NONE)    {        return false;    }    // Verifica a plataforma e ROM    if (metadata.platform_id != platform_id || metadata.rom_crc32 != rom_crc32)    {        return false;    }    return true;}int save_state_create_snapshot(save_state_t *state){    if (!state)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Parâmetros inválidos para criar snapshot");        return SAVE_STATE_ERROR_INVALID;    }    // Calcula o tamanho total necessário    uint32_t total_size = 0;    for (int i = 0; i < state->field_count; i++)    {        total_size += state->fields[i].size;    }    // Aloca ou realoca o buffer do snapshot    if (state->snapshot.data)    {        void *new_data = realloc(state->snapshot.data, total_size);        if (!new_data)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao realocar memória para snapshot");            return SAVE_STATE_ERROR_MEMORY;        }        state->snapshot.data = new_data;    }    else    {        state->snapshot.data = malloc(total_size);        if (!state->snapshot.data)        {            LOG_ERROR(LOG_CAT_SAVE_STATE, "Falha ao alocar memória para snapshot");            return SAVE_STATE_ERROR_MEMORY;        }    }    // Copia os dados de cada campo    uint8_t *dest = (uint8_t *)state->snapshot.data;    for (int i = 0; i < state->field_count; i++)    {        memcpy(dest, state->fields[i].data, state->fields[i].size);        dest += state->fields[i].size;    }    state->snapshot.size = total_size;    LOG_INFO(LOG_CAT_SAVE_STATE, "Snapshot criado com sucesso, tamanho total %u bytes", total_size);    return SAVE_STATE_ERROR_NONE;}int save_state_restore_snapshot(save_state_t *state){    if (!state || !state->snapshot.data)    {        LOG_ERROR(LOG_CAT_SAVE_STATE, "Nenhum snapshot disponível para restaurar");        return SAVE_STATE_ERROR_INVALID;    }    // Restaura os dados de cada campo    uint8_t *src = (uint8_t *)state->snapshot.data;    for (int i = 0; i < state->field_count; i++)    {        memcpy(state->fields[i].data, src, state->fields[i].size);        src += state->fields[i].size;    }    LOG_INFO(LOG_CAT_SAVE_STATE, "Snapshot restaurado com sucesso");    // Notifica a alteração    if (state->callback)    {        state->callback(state->callback_user_data);    }    return SAVE_STATE_ERROR_NONE;}void save_state_set_callback(    save_state_t *state,    void (*callback)(void *user_data),    void *user_data){    if (!state)    {        return;    }    state->callback = callback;    state->callback_user_data = user_data;}