/** * @file state.c * @brief Implementação do sistema de estado do emulador */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include <zlib.h>#include "state.h"#include "core/cpu/cpu.h"#include "core/memory/memory.h"#include "core/video/video.h"#include "core/audio/audio.h"#include "core/input/input.h"#include "utils/log.h"#define STATE_MAGIC 0x4D454753 // "MEGM"#define STATE_VERSION 1#define MAX_SAVE_SIZE (10 * 1024 * 1024) // 10MB#define CHECKSUM_SEED 0xDEADBEEFtypedef struct{    uint32_t magic;    uint32_t version;    uint32_t platform_id;    uint32_t timestamp;    uint32_t save_size;    uint32_t checksum;    uint8_t reserved[32];} state_header_t;typedef struct{    uint32_t component_id;    uint32_t data_size;    uint32_t checksum;} component_header_t;static uint32_t calculate_checksum(const void *data, size_t size, uint32_t seed){    return crc32(seed, data, size);}int emu_save_state(const char *filename, int slot){    if (!filename || slot < 0 || slot >= MAX_SAVE_SLOTS)    {        LOG_ERROR("Parâmetros inválidos para salvamento de estado");        return -1;    }    // Criar diretório de saves se não existir    if (mkdir("saves", 0777) && errno != EEXIST)    {        LOG_ERROR("Falha ao criar diretório de saves");        return -1;    }    char filepath[256];    snprintf(filepath, sizeof(filepath), "saves/state_%d.sav", slot);    FILE *file = fopen(filepath, "wb");    if (!file)    {        LOG_ERROR("Falha ao abrir arquivo para salvamento: %s", filepath);        return -1;    }    // Preparar cabeçalho    state_header_t header = {        .magic = STATE_MAGIC,        .version = STATE_VERSION,        .platform_id = get_platform_id(),        .timestamp = (uint32_t)time(NULL),        .save_size = 0, // Será atualizado depois        .checksum = 0   // Será calculado depois    };    // Escrever cabeçalho (será atualizado depois)    if (fwrite(&header, sizeof(header), 1, file) != 1)    {        LOG_ERROR("Falha ao escrever cabeçalho do estado");        fclose(file);        return -1;    }    uint32_t total_size = sizeof(header);    uint32_t data_checksum = CHECKSUM_SEED;    // Salvar estado da CPU    cpu_state_t cpu_state;    if (cpu_save_state(&cpu_state) != 0)    {        LOG_ERROR("Falha ao salvar estado da CPU");        fclose(file);        return -1;    }    component_header_t comp_header = {        .component_id = COMPONENT_CPU,        .data_size = sizeof(cpu_state),        .checksum = calculate_checksum(&cpu_state, sizeof(cpu_state), CHECKSUM_SEED)};    if (fwrite(&comp_header, sizeof(comp_header), 1, file) != 1 ||        fwrite(&cpu_state, sizeof(cpu_state), 1, file) != 1)    {        LOG_ERROR("Falha ao escrever estado da CPU");        fclose(file);        return -1;    }    total_size += sizeof(comp_header) + sizeof(cpu_state);    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&cpu_state, sizeof(cpu_state), data_checksum);    // Salvar estado da memória    memory_state_t memory_state;    if (memory_save_state(&memory_state) != 0)    {        LOG_ERROR("Falha ao salvar estado da memória");        fclose(file);        return -1;    }    comp_header.component_id = COMPONENT_MEMORY;    comp_header.data_size = sizeof(memory_state);    comp_header.checksum = calculate_checksum(&memory_state, sizeof(memory_state), CHECKSUM_SEED);    if (fwrite(&comp_header, sizeof(comp_header), 1, file) != 1 ||        fwrite(&memory_state, sizeof(memory_state), 1, file) != 1)    {        LOG_ERROR("Falha ao escrever estado da memória");        fclose(file);        return -1;    }    total_size += sizeof(comp_header) + sizeof(memory_state);    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&memory_state, sizeof(memory_state), data_checksum);    // Salvar estado do vídeo    video_state_t video_state;    if (video_save_state(&video_state) != 0)    {        LOG_ERROR("Falha ao salvar estado do vídeo");        fclose(file);        return -1;    }    comp_header.component_id = COMPONENT_VIDEO;    comp_header.data_size = sizeof(video_state);    comp_header.checksum = calculate_checksum(&video_state, sizeof(video_state), CHECKSUM_SEED);    if (fwrite(&comp_header, sizeof(comp_header), 1, file) != 1 ||        fwrite(&video_state, sizeof(video_state), 1, file) != 1)    {        LOG_ERROR("Falha ao escrever estado do vídeo");        fclose(file);        return -1;    }    total_size += sizeof(comp_header) + sizeof(video_state);    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&video_state, sizeof(video_state), data_checksum);    // Salvar estado do áudio    audio_state_t audio_state;    if (audio_save_state(&audio_state) != 0)    {        LOG_ERROR("Falha ao salvar estado do áudio");        fclose(file);        return -1;    }    comp_header.component_id = COMPONENT_AUDIO;    comp_header.data_size = sizeof(audio_state);    comp_header.checksum = calculate_checksum(&audio_state, sizeof(audio_state), CHECKSUM_SEED);    if (fwrite(&comp_header, sizeof(comp_header), 1, file) != 1 ||        fwrite(&audio_state, sizeof(audio_state), 1, file) != 1)    {        LOG_ERROR("Falha ao escrever estado do áudio");        fclose(file);        return -1;    }    total_size += sizeof(comp_header) + sizeof(audio_state);    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&audio_state, sizeof(audio_state), data_checksum);    // Salvar estado do input    input_state_t input_state;    if (input_save_state(&input_state) != 0)    {        LOG_ERROR("Falha ao salvar estado do input");        fclose(file);        return -1;    }    comp_header.component_id = COMPONENT_INPUT;    comp_header.data_size = sizeof(input_state);    comp_header.checksum = calculate_checksum(&input_state, sizeof(input_state), CHECKSUM_SEED);    if (fwrite(&comp_header, sizeof(comp_header), 1, file) != 1 ||        fwrite(&input_state, sizeof(input_state), 1, file) != 1)    {        LOG_ERROR("Falha ao escrever estado do input");        fclose(file);        return -1;    }    total_size += sizeof(comp_header) + sizeof(input_state);    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&input_state, sizeof(input_state), data_checksum);    // Atualizar cabeçalho com tamanho total e checksum    header.save_size = total_size;    header.checksum = data_checksum;    if (fseek(file, 0, SEEK_SET) != 0 ||        fwrite(&header, sizeof(header), 1, file) != 1)    {        LOG_ERROR("Falha ao atualizar cabeçalho do arquivo de estado");        fclose(file);        return -1;    }    fclose(file);    LOG_INFO("Estado salvo com sucesso em: %s", filepath);    return 0;}int emu_load_state(const char *filename, int slot){    if (!filename || slot < 0 || slot >= MAX_SAVE_SLOTS)    {        LOG_ERROR("Parâmetros inválidos para carregamento de estado");        return -1;    }    char filepath[256];    snprintf(filepath, sizeof(filepath), "saves/state_%d.sav", slot);    FILE *file = fopen(filepath, "rb");    if (!file)    {        LOG_ERROR("Falha ao abrir arquivo de estado: %s", filepath);        return -1;    }    // Ler e verificar cabeçalho    state_header_t header;    if (fread(&header, sizeof(header), 1, file) != 1)    {        LOG_ERROR("Falha ao ler cabeçalho do arquivo de estado");        fclose(file);        return -1;    }    if (header.magic != STATE_MAGIC)    {        LOG_ERROR("Arquivo de estado inválido: magic number incorreto");        fclose(file);        return -1;    }    if (header.version != STATE_VERSION)    {        LOG_ERROR("Versão do arquivo de estado incompatível");        fclose(file);        return -1;    }    if (header.platform_id != get_platform_id())    {        LOG_ERROR("Arquivo de estado de uma plataforma diferente");        fclose(file);        return -1;    }    if (header.save_size > MAX_SAVE_SIZE)    {        LOG_ERROR("Arquivo de estado muito grande");        fclose(file);        return -1;    }    uint32_t data_checksum = CHECKSUM_SEED;    component_header_t comp_header;    // Carregar estado da CPU    if (fread(&comp_header, sizeof(comp_header), 1, file) != 1)    {        LOG_ERROR("Falha ao ler cabeçalho do componente CPU");        fclose(file);        return -1;    }    if (comp_header.component_id != COMPONENT_CPU)    {        LOG_ERROR("Componente CPU não encontrado no arquivo de estado");        fclose(file);        return -1;    }    cpu_state_t cpu_state;    if (fread(&cpu_state, sizeof(cpu_state), 1, file) != 1)    {        LOG_ERROR("Falha ao ler estado da CPU");        fclose(file);        return -1;    }    uint32_t cpu_checksum = calculate_checksum(&cpu_state, sizeof(cpu_state), CHECKSUM_SEED);    if (cpu_checksum != comp_header.checksum)    {        LOG_ERROR("Checksum do estado da CPU inválido");        fclose(file);        return -1;    }    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&cpu_state, sizeof(cpu_state), data_checksum);    // Carregar estado da memória    if (fread(&comp_header, sizeof(comp_header), 1, file) != 1)    {        LOG_ERROR("Falha ao ler cabeçalho do componente memória");        fclose(file);        return -1;    }    if (comp_header.component_id != COMPONENT_MEMORY)    {        LOG_ERROR("Componente memória não encontrado no arquivo de estado");        fclose(file);        return -1;    }    memory_state_t memory_state;    if (fread(&memory_state, sizeof(memory_state), 1, file) != 1)    {        LOG_ERROR("Falha ao ler estado da memória");        fclose(file);        return -1;    }    uint32_t memory_checksum = calculate_checksum(&memory_state, sizeof(memory_state), CHECKSUM_SEED);    if (memory_checksum != comp_header.checksum)    {        LOG_ERROR("Checksum do estado da memória inválido");        fclose(file);        return -1;    }    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&memory_state, sizeof(memory_state), data_checksum);    // Carregar estado do vídeo    if (fread(&comp_header, sizeof(comp_header), 1, file) != 1)    {        LOG_ERROR("Falha ao ler cabeçalho do componente vídeo");        fclose(file);        return -1;    }    if (comp_header.component_id != COMPONENT_VIDEO)    {        LOG_ERROR("Componente vídeo não encontrado no arquivo de estado");        fclose(file);        return -1;    }    video_state_t video_state;    if (fread(&video_state, sizeof(video_state), 1, file) != 1)    {        LOG_ERROR("Falha ao ler estado do vídeo");        fclose(file);        return -1;    }    uint32_t video_checksum = calculate_checksum(&video_state, sizeof(video_state), CHECKSUM_SEED);    if (video_checksum != comp_header.checksum)    {        LOG_ERROR("Checksum do estado do vídeo inválido");        fclose(file);        return -1;    }    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&video_state, sizeof(video_state), data_checksum);    // Carregar estado do áudio    if (fread(&comp_header, sizeof(comp_header), 1, file) != 1)    {        LOG_ERROR("Falha ao ler cabeçalho do componente áudio");        fclose(file);        return -1;    }    if (comp_header.component_id != COMPONENT_AUDIO)    {        LOG_ERROR("Componente áudio não encontrado no arquivo de estado");        fclose(file);        return -1;    }    audio_state_t audio_state;    if (fread(&audio_state, sizeof(audio_state), 1, file) != 1)    {        LOG_ERROR("Falha ao ler estado do áudio");        fclose(file);        return -1;    }    uint32_t audio_checksum = calculate_checksum(&audio_state, sizeof(audio_state), CHECKSUM_SEED);    if (audio_checksum != comp_header.checksum)    {        LOG_ERROR("Checksum do estado do áudio inválido");        fclose(file);        return -1;    }    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&audio_state, sizeof(audio_state), data_checksum);    // Carregar estado do input    if (fread(&comp_header, sizeof(comp_header), 1, file) != 1)    {        LOG_ERROR("Falha ao ler cabeçalho do componente input");        fclose(file);        return -1;    }    if (comp_header.component_id != COMPONENT_INPUT)    {        LOG_ERROR("Componente input não encontrado no arquivo de estado");        fclose(file);        return -1;    }    input_state_t input_state;    if (fread(&input_state, sizeof(input_state), 1, file) != 1)    {        LOG_ERROR("Falha ao ler estado do input");        fclose(file);        return -1;    }    uint32_t input_checksum = calculate_checksum(&input_state, sizeof(input_state), CHECKSUM_SEED);    if (input_checksum != comp_header.checksum)    {        LOG_ERROR("Checksum do estado do input inválido");        fclose(file);        return -1;    }    data_checksum = calculate_checksum(&comp_header, sizeof(comp_header), data_checksum);    data_checksum = calculate_checksum(&input_state, sizeof(input_state), data_checksum);    // Verificar checksum final    if (data_checksum != header.checksum)    {        LOG_ERROR("Checksum do arquivo de estado inválido");        fclose(file);        return -1;    }    fclose(file);    // Aplicar estados carregados    if (cpu_load_state(&cpu_state) != 0 ||        memory_load_state(&memory_state) != 0 ||        video_load_state(&video_state) != 0 ||        audio_load_state(&audio_state) != 0 ||        input_load_state(&input_state) != 0)    {        LOG_ERROR("Falha ao aplicar estados carregados");        return -1;    }    LOG_INFO("Estado carregado com sucesso de: %s", filepath);    return 0;}// Função para salvar o estado da plataformastatic int emu_state_save_state_to_file(const char *filename, const char *description){    return emu_save_state(filename, 0);}// Função para carregar o estado da plataformastatic int emu_state_load_state_from_file(const char *filename){    return emu_load_state(filename, 0);}// Função para criar um snapshot do estado atualstatic int create_snapshot(state_snapshot_t *snapshot){    if (!snapshot)    {        return -1;    }    // Alocar memória para o snapshot    snapshot->data = malloc(MAX_SAVE_SIZE);    if (!snapshot->data)    {        return -1;    }    // Salvar estado em memória    FILE *memfile = fmemopen(snapshot->data, MAX_SAVE_SIZE, "wb");    if (!memfile)    {        free(snapshot->data);        return -1;    }    int result = emu_save_state(memfile, 0);    fclose(memfile);    if (result != 0)    {        free(snapshot->data);        return -1;    }    snapshot->size = ftell(memfile);    snapshot->timestamp = time(NULL);    snapshot->in_use = 1;    return 0;}// Função para restaurar um snapshotstatic int restore_snapshot(const state_snapshot_t *snapshot){    if (!snapshot || !snapshot->data || !snapshot->in_use)    {        return -1;    }    // Carregar estado da memória    FILE *memfile = fmemopen(snapshot->data, snapshot->size, "rb");    if (!memfile)    {        return -1;    }    int result = emu_load_state(memfile, 0);    fclose(memfile);    return result;}// Função para resetar a plataformastatic int reset_platform(void){    // Criar snapshot antes do reset    state_snapshot_t reset_snapshot;    if (create_snapshot(&reset_snapshot) != 0)    {        return -1;    }    // Executar reset    int result = g_state.platform->reset();    // Restaurar snapshot se o reset falhar    if (result != 0)    {        restore_snapshot(&reset_snapshot);    }    free_snapshot(&reset_snapshot);    return result;}// Função para rebobinar o estadostatic int rewind_state(void){    if (!g_state.rewind_enabled || g_state.snapshot_count == 0)    {        return -1;    }    // Encontrar snapshot mais recente    int latest_idx = -1;    uint64_t latest_time = 0;    for (int i = 0; i < EMU_STATE_MAX_SNAPSHOTS; i++)    {        if (g_state.snapshots[i].in_use && g_state.snapshots[i].timestamp > latest_time)        {            latest_time = g_state.snapshots[i].timestamp;            latest_idx = i;        }    }    if (latest_idx >= 0)    {        return restore_snapshot(&g_state.snapshots[latest_idx]);    }    return -1;}// Funções de snapshotstatic int emu_state_create_snapshot(void){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (!g_state.platform)    {        g_state.last_error = EMU_STATE_ERROR_PLATFORM_NOT_SUPPORTED;        LOG_ERROR("Nenhuma plataforma configurada para o sistema de estado");        return -1;    }    // Encontrar slot livre para snapshot    int slot = -1;    for (int i = 0; i < EMU_STATE_MAX_SNAPSHOTS; i++)    {        if (!g_state.snapshots[i].in_use)        {            slot = i;            break;        }    }    if (slot == -1)    {        // Se não houver slot livre, reutilizar o mais antigo        uint64_t oldest_time = UINT64_MAX;        for (int i = 0; i < EMU_STATE_MAX_SNAPSHOTS; i++)        {            if (g_state.snapshots[i].timestamp < oldest_time)            {                oldest_time = g_state.snapshots[i].timestamp;                slot = i;            }        }        // Liberar o snapshot antigo        free_snapshot(&g_state.snapshots[slot]);    }    // TODO: Implementar criação real do snapshot    // Aqui precisaríamos ter funções na plataforma para obter o estado atual    // Por enquanto, apenas um teste de snapshot com string    const char *test_data = "DADOS DE TESTE DO SNAPSHOT";    size_t data_size = strlen(test_data) + 1;    g_state.snapshots[slot].data = (uint8_t *)malloc(data_size);    if (!g_state.snapshots[slot].data)    {        g_state.last_error = EMU_STATE_ERROR_OUT_OF_MEMORY;        LOG_ERROR("Não foi possível alocar memória para o snapshot");        return -1;    }    memcpy(g_state.snapshots[slot].data, test_data, data_size);    g_state.snapshots[slot].size = data_size;    g_state.snapshots[slot].timestamp = (uint64_t)time(NULL);    g_state.snapshots[slot].in_use = 1;    g_state.snapshots[slot].id = slot;    if (g_state.snapshot_count < EMU_STATE_MAX_SNAPSHOTS)    {        g_state.snapshot_count++;    }    LOG_INFO("Snapshot criado com sucesso (ID: %d)", slot);    return slot;}static int emu_state_restore_snapshot(int snapshot_id){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (snapshot_id < 0 || snapshot_id >= EMU_STATE_MAX_SNAPSHOTS)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("ID de snapshot inválido: %d", snapshot_id);        return -1;    }    if (!g_state.snapshots[snapshot_id].in_use)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Snapshot %d não está em uso", snapshot_id);        return -1;    }    if (!g_state.platform)    {        g_state.last_error = EMU_STATE_ERROR_PLATFORM_NOT_SUPPORTED;        LOG_ERROR("Nenhuma plataforma configurada para o sistema de estado");        return -1;    }    // TODO: Implementar restauração real do snapshot    // Aqui precisaríamos ter funções na plataforma para restaurar o estado    // Por enquanto, apenas um teste de restauração com string    if (g_state.snapshots[snapshot_id].data)    {        char *test_data = (char *)g_state.snapshots[snapshot_id].data;        LOG_DEBUG("Dados de teste do snapshot: %s", test_data);    }    LOG_INFO("Snapshot restaurado com sucesso (ID: %d)", snapshot_id);    return 0;}static int emu_state_delete_snapshot(int snapshot_id){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (snapshot_id < 0 || snapshot_id >= EMU_STATE_MAX_SNAPSHOTS)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("ID de snapshot inválido: %d", snapshot_id);        return -1;    }    if (!g_state.snapshots[snapshot_id].in_use)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Snapshot %d não está em uso", snapshot_id);        return -1;    }    free_snapshot(&g_state.snapshots[snapshot_id]);    // Atualizar contador de snapshots    g_state.snapshot_count--;    if (g_state.snapshot_count < 0)    {        g_state.snapshot_count = 0;    }    LOG_INFO("Snapshot excluído com sucesso (ID: %d)", snapshot_id);    return 0;}static int emu_state_get_snapshot_count(void){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    return g_state.snapshot_count;}// Funções de resetstatic int emu_state_reset(emu_state_type_t reset_type){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (!g_state.platform)    {        g_state.last_error = EMU_STATE_ERROR_PLATFORM_NOT_SUPPORTED;        LOG_ERROR("Nenhuma plataforma configurada para o sistema de estado");        return -1;    }    LOG_INFO("Executando reset do tipo %d", reset_type);    // TODO: Implementar reset real na plataforma    // Aqui precisaríamos ter funções na plataforma para reset    switch (reset_type)    {    case EMU_STATE_TYPE_RESET:        LOG_INFO("Reset do sistema");        break;    case EMU_STATE_TYPE_POWER_CYCLE:        LOG_INFO("Power cycle do sistema");        break;    default:        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Tipo de reset não suportado: %d", reset_type);        return -1;    }    return 0;}static int emu_state_rewind(int frames){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (!g_state.rewind_enabled)    {        g_state.last_error = EMU_STATE_ERROR_NOT_IMPLEMENTED;        LOG_ERROR("Rebobinagem não está habilitada");        return -1;    }    if (!g_state.platform)    {        g_state.last_error = EMU_STATE_ERROR_PLATFORM_NOT_SUPPORTED;        LOG_ERROR("Nenhuma plataforma configurada para o sistema de estado");        return -1;    }    if (frames <= 0)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Número de frames inválido: %d", frames);        return -1;    }    LOG_INFO("Rebobinando %d frames", frames);    // TODO: Implementar rebobinagem real    // Aqui precisaríamos ter um buffer circular de estados    return 0;}// Funções de informaçãostatic int emu_state_get_state_info(int slot, emu_state_info_t *info){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (slot < 0 || slot >= EMU_STATE_MAX_SLOTS)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_SLOT;        LOG_ERROR("Slot de estado inválido: %d", slot);        return -1;    }    if (!info)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Ponteiro de informações inválido");        return -1;    }    if (!g_state.slot_used[slot])    {        g_state.last_error = EMU_STATE_ERROR_FILE_NOT_FOUND;        LOG_ERROR("Slot de estado %d não utilizado", slot);        return -1;    }    // Obter informações do arquivo    return emu_state_get_file_info(g_state.state_files[slot], info);}static int emu_state_get_file_info(const char *filename, emu_state_info_t *info){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (!filename || !info)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Parâmetros inválidos");        return -1;    }    // Abrir arquivo para leitura    FILE *file = fopen(filename, "rb");    if (!file)    {        g_state.last_error = EMU_STATE_ERROR_FILE_NOT_FOUND;        LOG_ERROR("Arquivo de estado não encontrado: %s", filename);        return -1;    }    // Ler e verificar cabeçalho    if (read_header(file, info) != 0)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_FORMAT;        LOG_ERROR("Formato de arquivo de estado inválido");        fclose(file);        return -1;    }    fclose(file);    return 0;}static int emu_state_get_state_slots(int *filled_slots, int max_slots){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (!filled_slots || max_slots <= 0)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Parâmetros inválidos");        return -1;    }    int count = 0;    for (int i = 0; i < EMU_STATE_MAX_SLOTS && count < max_slots; i++)    {        if (g_state.slot_used[i])        {            filled_slots[count++] = i;        }    }    return count;}// Funções de callbackstatic int emu_state_set_progress_callback(emu_state_progress_callback_t callback, void *userdata){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    g_state.progress_callback = callback;    g_state.progress_userdata = userdata;    LOG_INFO("Callback de progresso configurado");    return 0;}static int emu_state_set_rom_verify_callback(emu_state_rom_verify_callback_t callback, void *userdata){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    g_state.rom_verify_callback = callback;    g_state.rom_verify_userdata = userdata;    LOG_INFO("Callback de verificação de ROM configurado");    return 0;}// Funções de configuraçãostatic int emu_state_enable_rewind(int enable){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    g_state.rewind_enabled = enable ? 1 : 0;    LOG_INFO("Rebobinagem %s", enable ? "habilitada" : "desabilitada");    return 0;}static int emu_state_set_rewind_buffer_frames(int frames){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (frames <= 0)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Número de frames inválido: %d", frames);        return -1;    }    g_state.rewind_buffer_frames = frames;    LOG_INFO("Buffer de rebobinagem configurado para %d frames", frames);    return 0;}static int emu_state_set_autosave_interval(int seconds){    if (!g_state.is_initialized)    {        g_state.last_error = EMU_STATE_ERROR_NOT_INITIALIZED;        LOG_ERROR("Sistema de estado não inicializado");        return -1;    }    if (seconds < 0)    {        g_state.last_error = EMU_STATE_ERROR_INVALID_TYPE;        LOG_ERROR("Intervalo de autosave inválido: %d", seconds);        return -1;    }    g_state.autosave_interval = seconds;    LOG_INFO("Intervalo de autosave configurado para %d segundos", seconds);    return 0;}// Funções de utilitáriostatic const char *emu_state_get_error_string(emu_state_error_t error){    switch (error)    {    case EMU_STATE_ERROR_NONE:        return "Sem erro";    case EMU_STATE_ERROR_NOT_INITIALIZED:        return "Sistema de estado não inicializado";    case EMU_STATE_ERROR_INVALID_TYPE:        return "Tipo inválido";    case EMU_STATE_ERROR_INVALID_SLOT:        return "Slot inválido";    case EMU_STATE_ERROR_FILE_NOT_FOUND:        return "Arquivo não encontrado";    case EMU_STATE_ERROR_FILE_ACCESS:        return "Erro de acesso ao arquivo";    case EMU_STATE_ERROR_INVALID_FORMAT:        return "Formato de arquivo inválido";    case EMU_STATE_ERROR_INVALID_VERSION:        return "Versão de arquivo não suportada";    case EMU_STATE_ERROR_OUT_OF_MEMORY:        return "Memória insuficiente";    case EMU_STATE_ERROR_PLATFORM_NOT_SUPPORTED:        return "Plataforma não suportada";    case EMU_STATE_ERROR_DATA_CORRUPTION:        return "Dados corrompidos";    case EMU_STATE_ERROR_NOT_IMPLEMENTED:        return "Funcionalidade não implementada";    default:        return "Erro desconhecido";    }}// Interface do sistema de estadostatic const emu_state_interface_t g_state_interface = {    .init = emu_state_init,    .shutdown = emu_state_shutdown,    .set_platform = emu_state_set_platform,    .save_state = emu_state_save_state,    .load_state = emu_state_load_state,    .save_state_to_file = emu_state_save_state_to_file,    .load_state_from_file = emu_state_load_state_from_file,    .create_snapshot = emu_state_create_snapshot,    .restore_snapshot = emu_state_restore_snapshot,    .delete_snapshot = emu_state_delete_snapshot,    .get_snapshot_count = emu_state_get_snapshot_count,    .reset = emu_state_reset,    .rewind = emu_state_rewind,    .get_state_info = emu_state_get_state_info,    .get_file_info = emu_state_get_file_info,    .get_state_slots = emu_state_get_state_slots,    .set_progress_callback = emu_state_set_progress_callback,    .set_rom_verify_callback = emu_state_set_rom_verify_callback,    .enable_rewind = emu_state_enable_rewind,    .set_rewind_buffer_frames = emu_state_set_rewind_buffer_frames,    .set_autosave_interval = emu_state_set_autosave_interval,    .get_error_string = emu_state_get_error_string};const emu_state_interface_t *emu_state_get_interface(void){    return &g_state_interface;}