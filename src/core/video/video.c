/** * @file video.c * @brief Implementação do sistema de vídeo do emulador */#include <stdio.h>#include <stdlib.h>#include <string.h>#include "video_interface.h"#include "../../utils/error_handling.h"#include "../../utils/enhanced_log.h"#include "../../utils/log_categories.h"/** * @brief Cria uma nova instância de sistema de vídeo * * @return Nova instância de sistema de vídeo ou NULL em caso de erro */emu_video_t emu_video_create(void){    emu_video_t video = (emu_video_t)malloc(sizeof(emu_video_instance_t));    if (!video)    {        EMU_THROW(EMU_ERROR_OUT_OF_MEMORY, "Falha ao alocar estrutura de vídeo");        return NULL;    }    memset(video, 0, sizeof(emu_video_instance_t));    return video;}/** * @brief Destrói uma instância de sistema de vídeo * * @param video Instância a ser destruída */void emu_video_destroy(emu_video_t video){    if (!video)    {        return;    }    if (video->framebuffer)    {        free(video->framebuffer);    }    free(video);}/** * @brief Inicializa um sistema de vídeo * * @param video Instância de sistema de vídeo * @return true em caso de sucesso, false caso contrário */bool emu_video_init(emu_video_t video){    EMU_CHECK_NULL(video, "Instância de vídeo inválida");    if (video->initialized)    {        EMU_THROW(EMU_ERROR_ALREADY_INITIALIZED, "Sistema de vídeo já inicializado");        return false;    }    video->width = EMU_VIDEO_MAX_WIDTH;    video->height = EMU_VIDEO_MAX_HEIGHT;    video->framebuffer = (uint8_t *)malloc(video->width * video->height);    if (!video->framebuffer)    {        EMU_THROW(EMU_ERROR_OUT_OF_MEMORY, "Falha ao alocar framebuffer");        return false;    }    memset(video->framebuffer, 0, video->width * video->height);    video->initialized = true;    EMU_LOG_INFO(EMU_LOG_CAT_VIDEO, "Sistema de vídeo inicializado: %dx%d", video->width, video->height);    return true;}/** * @brief Desliga um sistema de vídeo * * @param video Instância de sistema de vídeo */void emu_video_shutdown(emu_video_t video){    if (!video)    {        return;    }    if (video->framebuffer)    {        free(video->framebuffer);        video->framebuffer = NULL;    }    EMU_LOG_INFO(EMU_LOG_CAT_VIDEO, "Sistema de vídeo desligado");    free(video);}/** * @brief Reseta um sistema de vídeo * * @param video Instância de sistema de vídeo * @return true em caso de sucesso, false caso contrário */bool emu_video_reset(emu_video_t video){    EMU_CHECK_NULL(video, "Instância de vídeo inválida");    if (!video->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Sistema de vídeo não inicializado");        return false;    }    if (video->framebuffer)    {        memset(video->framebuffer, 0, video->width * video->height);    }    video->num_sprites = 0;    video->num_layers = 0;    video->num_palettes = 0;    EMU_LOG_INFO(EMU_LOG_CAT_VIDEO, "Sistema de vídeo resetado");    return true;}/** * @brief Atualiza um sistema de vídeo * * @param video Instância de sistema de vídeo * @return true em caso de sucesso, false caso contrário */bool emu_video_update(emu_video_t video){    EMU_CHECK_NULL(video, "Instância de vídeo inválida");    if (!video->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Sistema de vídeo não inicializado");        return false;    }    EMU_LOG_DEBUG(EMU_LOG_CAT_VIDEO, "Atualizando sistema de vídeo");    return true;}/** * @brief Renderiza um quadro de vídeo * * @param video Instância de sistema de vídeo * @return true em caso de sucesso, false caso contrário */bool emu_video_render_frame(emu_video_t video){    EMU_CHECK_NULL(video, "Instância de vídeo inválida");    if (!video->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Sistema de vídeo não inicializado");        return false;    }    // Usar callback de renderização, se disponível    if (video->render_callback)    {        video->render_callback(video);        return true;    }    // Implementação padrão de renderização    // Limpar framebuffer    if (video->framebuffer)    {        memset(video->framebuffer, 0, video->width * video->height);    }    // Renderizar camadas (do fundo para a frente)    for (int i = 0; i < video->num_layers; i++)    {        if (video->layers[i].visible && video->layers[i].data)        {            // Implementação básica de renderização de camada            // (na prática, seria mais complexo com suporte a paletas, etc.)            // ...        }    }    // Renderizar sprites    for (int i = 0; i < video->num_sprites; i++)    {        if (video->sprites[i].visible && video->sprites[i].data)        {            // Implementação básica de renderização de sprite            // (na prática, seria mais complexo com suporte a paletas, etc.)            // ...        }    }    return true;}/** * @brief Lê um registrador de vídeo * * @param video Instância de sistema de vídeo * @param address Endereço do registrador * @param value Ponteiro para armazenar o valor lido * @return true em caso de sucesso, false caso contrário */bool emu_video_read_register(emu_video_t video, uint16_t address, uint8_t *value){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_NULL(value, "Value pointer is NULL");    // Usar callback de leitura, se disponível    if (video->read_register)    {        *value = video->read_register(video, address);        return true;    }    return false;}/** * @brief Escreve em um registrador de vídeo * * @param video Instância de sistema de vídeo * @param address Endereço do registrador * @param value Valor a ser escrito * @return true em caso de sucesso, false caso contrário */bool emu_video_write_register(emu_video_t video, uint16_t address, uint8_t value){    EMU_CHECK_NULL(video, "Video instance is NULL");    // Usar callback de escrita, se disponível    if (video->write_register)    {        video->write_register(video, address, value);        return true;    }    return false;}/** * @brief Verifica se o quadro atual está completo * * @param video Instância de sistema de vídeo * @return true se o quadro está completo, false caso contrário */bool emu_video_is_frame_complete(emu_video_t video){    EMU_CHECK_NULL(video, "Video instance is NULL");    // Usar callback, se disponível    if (video->is_frame_complete)    {        return video->is_frame_complete(video);    }    // Implementação padrão    // ...    return false;}/** * @brief Lê dados de vídeo * * @param video Instância de sistema de vídeo * @param address Endereço dos dados * @param value Ponteiro para armazenar o valor lido * @return true em caso de sucesso, false caso contrário */bool emu_video_read_data(emu_video_t video, uint16_t address, uint8_t *value){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_NULL(value, "Value pointer is NULL");    // Usar callback de leitura, se disponível    if (video->read_data)    {        *value = video->read_data(video, address);        return true;    }    return false;}/** * @brief Escreve dados de vídeo * * @param video Instância de sistema de vídeo * @param address Endereço dos dados * @param value Valor a ser escrito * @return true em caso de sucesso, false caso contrário */bool emu_video_write_data(emu_video_t video, uint16_t address, uint8_t value){    EMU_CHECK_NULL(video, "Video instance is NULL");    // Usar callback de escrita, se disponível    if (video->write_data)    {        video->write_data(video, address, value);        return true;    }    return false;}/** * @brief Lê o registrador de controle * * @param video Instância de sistema de vídeo * @param value Ponteiro para armazenar o valor lido * @return true em caso de sucesso, false caso contrário */bool emu_video_read_control(emu_video_t video, uint8_t *value){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_NULL(value, "Value pointer is NULL");    // Usar callback de leitura, se disponível    if (video->read_control)    {        *value = video->read_control(video);        return true;    }    return false;}/** * @brief Escreve no registrador de controle * * @param video Instância de sistema de vídeo * @param value Valor a ser escrito * @return true em caso de sucesso, false caso contrário */bool emu_video_write_control(emu_video_t video, uint8_t value){    EMU_CHECK_NULL(video, "Video instance is NULL");    // Usar callback de escrita, se disponível    if (video->write_control)    {        video->write_control(video, value);        return true;    }    return false;}/** * @brief Limpa o framebuffer do sistema de vídeo * * @param video Instância de sistema de vídeo * @return true em caso de sucesso, false caso contrário */bool emu_video_clear_framebuffer(emu_video_t video){    EMU_CHECK_NULL(video, "Instância de vídeo inválida");    if (!video->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Sistema de vídeo não inicializado");    }    if (video->framebuffer)    {        memset(video->framebuffer, 0, video->width * video->height);    }    return true;}/** * @brief Define uma cor na paleta do sistema de vídeo * * @param video Instância de sistema de vídeo * @param palette_index Índice da paleta * @param color_index Índice da cor na paleta * @param color Valor da cor (formato RGBA) * @return true em caso de sucesso, false caso contrário */bool emu_video_set_palette(emu_video_t video, uint8_t palette_index, uint8_t color_index, uint32_t color){    EMU_CHECK_NULL(video, "Instância de vídeo inválida");    if (!video->initialized)    {        EMU_THROW(EMU_ERROR_NOT_INITIALIZED, "Sistema de vídeo não inicializado");    }    if (palette_index >= EMU_VIDEO_MAX_PALETTES)    {        EMU_THROW(EMU_ERROR_OUT_OF_BOUNDS, "Índice de paleta inválido");    }    if (color_index >= EMU_VIDEO_PALETTE_SIZE)    {        EMU_THROW(EMU_ERROR_OUT_OF_BOUNDS, "Índice de cor inválido");    }    video->palettes[palette_index][color_index] = color;    return true;}/** * @brief Adiciona um sprite ao sistema de vídeo * * @param video Instância de sistema de vídeo * @param sprite_index Índice do sprite * @param x Coordenada X * @param y Coordenada Y * @param width Largura do sprite * @param height Altura do sprite * @param data Dados do sprite * @param palette_index Índice da paleta * @return true em caso de sucesso, false caso contrário */bool emu_video_add_sprite(emu_video_t video, uint8_t sprite_index, uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t *data, uint8_t palette_index){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_BOUNDS(sprite_index, EMU_VIDEO_MAX_SPRITES, "Sprite index out of bounds");    EMU_CHECK_BOUNDS(palette_index, EMU_VIDEO_MAX_PALETTES, "Palette index out of bounds");    video_sprite_t *sprite = &video->sprites[sprite_index];    sprite->x = x;    sprite->y = y;    sprite->width = width;    sprite->height = height;    sprite->data = data;    sprite->palette_index = palette_index;    sprite->visible = true;    if (sprite_index >= video->num_sprites)    {        video->num_sprites = sprite_index + 1;    }    return true;}/** * @brief Remove um sprite do sistema de vídeo * * @param video Instância de sistema de vídeo * @param sprite_index Índice do sprite * @return true em caso de sucesso, false caso contrário */bool emu_video_remove_sprite(emu_video_t video, uint8_t sprite_index){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_BOUNDS(sprite_index, EMU_VIDEO_MAX_SPRITES, "Sprite index out of bounds");    video_sprite_t *sprite = &video->sprites[sprite_index];    sprite->visible = false;    // Se for o último sprite, atualizar o contador    if (sprite_index == video->num_sprites - 1)    {        video->num_sprites--;    }    return true;}/** * @brief Atualiza a posição de um sprite * * @param video Instância de sistema de vídeo * @param sprite_index Índice do sprite * @param x Nova coordenada X * @param y Nova coordenada Y * @return true em caso de sucesso, false caso contrário */bool emu_video_update_sprite(emu_video_t video, uint8_t sprite_index, uint16_t x, uint16_t y){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_BOUNDS(sprite_index, EMU_VIDEO_MAX_SPRITES, "Sprite index out of bounds");    video_sprite_t *sprite = &video->sprites[sprite_index];    sprite->x = x;    sprite->y = y;    return true;}/** * @brief Define a visibilidade de um sprite * * @param video Instância de sistema de vídeo * @param sprite_index Índice do sprite * @param visible Flag de visibilidade * @return true em caso de sucesso, false caso contrário */bool emu_video_set_sprite_visibility(emu_video_t video, uint8_t sprite_index, bool visible){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_BOUNDS(sprite_index, EMU_VIDEO_MAX_SPRITES, "Sprite index out of bounds");    video->sprites[sprite_index].visible = visible;    return true;}/** * @brief Adiciona uma camada ao sistema de vídeo * * @param video Instância de sistema de vídeo * @param layer_index Índice da camada * @param width Largura da camada * @param height Altura da camada * @param data Dados da camada * @param palette_index Índice da paleta * @param priority Prioridade da camada * @return true em caso de sucesso, false caso contrário */bool emu_video_add_layer(emu_video_t video, uint8_t layer_index, uint16_t width, uint16_t height, uint8_t *data, uint8_t palette_index, uint8_t priority){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_BOUNDS(layer_index, EMU_VIDEO_MAX_LAYERS, "Layer index out of bounds");    EMU_CHECK_BOUNDS(palette_index, EMU_VIDEO_MAX_PALETTES, "Palette index out of bounds");    video_layer_t *layer = &video->layers[layer_index];    layer->width = width;    layer->height = height;    layer->data = data;    layer->palette_index = palette_index;    layer->priority = priority;    layer->visible = true;    if (layer_index >= video->num_layers)    {        video->num_layers = layer_index + 1;    }    return true;}/** * @brief Remove uma camada do sistema de vídeo * * @param video Instância de sistema de vídeo * @param layer_index Índice da camada * @return true em caso de sucesso, false caso contrário */bool emu_video_remove_layer(emu_video_t video, uint8_t layer_index){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_BOUNDS(layer_index, EMU_VIDEO_MAX_LAYERS, "Layer index out of bounds");    video_layer_t *layer = &video->layers[layer_index];    layer->visible = false;    // Se for a última camada, atualizar o contador    if (layer_index == video->num_layers - 1)    {        video->num_layers--;    }    return true;}/** * @brief Define a visibilidade de uma camada * * @param video Instância de sistema de vídeo * @param layer_index Índice da camada * @param visible Visibilidade * @return true em caso de sucesso, false caso contrário */bool emu_video_set_layer_visibility(emu_video_t video, uint8_t layer_index, bool visible){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_BOUNDS(layer_index, EMU_VIDEO_MAX_LAYERS, "Layer index out of bounds");    video->layers[layer_index].visible = visible;    return true;}/** * @brief Define a prioridade de uma camada * * @param video Instância de sistema de vídeo * @param layer_index Índice da camada * @param priority Prioridade * @return true em caso de sucesso, false caso contrário */bool emu_video_set_layer_priority(emu_video_t video, uint8_t layer_index, uint8_t priority){    EMU_CHECK_NULL(video, "Video instance is NULL");    EMU_CHECK_BOUNDS(layer_index, EMU_VIDEO_MAX_LAYERS, "Layer index out of bounds");    video->layers[layer_index].priority = priority;    return true;}