/** * @file cpu.c * @brief Implementação da CPU do emulador */#include "cpu.h"#include <stdlib.h>#include <string.h>#include "../../utils/error_handling.h"#include <stdint.h>#include <stdbool.h>/* Implementação da CPU Z80 */// Constantes para flags#define FLAG_C  0x01  // Carry#define FLAG_N  0x02  // Add/Subtract#define FLAG_PV 0x04  // Parity/Overflow#define FLAG_H  0x08  // Half Carry#define FLAG_Z  0x40  // Zero#define FLAG_S  0x80  // Sign// Tabelas de paridade (lookup table para otimização)static const uint8_t PARITY_TABLE[256] = {#include "cpu.h"#include <stdlib.h>#include <string.h>#include "../../utils/error_handling.h"/* Implementação da CPU */emu_cpu_t emu_cpu_create(void){    emu_cpu_t cpu = (emu_cpu_t)malloc(sizeof(emu_cpu_instance_t));    if (!cpu)    {        EMU_THROW(EMU_ERROR_OUT_OF_MEMORY, "Falha ao alocar CPU");        return NULL;    }    /* Inicializa os campos */    memset(cpu, 0, sizeof(emu_cpu_instance_t));    return cpu;}void emu_cpu_destroy(emu_cpu_t cpu){    if (!cpu)    {        return;    }    /* Libera a CPU */    free(cpu);}bool emu_cpu_init(emu_cpu_t cpu, emu_memory_t memory){    EMU_CHECK_NULL(cpu, "Ponteiro de CPU inválido");    EMU_CHECK_NULL(memory, "Ponteiro de memória inválido");    cpu->memory = memory;    cpu->initialized = true;    cpu->running = false;    cpu->pc = 0;    return true;}void emu_cpu_shutdown(emu_cpu_t cpu){    if (cpu == NULL)    {        return;    }    /* Nada a fazer aqui */}bool emu_cpu_reset(emu_cpu_t cpu){    EMU_CHECK_NULL(cpu, "Ponteiro de CPU inválido");    EMU_CHECK_ERROR(cpu->initialized, EMU_ERROR_NOT_INITIALIZED, "CPU não inicializada");    cpu->pc = 0;    cpu->running = false;    memset(&cpu->regs, 0, sizeof(z80_regs_t));    // Estado inicial padrão do Z80    cpu->regs.pc = 0x0000;    cpu->regs.sp = 0xFFFF;    cpu->regs.iff1 = false;    cpu->regs.iff2 = false;    cpu->regs.im = 0;    return true;}bool emu_cpu_start(emu_cpu_t cpu){    EMU_CHECK_NULL(cpu, "Ponteiro de CPU inválido");    EMU_CHECK_ERROR(cpu->initialized, EMU_ERROR_NOT_INITIALIZED, "CPU não inicializada");    if (cpu->running)    {        EMU_THROW(EMU_ERROR_INVALID_STATE, "CPU já está em execução");        return false;    }    cpu->running = true;    return true;}bool emu_cpu_stop(emu_cpu_t cpu){    EMU_CHECK_NULL(cpu, "Ponteiro de CPU inválido");    EMU_CHECK_ERROR(cpu->initialized, EMU_ERROR_NOT_INITIALIZED, "CPU não inicializada");    if (!cpu->running)    {        EMU_THROW(EMU_ERROR_INVALID_STATE, "CPU não está em execução");        return false;    }    cpu->running = false;    return true;}bool emu_cpu_step(emu_cpu_t cpu){    EMU_CHECK_NULL(cpu, "Ponteiro de CPU inválido");    EMU_CHECK_ERROR(cpu->initialized, EMU_ERROR_NOT_INITIALIZED, "CPU não inicializada");    if (!cpu->running)    {        EMU_THROW(EMU_ERROR_INVALID_STATE, "CPU não está em execução");        return false;    }    uint32_t instruction = emu_memory_read_32(cpu->memory, cpu->pc);    cpu->pc += 4;    // Decodificar e executar a instrução    emu_cpu_execute_instruction(cpu, instruction);    return true;}void emu_cpu_interrupt(emu_cpu_t cpu, int level){    if (cpu == NULL)    {        return;    }    /* Define o nível de interrupção */    cpu->irq_level = level;}void emu_cpu_nmi(emu_cpu_t cpu){    if (cpu == NULL)    {        return;    }    /* Define o flag de NMI pendente */    cpu->nmi_pending = 1;}void emu_cpu_set_userdata(emu_cpu_t cpu, void *userdata){    if (cpu == NULL)    {        return;    }    /* Define os dados do usuário */    cpu->userdata = userdata;}void *emu_cpu_get_userdata(emu_cpu_t cpu){    if (cpu == NULL)    {        return NULL;    }    /* Retorna os dados do usuário */    return cpu->userdata;}void emu_cpu_get_state(emu_cpu_t cpu, emu_cpu_state_t *state){    if (cpu == NULL || state == NULL)    {        return;    }    /* Copia o estado da CPU */    state->pc = cpu->regs.pc;    state->sp = cpu->regs.sp;    state->af = cpu->regs.af;    state->bc = cpu->regs.bc;    state->de = cpu->regs.de;    state->hl = cpu->regs.hl;    state->i = cpu->regs.i;    state->r = cpu->regs.r;}void emu_cpu_set_state(emu_cpu_t cpu, const emu_cpu_state_t *state){    if (cpu == NULL || state == NULL)    {        return;    }    /* Atualiza o estado da CPU */    cpu->regs.pc = state->pc;    cpu->regs.sp = state->sp;    cpu->regs.af = state->af;    cpu->regs.bc = state->bc;    cpu->regs.de = state->de;    cpu->regs.hl = state->hl;    cpu->regs.i = state->i;    cpu->regs.r = state->r;}int emu_cpu_get_cycles(emu_cpu_t cpu){    if (cpu == NULL)    {        return 0;    }    /* Retorna o número de ciclos */    return cpu->cycles;}bool emu_cpu_get_halted(emu_cpu_t cpu){    if (cpu == NULL)    {        return false;    }    /* Retorna o flag de parada */    return cpu->halted != 0;}int emu_cpu_get_irq_level(emu_cpu_t cpu){    if (cpu == NULL)    {        return 0;    }    /* Retorna o nível de interrupção */    return cpu->irq_level;}bool emu_cpu_get_nmi_pending(emu_cpu_t cpu){    if (cpu == NULL)    {        return false;    }    /* Retorna o flag de NMI pendente */    return cpu->nmi_pending != 0;}void emu_cpu_get_registers(emu_cpu_t cpu, m68k_regs_t *regs){    if (!cpu || !regs)    {        return;    }    /* Copia os registradores */    memcpy(regs, &cpu->regs, sizeof(m68k_regs_t));}void emu_cpu_set_registers(emu_cpu_t cpu, const m68k_regs_t *regs){    if (!cpu || !regs)    {        return;    }    /* Atualiza os registradores */    memcpy(&cpu->regs, regs, sizeof(m68k_regs_t));}uint32_t emu_cpu_fetch_instruction(emu_cpu_t cpu){    uint32_t instruction = emu_memory_read_32(cpu->memory, cpu->pc);    cpu->pc += 4;    return instruction;}uint8_t emu_cpu_read_memory_8(emu_cpu_t cpu, uint32_t address){    return emu_memory_read_8(cpu->memory, address);}bool emu_cpu_run_cycles(emu_cpu_t cpu, int32_t cycles){    EMU_CHECK_NULL(cpu, "Ponteiro de CPU inválido");    EMU_CHECK_ERROR(cpu->initialized, EMU_ERROR_NOT_INITIALIZED, "CPU não inicializada");    EMU_CHECK_ERROR(cycles > 0, EMU_ERROR_INVALID_PARAMETER, "Número de ciclos deve ser maior que zero");    if (!cpu->running)    {        EMU_THROW(EMU_ERROR_INVALID_STATE, "CPU não está em execução");        return false;    }    while (cycles > 0 && !cpu->halted)    {        // Verifica interrupções        if (cpu->nmi_pending)        {            emu_cpu_handle_nmi(cpu);            cycles -= 11; // NMI consome 11 ciclos            continue;        }        // Atualiza o registrador R (refresh)        cpu->regs.r = (cpu->regs.r & 0x80) | ((cpu->regs.r + 1) & 0x7F);        // Busca e executa a instrução        uint8_t opcode = emu_memory_read_8(cpu->memory, cpu->regs.pc++);        int used_cycles = emu_cpu_execute_instruction(cpu, opcode);        cycles -= used_cycles;    }    return true;}bool emu_cpu_run_frame(emu_cpu_t cpu){    EMU_CHECK_NULL(cpu, "Ponteiro de CPU inválido");    EMU_CHECK_ERROR(cpu->initialized, EMU_ERROR_NOT_INITIALIZED, "CPU não inicializada");    if (!cpu->running)    {        EMU_THROW(EMU_ERROR_INVALID_STATE, "CPU não está em execução");        return false;    }    // Z80 roda a 3.58MHz no Master System    // Frames por segundo = 60Hz    // Ciclos por frame = 3580000 / 60 ≈ 59666    const int32_t cycles_per_frame = 59666;    return emu_cpu_run_cycles(cpu, cycles_per_frame);}void emu_cpu_execute_instruction(emu_cpu_t cpu, uint32_t instruction){    if (!cpu)    {        return;    }    // Decodifica a instrução    uint16_t opcode = (instruction >> 16) & 0xFFFF;    uint16_t operands = instruction & 0xFFFF;    // Extrai campos comuns    uint8_t op_mode = (opcode >> 6) & 0x7;    uint8_t reg = opcode & 0x7;    uint8_t size = (opcode >> 6) & 0x3;    // Executa a instrução baseado no opcode    switch (opcode >> 12)    {    case 0x0: // Bit manipulation/MOVEP/Immediate        break;    case 0x1: // Move Byte        break;    case 0x2: // Move Long        break;    case 0x3: // Move Word        break;    case 0x4: // Miscellaneous        break;    case 0x5: // ADDQ/SUBQ/Scc/DBcc/TRAPcc        break;    case 0x6:                            // Bcc/BSR/BRA        if ((opcode & 0xFF00) == 0x6000) // BRA        {            int8_t displacement = (int8_t)(opcode & 0xFF);            cpu->pc += displacement;        }        break;    case 0x7: // MOVEQ        if ((opcode & 0xF100) == 0x7000)        {            int8_t data = (int8_t)(opcode & 0xFF);            uint8_t reg = (opcode >> 9) & 0x7;            cpu->regs.d[reg] = (int32_t)data;        }        break;    case 0x8: // OR/DIV/SBCD        break;    case 0x9: // SUB/SUBX        break;    case 0xA: // (Unassigned)        break;    case 0xB: // CMP/EOR        break;    case 0xC: // AND/MUL/ABCD/EXG        break;    case 0xD: // ADD/ADDX        break;    case 0xE: // Shift/Rotate/Bit Field        break;    case 0xF: // Coprocessor Interface/CPU32 Extensions        break;    }    // Atualiza o contador de ciclos    cpu->cycles += 4; // Ciclos base para instruções simples}void emu_cpu_handle_exception(emu_cpu_t cpu, int32_t vector){    if (!cpu)    {        return;    }    // Salva o contexto atual    uint32_t old_pc = cpu->regs.pc;    uint16_t old_sr = cpu->regs.sr;    // Entra em modo supervisor    cpu->regs.sr |= 0x2000; // Set supervisor bit    // Salva o contexto na pilha do supervisor    cpu->regs.a[7] -= 4;                                      // Decrementa SP    emu_memory_write_32(cpu->memory, cpu->regs.a[7], old_pc); // Salva PC    cpu->regs.a[7] -= 2;                                      // Decrementa SP    emu_memory_write_16(cpu->memory, cpu->regs.a[7], old_sr); // Salva SR    // Carrega o novo PC do vetor de exceção    uint32_t vector_address = vector * 4;    cpu->regs.pc = emu_memory_read_32(cpu->memory, vector_address);    // Atualiza o contador de ciclos (34 ciclos para processar uma exceção)    cpu->cycles += 34;}void emu_cpu_update_flags(emu_cpu_t cpu, uint8_t result, uint8_t src, uint8_t dst){    if (!cpu)    {        return;    }    // Flags do Z80    uint8_t flags = 0;    // Sign flag (S)    if (result & 0x80)    {        flags |= FLAG_S;    }    // Zero flag (Z)    if (result == 0)    {        flags |= FLAG_Z;    }    // Half carry (H)    if ((src & 0x0F) + (dst & 0x0F) > 0x0F)    {        flags |= FLAG_H;    }    // Parity/Overflow (P/V)    if (PARITY_TABLE[result])    {        flags |= FLAG_PV;    }    // N flag é setado em operações de subtração    // Carry flag é setado quando há overflow    cpu->regs.f = flags;}static void emu_cpu_handle_nmi(emu_cpu_t cpu){    if (!cpu)    {        return;    }    cpu->halted = false;    cpu->nmi_pending = false;    cpu->regs.iff1 = false; // Desabilita interrupções    // Salva PC na pilha    cpu->regs.sp -= 2;    emu_memory_write_16(cpu->memory, cpu->regs.sp, cpu->regs.pc);    // Salta para o endereço de NMI (0x0066)    cpu->regs.pc = 0x0066;}

// Estrutura básica da CPU
typedef struct {
    uint16_t pc;    // Program Counter
    uint16_t sp;    // Stack Pointer
    uint8_t a;      // Acumulador
    uint8_t x;      // Registrador X
    uint8_t y;      // Registrador Y
    uint8_t status; // Status Register
} CPU;

// Inicializa a CPU
void cpu_init(CPU* cpu) {
    cpu->pc = 0;
    cpu->sp = 0xFF;
    cpu->a = 0;
    cpu->x = 0;
    cpu->y = 0;
    cpu->status = 0;
}

// Executa um ciclo da CPU
void cpu_step(CPU* cpu) {
    // TODO: Implementar lógica de execução
}

// Reset da CPU
void cpu_reset(CPU* cpu) {
    cpu_init(cpu);
}
