/** * @file events.c * @brief Implementação do sistema de eventos do emulador */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "events_interface.h"#include "../../utils/error_handling.h"#include "../../utils/enhanced_log.h"#define MAX_PENDING_EVENTS 256typedef struct pending_event_s{    event_t event;    struct pending_event_s *next;} pending_event_t;typedef struct event_queue_s{    pending_event_t *head;    pending_event_t *tail;    int size;} event_queue_t;static event_queue_t pending_events = {NULL, NULL, 0};static event_callback_t *callbacks[MAX_EVENT_TYPES] = {NULL};static int num_callbacks[MAX_EVENT_TYPES] = {0};// Estrutura para armazenar callbackstypedef struct{    emu_event_callback_t callback;    void *userdata;    struct callback_node *next;} callback_node_t;// Estrutura do sistema de eventostypedef struct{    callback_node_t *callbacks[EMU_EVENT_MAX];    int is_initialized;    int is_paused;    uint32_t event_count;} emu_events_t;// Instância global do sistema de eventosstatic emu_events_t g_events = {0};// Funções de gerenciamentostatic int emu_events_init(void){    if (g_events.is_initialized)    {        LOG_WARNING("Sistema de eventos já inicializado");        return 0;    }    memset(&g_events, 0, sizeof(emu_events_t));    g_events.is_initialized = 1;    g_events.event_count = 0;    memset(callbacks, 0, sizeof(callbacks));    memset(num_callbacks, 0, sizeof(num_callbacks));    pending_events.head = NULL;    pending_events.tail = NULL;    pending_events.size = 0;    LOG_INFO("Sistema de eventos inicializado");    return 0;}static int emu_events_shutdown(void){    if (!g_events.is_initialized)    {        return 0;    }    // Liberar todos os callbacks    for (int i = 0; i < EMU_EVENT_MAX; i++)    {        callback_node_t *node = g_events.callbacks[i];        while (node)        {            callback_node_t *next = node->next;            free(node);            node = next;        }        g_events.callbacks[i] = NULL;    }    // Liberar eventos pendentes    pending_event_t *current = pending_events.head;    while (current)    {        pending_event_t *next = current->next;        free(current);        current = next;    }    pending_events.head = NULL;    pending_events.tail = NULL;    pending_events.size = 0;    g_events.is_initialized = 0;    LOG_INFO("Sistema de eventos finalizado");    return 0;}static int emu_events_register_callback(emu_event_type_t type, emu_event_callback_t callback, void *userdata){    if (!g_events.is_initialized || !callback || type >= EMU_EVENT_MAX)    {        LOG_ERROR("Parâmetros inválidos para registro de callback");        return -1;    }    callback_node_t *node = (callback_node_t *)malloc(sizeof(callback_node_t));    if (!node)    {        LOG_ERROR("Falha ao alocar memória para callback");        return -1;    }    node->callback = callback;    node->userdata = userdata;    node->next = g_events.callbacks[type];    g_events.callbacks[type] = node;    LOG_DEBUG("Callback registrado para evento %d", type);    return 0;}static int emu_events_unregister_callback(emu_event_type_t type, emu_event_callback_t callback){    if (!g_events.is_initialized || !callback || type >= EMU_EVENT_MAX)    {        LOG_ERROR("Parâmetros inválidos para remoção de callback");        return -1;    }    callback_node_t *node = g_events.callbacks[type];    callback_node_t *prev = NULL;    while (node)    {        if (node->callback == callback)        {            if (prev)            {                prev->next = node->next;            }            else            {                g_events.callbacks[type] = node->next;            }            free(node);            LOG_DEBUG("Callback removido para evento %d", type);            return 0;        }        prev = node;        node = node->next;    }    LOG_WARNING("Callback não encontrado para evento %d", type);    return -1;}// Funções de eventosstatic int emu_events_trigger_event(emu_event_type_t type, void *data, size_t data_size){    if (!g_events.is_initialized || type >= EMU_EVENT_MAX)    {        LOG_ERROR("Parâmetros inválidos para trigger de evento");        return -1;    }    if (g_events.is_paused)    {        return 0;    }    emu_event_t event = {        .type = type,        .timestamp = (uint32_t)time(NULL),        .data = data,        .data_size = data_size};    callback_node_t *node = g_events.callbacks[type];    while (node)    {        node->callback(&event, node->userdata);        node = node->next;    }    g_events.event_count++;    LOG_DEBUG("Evento %d disparado", type);    // Criar novo evento pendente    pending_event_t *pending = malloc(sizeof(pending_event_t));    if (!pending)    {        LOG_ERROR("Falha ao alocar memória para evento pendente");        return -1;    }    // Copiar evento    memcpy(&pending->event, &event, sizeof(event_t));    pending->next = NULL;    // Adicionar à fila    if (pending_events.size >= MAX_PENDING_EVENTS)    {        LOG_ERROR("Fila de eventos cheia");        free(pending);        return -1;    }    if (!pending_events.head)    {        pending_events.head = pending;        pending_events.tail = pending;    }    else    {        pending_events.tail->next = pending;        pending_events.tail = pending;    }    pending_events.size++;    return 0;}static int emu_events_process_events(void){    if (!g_events.is_initialized)    {        LOG_ERROR("Sistema de eventos não inicializado");        return -1;    }    // Processar eventos pendentes    while (pending_events.head)    {        pending_event_t *current = pending_events.head;        event_t *event = &current->event;        // Chamar callbacks registrados        if (callbacks[event->type])        {            for (int i = 0; i < num_callbacks[event->type]; i++)            {                if (callbacks[event->type][i])                {                    callbacks[event->type][i](event);                }            }        }        // Remover evento da fila        pending_events.head = current->next;        if (!pending_events.head)        {            pending_events.tail = NULL;        }        pending_events.size--;        free(current);    }    return 0;}// Funções de controlestatic void emu_events_pause(void){    if (!g_events.is_initialized)    {        return;    }    g_events.is_paused = 1;    LOG_INFO("Sistema de eventos pausado");}static void emu_events_resume(void){    if (!g_events.is_initialized)    {        return;    }    g_events.is_paused = 0;    LOG_INFO("Sistema de eventos retomado");}static void emu_events_reset(void){    if (!g_events.is_initialized)    {        return;    }    // Limpar todos os callbacks    for (int i = 0; i < EMU_EVENT_MAX; i++)    {        callback_node_t *node = g_events.callbacks[i];        while (node)        {            callback_node_t *next = node->next;            free(node);            node = next;        }        g_events.callbacks[i] = NULL;    }    g_events.event_count = 0;    g_events.is_paused = 0;    LOG_INFO("Sistema de eventos resetado");}// Interface do sistema de eventosstatic const emu_events_interface_t g_events_interface = {    .init = emu_events_init,    .shutdown = emu_events_shutdown,    .register_callback = emu_events_register_callback,    .unregister_callback = emu_events_unregister_callback,    .trigger_event = emu_events_trigger_event,    .process_events = emu_events_process_events,    .pause = emu_events_pause,    .resume = emu_events_resume,    .reset = emu_events_reset};const emu_events_interface_t *emu_events_get_interface(void){    return &g_events_interface;}