#include "event_dispatcher.h"// Pool de eventos para reutilizaçãostatic EmuNodeEvent event_pool[MAX_POOLED_EVENTS];static uint32_t pool_index = 0;emu_status_t emu_dispatch_event(EmuNode* source, EmuNodeEvent* event) {    if (!source || !event) return EMU_ERROR_INVALID_PARAM;    // Usar evento do pool se disponível    EmuNodeEvent* pooled_event = &event_pool[pool_index];    memcpy(pooled_event, event, sizeof(EmuNodeEvent));        // Propagação otimizada usando bitmap de interesse    uint32_t interested_nodes = source->event_interest_map[event->type];        while (interested_nodes) {        int node_index = __builtin_ctz(interested_nodes);        EmuNode* target = source->connections[node_index];                if (target && target->enabled) {            emu_node_handle_event(target, pooled_event);        }                interested_nodes &= (interested_nodes - 1);    }        pool_index = (pool_index + 1) % MAX_POOLED_EVENTS;    return EMU_SUCCESS;}