/** * @file config.c * @brief Implementação do sistema de configuração do emulador */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#include "config_interface.h"#include "../../utils/error_handling.h"#include "../../utils/enhanced_log.h"// Estrutura para armazenar uma entrada de configuraçãotypedef struct config_entry{    char *key;    emu_config_value_t value;    struct config_entry *next;} config_entry_t;// Estrutura para armazenar um callback de notificaçãotypedef struct config_callback{    char *key;    emu_config_change_callback_t callback;    void *userdata;    struct config_callback *next;} config_callback_t;// Estrutura do sistema de configuraçãotypedef struct{    config_entry_t *entries;    config_callback_t *callbacks;    int is_initialized;    emu_config_error_t last_error;} emu_config_t;// Instância global do sistema de configuraçãostatic emu_config_t g_config = {0};// Função para liberar uma entrada de configuraçãostatic void free_config_entry(config_entry_t *entry){    if (!entry)    {        return;    }    free(entry->key);    if (entry->value.type == EMU_CONFIG_TYPE_STRING && entry->value.string_value)    {        free(entry->value.string_value);    }    free(entry);}// Função para liberar um callback de notificaçãostatic void free_config_callback(config_callback_t *callback){    if (!callback)    {        return;    }    free(callback->key);    free(callback);}// Funções de gerenciamentostatic int emu_config_init(void){    if (g_config.is_initialized)    {        LOG_WARNING("Sistema de configuração já inicializado");        return 0;    }    memset(&g_config, 0, sizeof(emu_config_t));    g_config.is_initialized = 1;    g_config.last_error = EMU_CONFIG_ERROR_NONE;    LOG_INFO("Sistema de configuração inicializado");    return 0;}static void emu_config_shutdown(void){    if (!g_config.is_initialized)    {        return;    }    // Liberar todas as entradas    config_entry_t *entry = g_config.entries;    while (entry)    {        config_entry_t *next = entry->next;        free_config_entry(entry);        entry = next;    }    g_config.entries = NULL;    // Liberar todos os callbacks    config_callback_t *callback = g_config.callbacks;    while (callback)    {        config_callback_t *next = callback->next;        free_config_callback(callback);        callback = next;    }    g_config.callbacks = NULL;    g_config.is_initialized = 0;    LOG_INFO("Sistema de configuração finalizado");}static int emu_config_load_defaults(void){    if (!g_config.is_initialized)    {        LOG_ERROR("Sistema de configuração não inicializado");        g_config.last_error = EMU_CONFIG_ERROR_NOT_FOUND;        return -1;    }    // Definir configurações padrão    emu_config_set_int("video.width", 640);    emu_config_set_int("video.height", 480);    emu_config_set_bool("video.fullscreen", 0);    emu_config_set_int("audio.sample_rate", 44100);    emu_config_set_int("audio.channels", 2);    emu_config_set_float("audio.volume", 1.0);    emu_config_set_string("paths.roms", "./roms");    emu_config_set_string("paths.saves", "./saves");    emu_config_set_bool("emulation.auto_save", 1);    emu_config_set_int("emulation.speed", 100);    emu_config_set_bool("debug.enabled", 0);    emu_config_set_int("debug.log_level", 2);    LOG_INFO("Configurações padrão carregadas");    return 0;}// Funções auxiliaresstatic config_entry_t *find_entry(const char *key){    if (!key)    {        return NULL;    }    config_entry_t *entry = g_config.entries;    while (entry)    {        if (strcmp(entry->key, key) == 0)        {            return entry;        }        entry = entry->next;    }    return NULL;}static config_entry_t *create_entry(const char *key){    config_entry_t *entry = (config_entry_t *)malloc(sizeof(config_entry_t));    if (!entry)    {        g_config.last_error = EMU_CONFIG_ERROR_OUT_OF_MEMORY;        return NULL;    }    entry->key = strdup(key);    if (!entry->key)    {        free(entry);        g_config.last_error = EMU_CONFIG_ERROR_OUT_OF_MEMORY;        return NULL;    }    memset(&entry->value, 0, sizeof(emu_config_value_t));    entry->next = g_config.entries;    g_config.entries = entry;    return entry;}static void notify_change(const char *key, const emu_config_value_t *value){    if (!key || !value)    {        return;    }    config_callback_t *callback = g_config.callbacks;    while (callback)    {        if (strcmp(callback->key, key) == 0 || strcmp(callback->key, "*") == 0)        {            callback->callback(key, value, callback->userdata);        }        callback = callback->next;    }}// Funções de acessostatic int emu_config_get_int(const char *key, int64_t *value){    if (!g_config.is_initialized || !key || !value)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        g_config.last_error = EMU_CONFIG_ERROR_NOT_FOUND;        return -1;    }    if (entry->value.type != EMU_CONFIG_TYPE_INT)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_TYPE;        return -1;    }    *value = entry->value.int_value;    return 0;}static int emu_config_get_float(const char *key, double *value){    if (!g_config.is_initialized || !key || !value)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        g_config.last_error = EMU_CONFIG_ERROR_NOT_FOUND;        return -1;    }    if (entry->value.type != EMU_CONFIG_TYPE_FLOAT)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_TYPE;        return -1;    }    *value = entry->value.float_value;    return 0;}static int emu_config_get_bool(const char *key, int *value){    if (!g_config.is_initialized || !key || !value)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        g_config.last_error = EMU_CONFIG_ERROR_NOT_FOUND;        return -1;    }    if (entry->value.type != EMU_CONFIG_TYPE_BOOL)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_TYPE;        return -1;    }    *value = entry->value.bool_value;    return 0;}static int emu_config_get_string(const char *key, char *value, size_t max_size){    if (!g_config.is_initialized || !key || !value || max_size == 0)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        g_config.last_error = EMU_CONFIG_ERROR_NOT_FOUND;        return -1;    }    if (entry->value.type != EMU_CONFIG_TYPE_STRING || !entry->value.string_value)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_TYPE;        return -1;    }    strncpy(value, entry->value.string_value, max_size - 1);    value[max_size - 1] = '\0';    return 0;}static int emu_config_get_value(const char *key, emu_config_value_t *value){    if (!g_config.is_initialized || !key || !value)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        g_config.last_error = EMU_CONFIG_ERROR_NOT_FOUND;        return -1;    }    // Copiar o valor mantendo strings    value->type = entry->value.type;    switch (value->type)    {    case EMU_CONFIG_TYPE_INT:        value->int_value = entry->value.int_value;        break;    case EMU_CONFIG_TYPE_FLOAT:        value->float_value = entry->value.float_value;        break;    case EMU_CONFIG_TYPE_BOOL:        value->bool_value = entry->value.bool_value;        break;    case EMU_CONFIG_TYPE_STRING:        if (entry->value.string_value)        {            value->string_value = strdup(entry->value.string_value);            if (!value->string_value)            {                g_config.last_error = EMU_CONFIG_ERROR_OUT_OF_MEMORY;                return -1;            }        }        else        {            value->string_value = NULL;        }        break;    case EMU_CONFIG_TYPE_OBJECT:    case EMU_CONFIG_TYPE_ARRAY:        value->object_value = entry->value.object_value;        value->array_size = entry->value.array_size;        break;    default:        break;    }    return 0;}// Funções de modificaçãostatic int emu_config_set_int(const char *key, int64_t value){    if (!g_config.is_initialized || !key)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        entry = create_entry(key);        if (!entry)        {            return -1;        }    }    else if (entry->value.type == EMU_CONFIG_TYPE_STRING && entry->value.string_value)    {        free(entry->value.string_value);        entry->value.string_value = NULL;    }    entry->value.type = EMU_CONFIG_TYPE_INT;    entry->value.int_value = value;    notify_change(key, &entry->value);    LOG_DEBUG("Configuração '%s' definida para int %" PRId64, key, value);    return 0;}static int emu_config_set_float(const char *key, double value){    if (!g_config.is_initialized || !key)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        entry = create_entry(key);        if (!entry)        {            return -1;        }    }    else if (entry->value.type == EMU_CONFIG_TYPE_STRING && entry->value.string_value)    {        free(entry->value.string_value);        entry->value.string_value = NULL;    }    entry->value.type = EMU_CONFIG_TYPE_FLOAT;    entry->value.float_value = value;    notify_change(key, &entry->value);    LOG_DEBUG("Configuração '%s' definida para float %f", key, value);    return 0;}static int emu_config_set_bool(const char *key, int value){    if (!g_config.is_initialized || !key)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        entry = create_entry(key);        if (!entry)        {            return -1;        }    }    else if (entry->value.type == EMU_CONFIG_TYPE_STRING && entry->value.string_value)    {        free(entry->value.string_value);        entry->value.string_value = NULL;    }    entry->value.type = EMU_CONFIG_TYPE_BOOL;    entry->value.bool_value = value ? 1 : 0;    notify_change(key, &entry->value);    LOG_DEBUG("Configuração '%s' definida para bool %s", key, value ? "true" : "false");    return 0;}static int emu_config_set_string(const char *key, const char *value){    if (!g_config.is_initialized || !key || !value)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_entry_t *entry = find_entry(key);    if (!entry)    {        entry = create_entry(key);        if (!entry)        {            return -1;        }    }    else if (entry->value.type == EMU_CONFIG_TYPE_STRING && entry->value.string_value)    {        free(entry->value.string_value);        entry->value.string_value = NULL;    }    entry->value.type = EMU_CONFIG_TYPE_STRING;    entry->value.string_value = strdup(value);    if (!entry->value.string_value)    {        g_config.last_error = EMU_CONFIG_ERROR_OUT_OF_MEMORY;        return -1;    }    notify_change(key, &entry->value);    LOG_DEBUG("Configuração '%s' definida para string '%s'", key, value);    return 0;}static int emu_config_set_value(const char *key, const emu_config_value_t *value){    if (!g_config.is_initialized || !key || !value)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    switch (value->type)    {    case EMU_CONFIG_TYPE_INT:        return emu_config_set_int(key, value->int_value);    case EMU_CONFIG_TYPE_FLOAT:        return emu_config_set_float(key, value->float_value);    case EMU_CONFIG_TYPE_BOOL:        return emu_config_set_bool(key, value->bool_value);    case EMU_CONFIG_TYPE_STRING:        return emu_config_set_string(key, value->string_value);    default:        g_config.last_error = EMU_CONFIG_ERROR_INVALID_TYPE;        return -1;    }}// Funções de arquivostatic int emu_config_load_from_file(const char *filename){    if (!g_config.is_initialized || !filename)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    FILE *file = fopen(filename, "r");    if (!file)    {        g_config.last_error = EMU_CONFIG_ERROR_FILE_NOT_FOUND;        LOG_ERROR("Não foi possível abrir o arquivo de configuração: %s", filename);        return -1;    }    char line[1024];    int line_number = 0;    while (fgets(line, sizeof(line), file))    {        line_number++;        // Remover espaços em branco no início e fim        char *start = line;        while (isspace(*start))        {            start++;        }        // Ignorar linhas vazias e comentários        if (*start == '\0' || *start == '#' || *start == ';')        {            continue;        }        // Encontrar o separador (=)        char *separator = strchr(start, '=');        if (!separator)        {            LOG_WARNING("Linha %d: formato inválido, ignorando", line_number);            continue;        }        // Dividir a linha em chave e valor        *separator = '\0';        char *key = start;        char *value = separator + 1;        // Remover espaços em branco no fim da chave        char *key_end = separator - 1;        while (key_end >= key && isspace(*key_end))        {            *key_end = '\0';            key_end--;        }        // Remover espaços em branco no início do valor        while (isspace(*value))        {            value++;        }        // Remover espaços em branco no fim do valor        char *value_end = value + strlen(value) - 1;        while (value_end >= value && (isspace(*value_end) || *value_end == '\n' || *value_end == '\r'))        {            *value_end = '\0';            value_end--;        }        // Verificar se o valor é um número inteiro        char *endptr;        int64_t int_value = strtoll(value, &endptr, 0);        if (*endptr == '\0')        {            emu_config_set_int(key, int_value);            continue;        }        // Verificar se o valor é um número de ponto flutuante        double float_value = strtod(value, &endptr);        if (*endptr == '\0')        {            emu_config_set_float(key, float_value);            continue;        }        // Verificar se o valor é um booleano        if (strcmp(value, "true") == 0 || strcmp(value, "yes") == 0 || strcmp(value, "1") == 0)        {            emu_config_set_bool(key, 1);            continue;        }        if (strcmp(value, "false") == 0 || strcmp(value, "no") == 0 || strcmp(value, "0") == 0)        {            emu_config_set_bool(key, 0);            continue;        }        // Tratar como string        emu_config_set_string(key, value);    }    fclose(file);    LOG_INFO("Configurações carregadas de: %s", filename);    return 0;}static int emu_config_save_to_file(const char *filename){    if (!g_config.is_initialized || !filename)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    FILE *file = fopen(filename, "w");    if (!file)    {        g_config.last_error = EMU_CONFIG_ERROR_FILE_ACCESS;        LOG_ERROR("Não foi possível abrir o arquivo para escrita: %s", filename);        return -1;    }    fprintf(file, "# Configuração do Mega_Emu\n");    fprintf(file, "# Gerado automaticamente\n\n");    config_entry_t *entry = g_config.entries;    while (entry)    {        switch (entry->value.type)        {        case EMU_CONFIG_TYPE_INT:            fprintf(file, "%s = %" PRId64 "\n", entry->key, entry->value.int_value);            break;        case EMU_CONFIG_TYPE_FLOAT:            fprintf(file, "%s = %f\n", entry->key, entry->value.float_value);            break;        case EMU_CONFIG_TYPE_BOOL:            fprintf(file, "%s = %s\n", entry->key, entry->value.bool_value ? "true" : "false");            break;        case EMU_CONFIG_TYPE_STRING:            fprintf(file, "%s = %s\n", entry->key, entry->value.string_value ? entry->value.string_value : "");            break;        default:            break;        }        entry = entry->next;    }    fclose(file);    LOG_INFO("Configurações salvas em: %s", filename);    return 0;}// Funções de notificaçãostatic int emu_config_register_change_callback(const char *key, emu_config_change_callback_t callback, void *userdata){    if (!g_config.is_initialized || !key || !callback)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_callback_t *cb = (config_callback_t *)malloc(sizeof(config_callback_t));    if (!cb)    {        g_config.last_error = EMU_CONFIG_ERROR_OUT_OF_MEMORY;        return -1;    }    cb->key = strdup(key);    if (!cb->key)    {        free(cb);        g_config.last_error = EMU_CONFIG_ERROR_OUT_OF_MEMORY;        return -1;    }    cb->callback = callback;    cb->userdata = userdata;    cb->next = g_config.callbacks;    g_config.callbacks = cb;    LOG_DEBUG("Callback registrado para configuração '%s'", key);    return 0;}static int emu_config_unregister_change_callback(const char *key, emu_config_change_callback_t callback){    if (!g_config.is_initialized || !key || !callback)    {        g_config.last_error = EMU_CONFIG_ERROR_INVALID_VALUE;        return -1;    }    config_callback_t *cb = g_config.callbacks;    config_callback_t *prev = NULL;    while (cb)    {        if (strcmp(cb->key, key) == 0 && cb->callback == callback)        {            if (prev)            {                prev->next = cb->next;            }            else            {                g_config.callbacks = cb->next;            }            free_config_callback(cb);            LOG_DEBUG("Callback removido para configuração '%s'", key);            return 0;        }        prev = cb;        cb = cb->next;    }    g_config.last_error = EMU_CONFIG_ERROR_NOT_FOUND;    return -1;}// Funções de utilitáriostatic const char *emu_config_get_error_string(emu_config_error_t error){    switch (error)    {    case EMU_CONFIG_ERROR_NONE:        return "Sem erro";    case EMU_CONFIG_ERROR_NOT_FOUND:        return "Configuração não encontrada";    case EMU_CONFIG_ERROR_INVALID_TYPE:        return "Tipo de configuração inválido";    case EMU_CONFIG_ERROR_INVALID_VALUE:        return "Valor de configuração inválido";    case EMU_CONFIG_ERROR_OUT_OF_MEMORY:        return "Memória insuficiente";    case EMU_CONFIG_ERROR_FILE_NOT_FOUND:        return "Arquivo não encontrado";    case EMU_CONFIG_ERROR_FILE_ACCESS:        return "Erro de acesso ao arquivo";    case EMU_CONFIG_ERROR_PARSE:        return "Erro de análise";    default:        return "Erro desconhecido";    }}// Interface do sistema de configuraçãostatic const emu_config_interface_t g_config_interface = {    .init = emu_config_init,    .shutdown = emu_config_shutdown,    .load_defaults = emu_config_load_defaults,    .get_int = emu_config_get_int,    .get_float = emu_config_get_float,    .get_bool = emu_config_get_bool,    .get_string = emu_config_get_string,    .get_value = emu_config_get_value,    .set_int = emu_config_set_int,    .set_float = emu_config_set_float,    .set_bool = emu_config_set_bool,    .set_string = emu_config_set_string,    .set_value = emu_config_set_value,    .load_from_file = emu_config_load_from_file,    .save_to_file = emu_config_save_to_file,    .register_change_callback = emu_config_register_change_callback,    .unregister_change_callback = emu_config_unregister_change_callback,    .get_error_string = emu_config_get_error_string};const emu_config_interface_t *emu_config_get_interface(void){    return &g_config_interface;}