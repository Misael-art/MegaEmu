/** * @file input_config.h * @brief Interface para configuração de controles em tempo real */#ifndef INPUT_CONFIG_H#define INPUT_CONFIG_H#ifdef __cplusplusextern "C" {#endif#include <stdint.h>#include <stdbool.h>// Códigos de retorno#define INPUT_CONFIG_ERROR_NONE 0#define INPUT_CONFIG_ERROR_INVALID -1#define INPUT_CONFIG_ERROR_DUPLICATE -2#define INPUT_CONFIG_ERROR_NOT_FOUND -3#define INPUT_CONFIG_ERROR_FILE -4// Número máximo de botões por controle#define INPUT_CONFIG_MAX_BUTTONS 32// Número máximo de controles#define INPUT_CONFIG_MAX_CONTROLLERS 4// Tipos de dispositivos de entradatypedef enum{    INPUT_DEVICE_KEYBOARD,    INPUT_DEVICE_JOYSTICK,    INPUT_DEVICE_GAMEPAD,    INPUT_DEVICE_MOUSE,    INPUT_DEVICE_LIGHTGUN,    INPUT_DEVICE_TOUCH} input_device_type_t;// Estrutura para mapeamento de botãotypedef struct{    char name[32];              // Nome do botão (ex: "A", "START", etc.)    input_device_type_t device; // Tipo de dispositivo    int32_t device_id;              // ID do dispositivo (para múltiplos do mesmo tipo)    int32_t code;                   // Código do botão/tecla    int32_t modifier;               // Modificador (Shift, Ctrl, etc.)    bool is_axis;               // Se é um eixo analógico    int32_t axis_direction;         // Direção do eixo (-1 ou 1)    float deadzone;             // Zona morta para eixos analógicos} input_button_mapping_t;// Estrutura para configuração de controletypedef struct{    char name[32];                                            // Nome da configuração    input_button_mapping_t buttons[INPUT_CONFIG_MAX_BUTTONS]; // Mapeamentos dos botões    int32_t num_buttons;                                          // Número de botões mapeados    bool enabled;                                             // Se a configuração está ativa} input_controller_config_t;// Contexto de configuração de entradatypedef struct input_config_t input_config_t;/** * @brief Cria um novo contexto de configuração de entrada * * @return input_config_t* Ponteiro para o contexto ou NULL em caso de erro */input_config_t *input_config_create(void);/** * @brief Libera um contexto de configuração de entrada * * @param config Ponteiro para o contexto */void input_config_destroy(input_config_t *config);/** * @brief Adiciona uma configuração de controle * * @param config Ponteiro para o contexto * @param controller_id ID do controle (0-3) * @param name Nome da configuração * @return int32_t 0 em caso de sucesso, código de erro caso contrário */int32_t input_config_add_controller(    input_config_t *config,    int32_t controller_id,    const char *name);/** * @brief Remove uma configuração de controle * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @return int32_t 0 em caso de sucesso, código de erro caso contrário */int32_t input_config_remove_controller(    input_config_t *config,    int32_t controller_id);/** * @brief Adiciona um mapeamento de botão * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param mapping Estrutura com o mapeamento * @return int32_t 0 em caso de sucesso, código de erro caso contrário */int32_t input_config_add_button_mapping(    input_config_t *config,    int32_t controller_id,    const input_button_mapping_t *mapping);/** * @brief Remove um mapeamento de botão * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param button_name Nome do botão * @return int32_t 0 em caso de sucesso, código de erro caso contrário */int32_t input_config_remove_button_mapping(    input_config_t *config,    int32_t controller_id,    const char *button_name);/** * @brief Obtém a configuração de um controle * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param controller_config Estrutura para receber a configuração * @return int32_t 0 em caso de sucesso, código de erro caso contrário */int32_t input_config_get_controller(    input_config_t *config,    int32_t controller_id,    input_controller_config_t *controller_config);/** * @brief Salva as configurações em um arquivo * * @param config Ponteiro para o contexto * @param filename Nome do arquivo * @return int32_t 0 em caso de sucesso, código de erro caso contrário */int32_t input_config_save(    input_config_t *config,    const char *filename);/** * @brief Carrega configurações de um arquivo * * @param config Ponteiro para o contexto * @param filename Nome do arquivo * @return int32_t 0 em caso de sucesso, código de erro caso contrário */int32_t input_config_load(    input_config_t *config,    const char *filename);/** * @brief Inicia o modo de configuração em tempo real * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param button_name Nome do botão a configurar * @param timeout_ms Tempo limite em milissegundos (0 para sem limite) * @return int32_t 0 em caso de sucesso, código de erro caso contrário */int32_t input_config_start_realtime_config(    input_config_t *config,    int32_t controller_id,    const char *button_name,    int32_t timeout_ms);/** * @brief Cancela o modo de configuração em tempo real * * @param config Ponteiro para o contexto */void input_config_cancel_realtime_config(input_config_t *config);/** * @brief Processa um evento de entrada durante configuração em tempo real * * @param config Ponteiro para o contexto * @param device_type Tipo de dispositivo * @param device_id ID do dispositivo * @param code Código do botão/tecla * @param value Valor do evento * @return int32_t 0 se a configuração foi concluída, 1 se ainda aguarda entrada, código de erro caso contrário */int32_t input_config_process_event(    input_config_t *config,    input_device_type_t device_type,    int32_t device_id,    int32_t code,    float value);/** * @brief Define uma função de callback para notificar mudanças * * @param config Ponteiro para o contexto * @param callback Função de callback * @param user_data Dados de usuário para o callback */void input_config_set_callback(    input_config_t *config,    void (*callback)(int32_t controller_id, const char *button_name, void *user_data),    void *user_data);/** * @brief Processa um evento de entrada e verifica atalhos de save state * * @param config Ponteiro para o contexto * @param device_type Tipo de dispositivo * @param device_id ID do dispositivo * @param code Código do botão/tecla * @param modifier Modificadores (Shift, Ctrl, Alt) * @param pressed 1 se pressionado, 0 se liberado * @return int32_t Número do slot de save state (1-10), valor negativo para carregar (-1 a -10), *             -10 para criar snapshot, -11 para restaurar snapshot, -2 para nenhum atalho */int32_t input_config_check_save_state_shortcuts(    input_config_t *config,    input_device_type_t device_type,    int32_t device_id,    int32_t code,    int32_t modifier,    int32_t pressed);/** * @brief Cria um novo perfil de entrada * * @param config Ponteiro para o contexto * @param name Nome do perfil * @param description Descrição do perfil * @return int32_t ID do perfil ou código de erro negativo */int32_t input_config_create_profile(    input_config_t *config,    const char *name,    const char *description);/** * @brief Carrega um perfil de entrada * * @param config Ponteiro para o contexto * @param profile_id ID do perfil * @return int32_t Código de erro (0 para sucesso) */int32_t input_config_load_profile(    input_config_t *config,    int32_t profile_id);/** * @brief Salva a configuração atual em um perfil * * @param config Ponteiro para o contexto * @param profile_id ID do perfil * @return int32_t Código de erro (0 para sucesso) */int32_t input_config_save_to_profile(    input_config_t *config,    int32_t profile_id);/** * @brief Remove um perfil de entrada * * @param config Ponteiro para o contexto * @param profile_id ID do perfil * @return int32_t Código de erro (0 para sucesso) */int32_t input_config_remove_profile(    input_config_t *config,    int32_t profile_id);/** * @brief Inicia a calibração de um eixo analógico * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @return int32_t Código de erro (0 para sucesso) */int32_t input_config_start_axis_calibration(    input_config_t *config,    int32_t controller_id,    int32_t axis_id);/** * @brief Adiciona uma amostra à calibração de um eixo * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @param value Valor do eixo * @return int32_t Código de erro (0 para sucesso, 1 para calibração concluída) */int32_t input_config_add_axis_sample(    input_config_t *config,    int32_t controller_id,    int32_t axis_id,    float value);/** * @brief Define a zona morta para um eixo * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @param deadzone Valor da zona morta (0.0 a 1.0) * @return int32_t Código de erro (0 para sucesso) */int32_t input_config_set_axis_deadzone(    input_config_t *config,    int32_t controller_id,    int32_t axis_id,    float deadzone);/** * @brief Inverte a direção de um eixo * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @param inverted true para inverter, false para normal * @return int32_t Código de erro (0 para sucesso) */int32_t input_config_set_axis_inverted(    input_config_t *config,    int32_t controller_id,    int32_t axis_id,    bool inverted);/** * @brief Normaliza um valor de eixo aplicando calibração * * @param config Ponteiro para o contexto * @param controller_id ID do controle * @param axis_id ID do eixo * @param raw_value Valor bruto do eixo * @return float Valor normalizado (-1.0 a 1.0) ou 0.0 em caso de erro */float input_config_normalize_axis(    input_config_t *config,    int32_t controller_id,    int32_t axis_id,    float raw_value);/** * @brief Configura suporte a hotplug de controles * * @param config Ponteiro para o contexto * @param enable true para habilitar, false para desabilitar * @param callback Função de callback para eventos de hotplug * @param user_data Dados de usuário para o callback */void input_config_set_hotplug_support(    input_config_t *config,    bool enable,    void (*callback)(int32_t device_id, bool is_connected, void *user_data),    void *user_data);/** * @brief Configura a integração com a interface gráfica * * @param config Ponteiro para o contexto * @param gui_context Contexto da GUI * @param create_callback Função para criar elementos da GUI * @param destroy_callback Função para destruir elementos da GUI * @return int32_t Código de erro (0 para sucesso) */int32_t input_config_set_gui_integration(    input_config_t *config,    void *gui_context,    int32_t (*create_callback)(void *gui_context, input_config_t *config),    void (*destroy_callback)(void *gui_context));/** * @brief Mostra a interface de configuração de controles * * @param config Ponteiro para o contexto * @return int32_t Código de erro (0 para sucesso) */int32_t input_config_show_gui(    input_config_t *config);#endif /* INPUT_CONFIG_H */