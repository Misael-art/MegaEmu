#include <stdint.h>/** * @file audio_system.hpp * @brief Define a classe base para o sistema de áudio * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-10 */#pragma once#include <SDL.h>#include <queue>#include <mutex>#include <vector>#include <stdexcept>namespace MegaEmu{    namespace Audio    {        /**         * @brief Classe que gerencia o sistema de áudio         */        class AudioSystem        {        public:            /**             * @brief Construtor             * @param sampleRate Taxa de amostragem em Hz             * @param channels Número de canais (1 = mono, 2 = estéreo)             * @param samples Tamanho do buffer em amostras             */            AudioSystem(int32_t sampleRate, int32_t channels, int32_t samples)                : deviceId(0), sampleRate(sampleRate), channels(channels), samples(samples), muted(false)            {                SDL_AudioSpec desired, obtained;                desired.freq = sampleRate;                desired.format = AUDIO_S16SYS;                desired.channels = channels;                desired.samples = samples;                desired.callback = audioCallback;                desired.userdata = this;                deviceId = SDL_OpenAudioDevice(nullptr, 0, &desired, &obtained, 0);                if (deviceId == 0)                {                    throw std::runtime_error("Erro ao abrir dispositivo de áudio: " + std::string(SDL_GetError()));                }                // Verificar se obtivemos as especificações desejadas                if (obtained.freq != desired.freq ||                    obtained.format != desired.format ||                    obtained.channels != desired.channels)                {                    SDL_CloseAudioDevice(deviceId);                    throw std::runtime_error("Não foi possível obter as especificações de áudio desejadas");                }                // Iniciar reprodução                SDL_PauseAudioDevice(deviceId, 0);            }            /**             * @brief Destrutor             */            ~AudioSystem()            {                if (deviceId > 0)                {                    SDL_CloseAudioDevice(deviceId);                }            }            /**             * @brief Adiciona amostras ao buffer de áudio             * @param buffer Buffer contendo as amostras             * @param size Tamanho do buffer em bytes             */            void queueSamples(const int16_t *buffer, size_t size)            {                std::lock_guard<std::mutex> lock(mutex);                // Converter buffer para bytes                const uint8_t *byteBuffer = reinterpret_cast<const uint8_t *>(buffer);                audioBuffer.insert(audioBuffer.end(), byteBuffer, byteBuffer + size * sizeof(int16_t));            }            /**             * @brief Limpa o buffer de áudio             */            void clearBuffer()            {                std::lock_guard<std::mutex> lock(mutex);                audioBuffer.clear();            }            /**             * @brief Define se o áudio está mudo             * @param mute true para mutar, false para desmutar             */            void setMuted(bool mute)            {                muted = mute;                SDL_PauseAudioDevice(deviceId, mute ? 1 : 0);            }            /**             * @brief Verifica se o áudio está mudo             * @return true se mudo, false caso contrário             */            bool isMuted() const            {                return muted;            }            /**             * @brief Obtém a taxa de amostragem             * @return Taxa de amostragem em Hz             */            int32_t getSampleRate() const            {                return sampleRate;            }            /**             * @brief Obtém o número de canais             * @return Número de canais             */            int32_t getChannels() const            {                return channels;            }            /**             * @brief Obtém o tamanho do buffer             * @return Tamanho do buffer em amostras             */            int32_t getSamples() const            {                return samples;            }        private:            /**             * @brief Callback chamado pelo SDL para preencher o buffer de áudio             * @param userdata Ponteiro para a instância do AudioSystem             * @param stream Buffer de áudio a ser preenchido             * @param len Tamanho do buffer em bytes             */            static void audioCallback(void *userdata, Uint8 *stream, int32_t len)            {                AudioSystem *audio = static_cast<AudioSystem *>(userdata);                std::lock_guard<std::mutex> lock(audio->mutex);                // Limpar o stream                SDL_memset(stream, 0, len);                if (audio->muted || audio->audioBuffer.empty())                {                    return;                }                // Copiar dados do buffer para o stream                size_t bytesToCopy = std::min(static_cast<size_t>(len), audio->audioBuffer.size());                SDL_memcpy(stream, audio->audioBuffer.data(), bytesToCopy);                // Remover dados copiados do buffer                audio->audioBuffer.erase(                    audio->audioBuffer.begin(),                    audio->audioBuffer.begin() + bytesToCopy);            }            SDL_AudioDeviceID deviceId;       ///< ID do dispositivo de áudio            int32_t sampleRate;                   ///< Taxa de amostragem            int32_t channels;                     ///< Número de canais            int32_t samples;                      ///< Tamanho do buffer            bool muted;                       ///< Flag de mudo            std::mutex mutex;                 ///< Mutex para sincronização            std::vector<uint8_t> audioBuffer; ///< Buffer de áudio        };    } // namespace Audio} // namespace MegaEmu