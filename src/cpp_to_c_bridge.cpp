/** * @file cpp_to_c_bridge.cpp * @brief Arquivo de ponte entre código C++ e C * @author Mega_Emu Team * @version 1.1.0 * @date 2024-03-13 */#include <memory>#include <stdexcept>#include <iostream>#include "core/platform.hpp"#include "core/rom_system.hpp"#include "platforms/megadrive/megadrive.hpp"// Manter um único ponteiro para a plataforma atualstatic std::unique_ptr<MegaEmu::Core::Platform> g_currentPlatform = nullptr;// Implementações de funções C para interoperabilidade com C++extern "C"{    void *emu_platform_create(emu_platform_type_t type)    {        try        {            // Criar uma nova instância da plataforma            g_currentPlatform = MegaEmu::Core::createPlatform(type);            // Inicializar a plataforma            if (g_currentPlatform && !g_currentPlatform->initialize())            {                std::cerr << "Falha ao inicializar a plataforma" << std::endl;                g_currentPlatform.reset();                return nullptr;            }            // Retornar o ponteiro para a plataforma (para uso em funções C)            return g_currentPlatform.get();        }        catch (const std::exception &e)        {            std::cerr << "Erro ao criar plataforma: " << e.what() << std::endl;            g_currentPlatform.reset();            return nullptr;        }    }    void emu_platform_destroy(void *platform)    {        // Verificar se é a plataforma atual        if (g_currentPlatform.get() == platform)        {            g_currentPlatform.reset();        }    }    emu_error_t emu_platform_run_frame(void *platform)    {        try        {            MegaEmu::Core::Platform *plat = static_cast<MegaEmu::Core::Platform *>(platform);            if (!plat)            {                return EMU_ERROR_INVALID_PARAMETER;            }            if (plat->runFrame())            {                return EMU_SUCCESS;            }            else            {                return EMU_ERROR_GENERIC;            }        }        catch (const std::exception &e)        {            std::cerr << "Erro ao executar quadro: " << e.what() << std::endl;            return EMU_ERROR_GENERIC;        }    }    emu_error_t emu_core_init(void)    {        // Inicialização do core        // Nota: As plataformas específicas serão inicializadas separadamente        return EMU_SUCCESS;    }    void emu_core_shutdown(void)    {        // Destruir a plataforma atual        g_currentPlatform.reset();    }    bool emu_core_is_initialized(void)    {        return g_currentPlatform != nullptr;    }    const char *emu_core_get_version(void)    {        static const char *version = "1.0.0";        return version;    }    void emu_core_set_log_level(int level)    {        // Implementar configuração de log    }    emu_error_t emu_core_select_platform(emu_platform_type_t platform_type)    {        void *newPlatform = emu_platform_create(platform_type);        if (!newPlatform)        {            return EMU_ERROR_GENERIC;        }        return EMU_SUCCESS;    }    emu_platform_type_t emu_core_get_current_platform(void)    {        if (!g_currentPlatform)        {            return EMU_PLATFORM_MEGADRIVE; // Default        }        return MegaEmu::Core::Platform::platformNameToType(g_currentPlatform->getPlatformName());    }    emu_error_t emu_core_load_rom(const char *filename)    {        if (!g_currentPlatform || !filename)        {            return EMU_ERROR_INVALID_PARAMETER;        }        try        {            if (g_currentPlatform->loadROM(filename))            {                return EMU_SUCCESS;            }            else            {                return EMU_ERROR_FILE_NOT_FOUND;            }        }        catch (const std::exception &e)        {            std::cerr << "Erro ao carregar ROM: " << e.what() << std::endl;            return EMU_ERROR_GENERIC;        }    }    emu_error_t emu_core_run_frame(void)    {        if (!g_currentPlatform)        {            return EMU_ERROR_NOT_INITIALIZED;        }        return emu_platform_run_frame(g_currentPlatform.get());    }    const uint32_t *emu_core_get_video_buffer(void)    {        if (!g_currentPlatform)        {            return nullptr;        }        return g_currentPlatform->getVideoBuffer();    }    void emu_core_get_screen_dimensions(int *width, int *height)    {        if (!g_currentPlatform || !width || !height)        {            if (width)                *width = 0;            if (height)                *height = 0;            return;        }        *width = g_currentPlatform->getScreenWidth();        *height = g_currentPlatform->getScreenHeight();    }    void emu_core_update_controller(const void *controller_data, int controller_index)    {        if (!g_currentPlatform || !controller_data || controller_index < 0 || controller_index > 3)        {            return;        }        // Converter de void* para ControllerState        const MegaEmu::Core::ControllerState *state =            static_cast<const MegaEmu::Core::ControllerState *>(controller_data);        g_currentPlatform->updateControllerState(controller_index, *state);    }    // Funções de ponte específicas para MegaDrive    void *md_cpp_create(void)    {        try        {            return new MegaEmu::Platforms::MegaDrive();        }        catch (const std::exception &e)        {            std::cerr << "Erro ao criar instância MegaDrive: " << e.what() << std::endl;            return nullptr;        }    }    void md_cpp_destroy(void *instance)    {        if (instance)        {            delete static_cast<MegaEmu::Platforms::MegaDrive *>(instance);        }    }    int md_cpp_initialize(void *instance)    {        if (!instance)        {            return 0;        }        try        {            MegaEmu::Platforms::MegaDrive *md = static_cast<MegaEmu::Platforms::MegaDrive *>(instance);            return md->initialize() ? 1 : 0;        }        catch (const std::exception &e)        {            std::cerr << "Erro ao inicializar MegaDrive: " << e.what() << std::endl;            return 0;        }    }    int md_cpp_load_rom(void *instance, const uint8_t *data, size_t size)    {        if (!instance || !data || size == 0)        {            return 0;        }        try        {            // Criar um arquivo temporário para carregar a ROM            std::string tempFilename = "temp_rom.bin";            std::ofstream file(tempFilename, std::ios::binary);            if (!file)            {                std::cerr << "Erro ao criar arquivo temporário para ROM" << std::endl;                return 0;            }            file.write(reinterpret_cast<const char *>(data), size);            file.close();            // Carregar a ROM            MegaEmu::Platforms::MegaDrive *md = static_cast<MegaEmu::Platforms::MegaDrive *>(instance);            bool result = md->loadROM(tempFilename);            // Remover o arquivo temporário            std::remove(tempFilename.c_str());            return result ? 1 : 0;        }        catch (const std::exception &e)        {            std::cerr << "Erro ao carregar ROM no MegaDrive: " << e.what() << std::endl;            return 0;        }    }    int md_cpp_run_frame(void *instance)    {        if (!instance)        {            return 0;        }        try        {            MegaEmu::Platforms::MegaDrive *md = static_cast<MegaEmu::Platforms::MegaDrive *>(instance);            return md->runFrame() ? 1 : 0;        }        catch (const std::exception &e)        {            std::cerr << "Erro ao executar quadro no MegaDrive: " << e.what() << std::endl;            return 0;        }    }    const uint32_t *md_cpp_get_video_buffer(void *instance)    {        if (!instance)        {            return nullptr;        }        try        {            MegaEmu::Platforms::MegaDrive *md = static_cast<MegaEmu::Platforms::MegaDrive *>(instance);            return md->getVideoBuffer();        }        catch (const std::exception &e)        {            std::cerr << "Erro ao obter buffer de vídeo do MegaDrive: " << e.what() << std::endl;            return nullptr;        }    }    void md_cpp_update_controller(void *instance, const void *controller_state, int controller_index)    {        if (!instance || !controller_state || controller_index < 0 || controller_index > 3)        {            return;        }        try        {            MegaEmu::Platforms::MegaDrive *md = static_cast<MegaEmu::Platforms::MegaDrive *>(instance);            md->updateControllerState(controller_index, *static_cast<const MegaEmu::Core::ControllerState *>(controller_state));        }        catch (const std::exception &e)        {            std::cerr << "Erro ao atualizar estado do controle no MegaDrive: " << e.what() << std::endl;        }    }    int md_cpp_save_state(void *instance, const char *filename)    {        if (!instance || !filename)        {            return 0;        }        try        {            MegaEmu::Platforms::MegaDrive *md = static_cast<MegaEmu::Platforms::MegaDrive *>(instance);            return md->saveState(filename) ? 1 : 0;        }        catch (const std::exception &e)        {            std::cerr << "Erro ao salvar estado do MegaDrive: " << e.what() << std::endl;            return 0;        }    }    int md_cpp_load_state(void *instance, const char *filename)    {        if (!instance || !filename)        {            return 0;        }        try        {            MegaEmu::Platforms::MegaDrive *md = static_cast<MegaEmu::Platforms::MegaDrive *>(instance);            return md->loadState(filename) ? 1 : 0;        }        catch (const std::exception &e)        {            std::cerr << "Erro ao carregar estado do MegaDrive: " << e.what() << std::endl;            return 0;        }    }    // Funções de ponte específicas para NES    void* nes_cpp_create(void)    {        try        {            return new MegaEmu::Platforms::NES();        }        catch (const std::exception& e)        {            std::cerr << "Erro ao criar instância NES: " << e.what() << std::endl;            return nullptr;        }    }    void nes_cpp_destroy(void* instance)    {        if (instance)        {            delete static_cast<MegaEmu::Platforms::NES*>(instance);        }    }    int nes_cpp_initialize(void* instance)    {        if (!instance)        {            return 0;        }        try        {            MegaEmu::Platforms::NES* nes = static_cast<MegaEmu::Platforms::NES*>(instance);            return nes->initialize() ? 1 : 0;        }        catch (const std::exception& e)        {            std::cerr << "Erro ao inicializar NES: " << e.what() << std::endl;            return 0;        }    }    int nes_cpp_load_rom(void* instance, const uint8_t* data, size_t size)    {        if (!instance || !data || size == 0)        {            return 0;        }        try        {            // Criar um arquivo temporário para carregar a ROM            std::string tempFilename = "temp_rom.nes";            std::ofstream file(tempFilename, std::ios::binary);            if (!file)            {                std::cerr << "Erro ao criar arquivo temporário para ROM" << std::endl;                return 0;            }            file.write(reinterpret_cast<const char*>(data), size);            file.close();            // Carregar a ROM            MegaEmu::Platforms::NES* nes = static_cast<MegaEmu::Platforms::NES*>(instance);            bool result = nes->loadROM(tempFilename);            // Remover o arquivo temporário            std::remove(tempFilename.c_str());            return result ? 1 : 0;        }        catch (const std::exception& e)        {            std::cerr << "Erro ao carregar ROM no NES: " << e.what() << std::endl;            return 0;        }    }    int nes_cpp_run_frame(void* instance)    {        if (!instance)        {            return 0;        }        try        {            MegaEmu::Platforms::NES* nes = static_cast<MegaEmu::Platforms::NES*>(instance);            return nes->runFrame() ? 1 : 0;        }        catch (const std::exception& e)        {            std::cerr << "Erro ao executar quadro no NES: " << e.what() << std::endl;            return 0;        }    }    const uint32_t* nes_cpp_get_video_buffer(void* instance)    {        if (!instance)        {            return nullptr;        }        try        {            MegaEmu::Platforms::NES* nes = static_cast<MegaEmu::Platforms::NES*>(instance);            return nes->getVideoBuffer();        }        catch (const std::exception& e)        {            std::cerr << "Erro ao obter buffer de vídeo do NES: " << e.what() << std::endl;            return nullptr;        }    }    void nes_cpp_update_controller(void* instance, const void* controller_state, int controller_index)    {        if (!instance || !controller_state || controller_index < 0 || controller_index > 1)        {            return;        }        try        {            MegaEmu::Platforms::NES* nes = static_cast<MegaEmu::Platforms::NES*>(instance);            nes->updateControllerState(controller_index, *static_cast<const MegaEmu::Core::ControllerState*>(controller_state));        }        catch (const std::exception& e)        {            std::cerr << "Erro ao atualizar estado do controle no NES: " << e.what() << std::endl;        }    }    int nes_cpp_save_state(void* instance, const char* filename)    {        if (!instance || !filename)        {            return 0;        }        try        {            MegaEmu::Platforms::NES* nes = static_cast<MegaEmu::Platforms::NES*>(instance);            return nes->saveState(filename) ? 1 : 0;        }        catch (const std::exception& e)        {            std::cerr << "Erro ao salvar estado do NES: " << e.what() << std::endl;            return 0;        }    }    int nes_cpp_load_state(void* instance, const char* filename)    {        if (!instance || !filename)        {            return 0;        }        try        {            MegaEmu::Platforms::NES* nes = static_cast<MegaEmu::Platforms::NES*>(instance);            return nes->loadState(filename) ? 1 : 0;        }        catch (const std::exception& e)        {            std::cerr << "Erro ao carregar estado do NES: " << e.what() << std::endl;            return 0;        }    }} // extern "C"