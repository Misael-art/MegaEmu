/** * @file vdp.h * @brief Interface para o VDP (Video Display Processor) do Mega Drive * * Este arquivo define a interface para o VDP do Mega Drive/Genesis, * baseado no chip Yamaha YM7101 (VDP). */#ifndef MD_VDP_H#define MD_VDP_H#include <stdint.h>#include <stdbool.h>#include <stdio.h>#include <stdlib.h>#include "core/interfaces/video_interface.h"#ifdef __cplusplusextern "C"{#endif// Define constantes do VDP#define VRAM_SIZE (64 * 1024) // 64KB#define CRAM_SIZE (128)       // 64 * 2 bytes#define VSRAM_SIZE (80)       // 40 * 2 bytes// Constantes para efeitos especiais#define MAX_RASTER_LINES 240#define MAX_H_SCROLL_BUFFER 320// Flags de debug do VDP#define VDP_DEBUG_SHOW_PLANE_A 0x01#define VDP_DEBUG_SHOW_PLANE_B 0x02#define VDP_DEBUG_SHOW_WINDOW 0x04#define VDP_DEBUG_SHOW_SPRITES 0x08#define VDP_DEBUG_SHOW_GRID 0x10#define VDP_DEBUG_SHOW_PRIORITY 0x20#define VDP_DEBUG_SHOW_COLLISION 0x40#define VDP_DEBUG_SHOW_DEBUG_INFO 0x80#define VDP_DEBUG_SCANLINES_MASK 0xFF00 // Máscara para o efeito de scanline (8 bits superiores)    /**     * @brief Registradores do VDP     */    typedef enum    {        VDP_REG_MODE1 = 0x00,       /**< Modo de controle 1 */        VDP_REG_MODE2 = 0x01,       /**< Modo de controle 2 */        VDP_REG_NTBASE = 0x02,      /**< Endereço base da tabela de nomes A */        VDP_REG_NTWINDOW = 0x03,    /**< Endereço base da tabela de nomes janela */        VDP_REG_NTBASEB = 0x04,     /**< Endereço base da tabela de nomes B */        VDP_REG_SATBASE = 0x05,     /**< Endereço base da tabela de atributos de sprite */        VDP_REG_SPRPATBASE = 0x06,  /**< Endereço base dos padrões de sprite */        VDP_REG_BGCOL = 0x07,       /**< Cor de fundo */        VDP_REG_UNUSED1 = 0x08,     /**< Não utilizado */        VDP_REG_UNUSED2 = 0x09,     /**< Não utilizado */        VDP_REG_HRATE = 0x0A,       /**< Taxa de interrupção H */        VDP_REG_MODE3 = 0x0B,       /**< Modo de controle 3 */        VDP_REG_MODE4 = 0x0C,       /**< Modo de controle 4 */        VDP_REG_HSCROLLBASE = 0x0D, /**< Endereço base da tabela de rolagem horizontal */        VDP_REG_UNUSED3 = 0x0E,     /**< Não utilizado */        VDP_REG_AUTOINC = 0x0F,     /**< Auto-incremento de dados */        VDP_REG_SCROLLSIZE = 0x10,  /**< Tamanho da tela de rolagem */        VDP_REG_WINHPOS = 0x11,     /**< Posição horizontal da janela */        VDP_REG_WINVPOS = 0x12,     /**< Posição vertical da janela */        VDP_REG_DMALEN_L = 0x13,    /**< Comprimento DMA (bits inferiores) */        VDP_REG_DMALEN_H = 0x14,    /**< Comprimento DMA (bits superiores) */        VDP_REG_DMASRC_L = 0x15,    /**< Endereço fonte DMA (bits inferiores) */        VDP_REG_DMASRC_M = 0x16,    /**< Endereço fonte DMA (bits do meio) */        VDP_REG_DMASRC_H = 0x17,    /**< Endereço fonte DMA (bits superiores/modo) */        VDP_REG_UNUSED4 = 0x18,     /**< Não utilizado */        VDP_REG_UNUSED5 = 0x19,     /**< Não utilizado */        VDP_REG_UNUSED6 = 0x1A,     /**< Não utilizado */        VDP_REG_UNUSED7 = 0x1B,     /**< Não utilizado */        VDP_REG_UNUSED8 = 0x1C,     /**< Não utilizado */        VDP_REG_UNUSED9 = 0x1D,     /**< Não utilizado */        VDP_REG_UNUSED10 = 0x1E,    /**< Não utilizado */        VDP_REG_UNUSED11 = 0x1F,    /**< Não utilizado */        VDP_REG_COUNT = 0x20        /**< Número total de registradores */    } md_vdp_reg_t;    /**     * @brief Portas de controle do VDP     */    typedef enum    {        VDP_PORT_DATA = 0x00,   /**< Porta de dados (acesso à VRAM/CRAM/VSRAM) */        VDP_PORT_CONTROL = 0x04 /**< Porta de controle (acesso aos registradores) */    } md_vdp_port_t;    /**     * @brief Tipos de DMA do VDP     */    typedef enum    {        VDP_DMA_VRAM_TO_VRAM = 0,    /**< Transferência de VRAM para VRAM */        VDP_DMA_MEMORY_TO_VRAM = 1,  /**< Transferência de memória para VRAM */        VDP_DMA_MEMORY_TO_CRAM = 2,  /**< Transferência de memória para CRAM */        VDP_DMA_MEMORY_TO_VSRAM = 3, /**< Transferência de memória para VSRAM */        VDP_DMA_FILL = 4             /**< Preenchimento de VRAM */    } md_vdp_dma_type_t;    /**     * @brief Tipos de interrupção do VDP     */    typedef enum    {        VDP_INT_VBLANK = 0, /**< Interrupção de início de retrace vertical */        VDP_INT_HBLANK = 1  /**< Interrupção de retrace horizontal */    } md_vdp_int_t;    /**     * @brief Estados de acesso do VDP     */    typedef enum    {        VDP_STATE_IDLE,        VDP_STATE_TRANSFER_1,        VDP_STATE_TRANSFER_2,        VDP_STATE_DMA_PENDING    } md_vdp_access_state_t;    /**     * @brief Códigos de operação do VDP     */    typedef enum    {        VDP_CODE_VRAM_READ = 0x00,        VDP_CODE_VRAM_WRITE = 0x01,        VDP_CODE_CRAM_WRITE = 0x03,        VDP_CODE_VSRAM_READ = 0x04,        VDP_CODE_VSRAM_WRITE = 0x05,        VDP_CODE_INVALID = 0xFF    } md_vdp_code_t;    /**     * @brief Tipo de plano a ser renderizado     */    typedef enum    {        PLANE_A,        PLANE_B,        PLANE_WINDOW    } plane_type_t;    /**     * @brief Estado interno do VDP     */    typedef struct md_vdp_state    {        // Memórias do VDP        uint8_t vram[VRAM_SIZE];        // Video RAM        uint16_t cram[CRAM_SIZE / 2];   // Color RAM (16-bit valores)        uint16_t vsram[VSRAM_SIZE / 2]; // Vertical Scroll RAM (16-bit valores)        // Flag de segurança para inicialização        int32_t is_fully_initialized;        // Registradores        uint8_t registers[VDP_REG_COUNT];        // Estado de acesso        md_vdp_access_state_t state;        uint16_t command_word;        uint16_t transfer_address;        md_vdp_code_t code;        // Estado de DMA        uint8_t dma_enabled;        uint32_t dma_source;        uint16_t dma_length;        md_vdp_dma_type_t dma_type;        // Estado de renderização        uint16_t h_counter;        uint16_t v_counter;        uint8_t frame_complete;        // Estado de interrupções        uint8_t vint_pending;        uint8_t hint_pending;        uint8_t vint_enabled;        uint8_t hint_enabled;        uint8_t hint_counter;        uint8_t hint_value;        // Callback de interrupção        void (*interrupt_callback)(int32_t type, void *userdata);        void *interrupt_userdata;        // Flags de estado interno        int32_t is_initialized;        int32_t is_pal; // Modo PAL (1) ou NTSC (0)        // Cores fixas        uint32_t fixed_colors[16];        // Contadores de temporização        uint32_t mclk_counter;    // Contador de ciclos de MCLK        uint16_t cycles_per_line; // Ciclos por linha        uint16_t lines_per_frame; // Linhas por frame        uint16_t active_lines;    // Linhas ativas por frame        uint16_t active_start;    // Primeira linha ativa        uint16_t screen_height;   // Altura da tela (224 NTSC, 240 PAL)        uint32_t frame_cycles;    // Ciclos por frame        // Flags de debug        uint32_t debug_flags;        // Suporte a modo entrelaçado        int32_t interlace_mode;        int32_t interlace_field; // 0 = par, 1 = ímpar        // Cache para otimização        uint32_t *tile_cache;      // Cache de tiles decodificados        uint8_t *tile_cache_dirty; // Flag para marcar tiles modificados        // Cache de sprites por linha para otimização        struct        {            int32_t count;            int32_t x[80];            int32_t tile_index[80];            int32_t palette[80];            int32_t priority[80];            int32_t size_x[80];            int32_t size_y[80];        } sprite_line_cache[512]; // Suporte a resoluções altas        // Suporte a efeitos raster/linha        struct        {            int32_t enabled;            int32_t h_scroll_per_line;                     // Scroll horizontal por linha            int32_t v_scroll_per_column;                   // Scroll vertical por coluna            uint16_t h_scroll_buffer[MAX_RASTER_LINES];    // Buffer para efeitos de água            uint16_t v_scroll_buffer[MAX_H_SCROLL_BUFFER]; // Buffer para column scroll            uint8_t palette_mods[MAX_RASTER_LINES][64];    // Modificações de paleta por linha            int32_t palette_mod_active[MAX_RASTER_LINES];  // Flag de modificação ativa            int32_t raster_splits[16];                     // Pontos de divisão de raster (mudanças de scroll)            int32_t num_raster_splits;                     // Número de splits de raster        } raster_effects;        // Efeitos avançados        struct        {            int32_t mosaic_enabled;   // Efeito de mosaico            int32_t mosaic_factor_x;  // Fator de mosaico X (1-16)            int32_t mosaic_factor_y;  // Fator de mosaico Y (1-16)            int32_t scanline_enabled; // Efeito de scanline            int32_t scanline_opacity; // Opacidade do efeito de scanline (0-100%)            int32_t crt_curvature;    // Curvatura de tela CRT            int32_t blur_factor;      // Fator de blur (0-100%)            int32_t noise_factor;     // Fator de ruído (0-100%)        } advanced_effects;    } md_vdp_state_t;    /**     * @brief Cria uma interface de vídeo para o VDP do Mega Drive     *     * @return Interface de vídeo preenchida com as funções do VDP     */    emu_video_interface_t md_vdp_get_interface(void);    /**     * @brief Inicializa o estado interno do VDP     *     * @return 0 em caso de sucesso, código de erro caso contrário     */    int32_t md_vdp_init(void);    /**     * @brief Reseta o VDP     */    void md_vdp_reset(void);    /**     * @brief Atualiza o estado do VDP por um número específico de ciclos     *     * @param cycles Número de ciclos a processar     */    void md_vdp_update(int32_t cycles);    /**     * @brief Renderiza um frame completo     *     * @param framebuffer Buffer para renderizar o frame     * @param width Largura do framebuffer     * @param height Altura do framebuffer     */    void md_vdp_render_frame(uint32_t *framebuffer, int32_t width, int32_t height);    /**     * @brief Lê um valor de um registrador do VDP     *     * @param reg Registrador a ser lido     * @return Valor do registrador     */    uint8_t md_vdp_read_register(uint16_t reg);    /**     * @brief Escreve um valor em um registrador do VDP     *     * @param reg Registrador a ser escrito     * @param value Valor a ser escrito     */    void md_vdp_write_register(uint16_t reg, uint8_t value);    /**     * @brief Lê um valor da porta de dados do VDP     *     * @return Valor lido da porta de dados     */    uint16_t md_vdp_read_data(void);    /**     * @brief Escreve um valor na porta de dados do VDP     *     * @param value Valor a ser escrito     */    void md_vdp_write_data(uint16_t value);    /**     * @brief Lê um valor da porta de controle do VDP     *     * @return Valor do status do VDP     */    uint16_t md_vdp_read_control(void);    /**     * @brief Escreve um comando na porta de controle do VDP     *     * @param value Comando a ser escrito     */    void md_vdp_write_control(uint16_t value);    /**     * @brief Verifica se o frame atual foi completado     *     * @return 1 se o frame foi completado, 0 caso contrário     */    int32_t md_vdp_is_frame_complete(void);    /**     * @brief Obtém o contador de linha atual do VDP     *     * @return Valor do contador de linha     */    uint16_t md_vdp_get_line_counter(void);    /**     * @brief Define a função de callback para notificação de interrupções     *     * @param callback Função a ser chamada quando uma interrupção ocorrer     * @param userdata Dados a serem passados para o callback     */    void md_vdp_set_interrupt_callback(void (*callback)(int32_t type, void *userdata), void *userdata);    /**     * @brief Inicia uma transferência DMA     *     * @param type Tipo de transferência DMA     * @param source Endereço fonte     * @param dest Endereço destino     * @param length Número de words (16-bits) a transferir     * @return 0 em caso de sucesso, código de erro caso contrário     */    int32_t md_vdp_start_dma(md_vdp_dma_type_t type, uint32_t source, uint16_t dest, uint16_t length);    /**     * @brief Define o modo de vídeo PAL ou NTSC     *     * @param is_pal 1 para PAL, 0 para NTSC     */    void md_vdp_set_pal_mode(int32_t is_pal);    /**     * @brief Ativa/desativa o modo entrelaçado     *     * @param enable 1 para ativar, 0 para desativar     */    void md_vdp_set_interlace_mode(int32_t enable);    /**     * @brief Define as flags de debug visual     *     * @param flags Combinação de flags VDP_DEBUG_*     */    void md_vdp_set_debug_flags(uint32_t flags);    /**     * @brief Renderiza um frame em modo de debug     *     * @param framebuffer Buffer para renderizar o frame     * @param width Largura do framebuffer     * @param height Altura do framebuffer     */    void md_vdp_render_debug_frame(uint32_t *framebuffer, int32_t width, int32_t height);    /**     * @brief Descarrega um dump da VRAM para um buffer externo     *     * @param buffer Buffer para receber os dados (deve ter tamanho >= VRAM_SIZE)     * @param size Tamanho do buffer     * @return Número de bytes copiados     */    int32_t md_vdp_dump_vram(uint8_t *buffer, int32_t size);    /**     * @brief Descarrega um dump da CRAM para um buffer externo     *     * @param buffer Buffer para receber os dados (deve ter tamanho >= CRAM_SIZE)     * @param size Tamanho do buffer     * @return Número de bytes copiados     */    int32_t md_vdp_dump_cram(uint8_t *buffer, int32_t size);    /**     * @brief Gera uma imagem das paletas de cores atuais     *     * @param buffer Buffer para receber a imagem (formato RGB32)     * @param width Largura do buffer     * @param height Altura do buffer     */    void md_vdp_generate_palette_view(uint32_t *buffer, int32_t width, int32_t height);    /**     * @brief Gera uma imagem do conteúdo da VRAM (visualizador de tiles)     *     * @param buffer Buffer para receber a imagem (formato RGB32)     * @param width Largura do buffer     * @param height Altura do buffer     * @param palette Paleta a utilizar (0-3)     */    void md_vdp_generate_tile_view(uint32_t *buffer, int32_t width, int32_t height, int32_t palette);    /**     * @brief Libera recursos alocados pelo VDP     */    void md_vdp_shutdown(void);    /**     * @brief Ativa/desativa efeitos de scroll por linha (H-scroll)     *     * @param enable 1 para ativar, 0 para desativar     */    void md_vdp_set_h_scroll_per_line(int32_t enable);    /**     * @brief Ativa/desativa efeitos de scroll por coluna (V-scroll)     *     * @param enable 1 para ativar, 0 para desativar     */    void md_vdp_set_v_scroll_per_column(int32_t enable);    /**     * @brief Define o buffer para efeitos de água (H-scroll variável por linha)     *     * @param buffer Buffer contendo os valores de H-scroll por linha     * @param size Tamanho do buffer (número de linhas)     */    void md_vdp_set_water_effect_buffer(uint16_t *buffer, int32_t size);    /**     * @brief Ativa efeito de mosaico     *     * @param factor_x Fator de mosaico no eixo X (1-16)     * @param factor_y Fator de mosaico no eixo Y (1-16)     */    void md_vdp_set_mosaic_effect(int32_t factor_x, int32_t factor_y);    /**     * @brief Ativa efeito de scanline     *     * @param opacity Opacidade das scanlines (0-100%)     */    void md_vdp_set_scanline_effect(int32_t opacity);    /**     * @brief Ativa efeitos de CRT (curvatura, blur, ruído)     *     * @param curvature Curvatura da tela (0-100%)     * @param blur Fator de blur (0-100%)     * @param noise Fator de ruído (0-100%)     */    void md_vdp_set_crt_effects(int32_t curvature, int32_t blur, int32_t noise);    /**     * @brief Define pontos de divisão de raster para mudanças de scroll     *     * @param line_positions Array com as posições de linha para splits     * @param count Número de splits     */    void md_vdp_set_raster_splits(int32_t *line_positions, int32_t count);    /**     * @brief Modifica a paleta para uma linha específica (efeito de raster)     *     * @param line Número da linha     * @param palette_data Novos dados da paleta     * @param start_index Índice inicial na paleta     * @param count Número de cores a modificar     */    void md_vdp_set_line_palette(int32_t line, uint16_t *palette_data, int32_t start_index, int32_t count);    /**     * @brief Define o nível de log do VDP     *     * @param level Nível de log (0-5)     */    void md_vdp_set_log_level(int32_t level);    /**     * @brief Gera um dump da VRAM para um arquivo     *     * @param filename Nome do arquivo para salvar o dump     * @return 1 se bem sucedido, 0 caso contrário     */    int32_t md_vdp_dump_vram_to_file(const char *filename);    /**     * @brief Gera um dump da CRAM para um arquivo     *     * @param filename Nome do arquivo para salvar o dump     * @return 1 se bem sucedido, 0 caso contrário     */    int32_t md_vdp_dump_cram_to_file(const char *filename);    /**     * @brief Gera uma imagem do conteúdo atual do framebuffer     *     * @param filename Nome do arquivo a ser criado     * @param framebuffer Buffer contendo a imagem     * @param width Largura da imagem     * @param height Altura da imagem     * @return 1 se bem sucedido, 0 caso contrário     */    int32_t md_vdp_capture_screen(const char *filename, uint32_t *framebuffer, int32_t width, int32_t height);    /**     * @brief Gera uma imagem de tiles individuais para debugging     *     * @param filename Nome do arquivo a ser criado     * @param start_tile Índice do primeiro tile a ser mostrado     * @param num_tiles Número de tiles a mostrar     * @param palette Paleta a utilizar (0-3)     * @return 1 se bem sucedido, 0 caso contrário     */    int32_t md_vdp_dump_tiles(const char *filename, int32_t start_tile, int32_t num_tiles, int32_t palette);    /**     * @brief Carrega uma ROM e configura o VDP para debugging     *     * @param rom_data Dados da ROM     * @param rom_size Tamanho da ROM     * @return 1 se bem sucedido, 0 caso contrário     */    int32_t md_vdp_debug_load_rom(const uint8_t *rom_data, size_t rom_size);    /**     * @brief Obtém a interface do VDP     * @return Ponteiro para a interface de vídeo     */    emu_video_t md_vdp_get_interface(void);#ifdef __cplusplus}#endif#endif /* MD_VDP_H */