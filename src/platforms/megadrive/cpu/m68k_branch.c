#include "m68k_branch.h"#include <string.h>// Branch predictor globalstatic md_m68k_branch_predictor_t predictor;// Macros para manipulação de endereços#define BTB_INDEX(addr) ((addr >> 2) & (M68K_BTB_SIZE - 1))#define BTB_TAG(addr) (addr >> (2 + __builtin_ctz(M68K_BTB_SIZE)))#define BHT_INDEX(addr, history) (((addr >> 2) ^ history) & (M68K_BHT_SIZE - 1))/** * @brief Inicializa o branch predictor */void md_m68k_init_branch_predictor(void){    memset(&predictor, 0, sizeof(predictor));    predictor.enabled = 1;}/** * @brief Habilita ou desabilita o branch predictor */void md_m68k_enable_branch_predictor(int enable){    if (enable != predictor.enabled)    {        predictor.enabled = enable;        if (enable)        {            md_m68k_clear_branch_history();        }    }}/** * @brief Prediz se um branch será tomado e seu destino * * @param pc Endereço do branch * @param target Ponteiro para armazenar endereço de destino * @return int 1 se branch previsto como tomado, 0 caso contrário */int md_m68k_predict_branch(uint32_t pc, uint32_t *target){    if (!predictor.enabled)    {        return 0;    }    // Buscar entrada na BTB    uint32_t index = BTB_INDEX(pc);    uint32_t tag = BTB_TAG(pc);    md_m68k_btb_entry_t *entry = &predictor.btb[index];    // Verificar hit na BTB    if (entry->valid && entry->tag == tag)    {        // Atualizar LRU        entry->last_access = ++predictor.hits;        // Para branches incondicionais, sempre predizer tomado        if (entry->type == 1)        {            *target = entry->target;            return 1;        }        // Para branches condicionais, consultar BHT        uint32_t bht_index = BHT_INDEX(pc, predictor.global_history);        uint8_t state = predictor.bht[bht_index];        // Predizer com base no estado        if (state >= WEAKLY_TAKEN)        {            *target = entry->target;            return 1;        }    }    return 0;}/** * @brief Atualiza o branch predictor com o resultado real * * @param pc Endereço do branch * @param target Endereço de destino real * @param taken 1 se branch foi tomado, 0 caso contrário */void md_m68k_update_branch_predictor(uint32_t pc, uint32_t target, int taken){    if (!predictor.enabled)    {        return;    }    uint32_t index = BTB_INDEX(pc);    uint32_t tag = BTB_TAG(pc);    md_m68k_btb_entry_t *entry = &predictor.btb[index];    uint32_t bht_index = BHT_INDEX(pc, predictor.global_history);    // Atualizar BTB    if (!entry->valid || entry->tag != tag)    {        // Nova entrada        entry->tag = tag;        entry->target = target;        entry->valid = 1;        entry->type = (target == pc + 4) ? 0 : 1; // 0=condicional, 1=incondicional        entry->state = taken ? WEAKLY_TAKEN : WEAKLY_NOT_TAKEN;    }    else    {        // Entrada existente        entry->target = target;        // Atualizar estado do preditor de 2 bits        uint8_t state = predictor.bht[bht_index];        if (taken)        {            if (state < STRONGLY_TAKEN)                state++;        }        else        {            if (state > STRONGLY_NOT_TAKEN)                state--;        }        predictor.bht[bht_index] = state;    }    // Atualizar história global    predictor.global_history = ((predictor.global_history << 1) | taken) &                               ((1 << M68K_HISTORY_BITS) - 1);    // Atualizar estatísticas    if ((state >= WEAKLY_TAKEN) == taken)    {        predictor.hits++;    }    else    {        predictor.misses++;    }}/** * @brief Obtém estatísticas do branch predictor */void md_m68k_branch_stats(uint32_t *hits, uint32_t *misses){    if (hits)        *hits = predictor.hits;    if (misses)        *misses = predictor.misses;}/** * @brief Limpa o histórico de branches */void md_m68k_clear_branch_history(void){    memset(predictor.btb, 0, sizeof(predictor.btb));    memset(predictor.bht, WEAKLY_NOT_TAKEN, sizeof(predictor.bht));    predictor.global_history = 0;    predictor.hits = 0;    predictor.misses = 0;}