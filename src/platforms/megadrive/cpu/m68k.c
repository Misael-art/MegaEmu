/** * @file m68k.c * @brief Implementação das funções da CPU Motorola 68000 * * Este arquivo contém a implementação das funções de controle, acesso aos * registradores e interação com a memória para a CPU M68K do Mega Drive. */#include "m68k.h"#include "m68k_instructions.h"#include "platforms/megadrive/memory/memory.h"#include <stdio.h>#include <stdlib.h>#include <string.h>/* Estado global da CPU M68K */static md_m68k_state_t m68k_state;/* Instância da interface da CPU */static emu_cpu_instance_t cpu_instance;/* Callbacks para acesso à memória */static uint8_t (*memory_read_8)(uint32_t address) = NULL;static uint16_t (*memory_read_16)(uint32_t address) = NULL;static uint32_t (*memory_read_32)(uint32_t address) = NULL;static void (*memory_write_8)(uint32_t address, uint8_t value) = NULL;static void (*memory_write_16)(uint32_t address, uint16_t value) = NULL;static void (*memory_write_32)(uint32_t address, uint32_t value) = NULL;/* Declarações de funções internas (privadas) */static void m68k_fetch_execute(void);static void m68k_check_interrupts(void);/** * @brief Inicializa a CPU M68K * * @return 0 em caso de sucesso, -1 em caso de erro */int md_m68k_init(void){    // Inicializar o estado da CPU    memset(&m68k_state, 0, sizeof(md_m68k_state_t));    // Inicializar a instância da CPU    memset(&cpu_instance, 0, sizeof(emu_cpu_instance_t));    cpu_instance.initialized = true;    cpu_instance.running = false;    cpu_instance.pc = 0;    // Configurar callbacks de memória    memory_read_8 = md_memory_read_8;    memory_read_16 = md_memory_read_16;    memory_read_32 = md_memory_read_32;    memory_write_8 = md_memory_write_8;    memory_write_16 = md_memory_write_16;    memory_write_32 = md_memory_write_32;    return 0;}/** * @brief Reseta a CPU M68K */void md_m68k_reset(void){    // Resetar os registradores    memset(m68k_state.data_regs, 0, sizeof(m68k_state.data_regs));    memset(m68k_state.addr_regs, 0, sizeof(m68k_state.addr_regs));    // Configurar SP inicial    m68k_state.addr_regs[7] = memory_read_32(0);    // Configurar PC inicial    m68k_state.pc = memory_read_32(4);    // Resetar SR    m68k_state.sr = 0x2700; // Supervisor mode, interrupções desabilitadas    // Resetar estado    m68k_state.halted = 0;    m68k_state.stopped = 0;    m68k_state.cycles = 0;    // Atualizar a instância da CPU    cpu_instance.pc = m68k_state.pc;    cpu_instance.regs.d[0] = m68k_state.data_regs[0];    cpu_instance.regs.d[1] = m68k_state.data_regs[1];    cpu_instance.regs.d[2] = m68k_state.data_regs[2];    cpu_instance.regs.d[3] = m68k_state.data_regs[3];    cpu_instance.regs.d[4] = m68k_state.data_regs[4];    cpu_instance.regs.d[5] = m68k_state.data_regs[5];    cpu_instance.regs.d[6] = m68k_state.data_regs[6];    cpu_instance.regs.d[7] = m68k_state.data_regs[7];    cpu_instance.regs.a[0] = m68k_state.addr_regs[0];    cpu_instance.regs.a[1] = m68k_state.addr_regs[1];    cpu_instance.regs.a[2] = m68k_state.addr_regs[2];    cpu_instance.regs.a[3] = m68k_state.addr_regs[3];    cpu_instance.regs.a[4] = m68k_state.addr_regs[4];    cpu_instance.regs.a[5] = m68k_state.addr_regs[5];    cpu_instance.regs.a[6] = m68k_state.addr_regs[6];    cpu_instance.regs.a[7] = m68k_state.addr_regs[7];    cpu_instance.regs.sr = m68k_state.sr;    cpu_instance.regs.usp = m68k_state.addr_regs[7];    cpu_instance.regs.ssp = m68k_state.addr_regs[7];}/** * @brief Executa um ciclo da CPU * * @return Número de ciclos executados */int md_m68k_step(void){    int cycles_start = m68k_state.cycles;    // Verificar se a CPU está parada    if (m68k_state.halted || m68k_state.stopped)    {        return 0;    }    // Verificar interrupções pendentes    m68k_check_interrupts();    // Buscar e executar a próxima instrução    m68k_fetch_execute();    // Atualizar a instância da CPU    cpu_instance.pc = m68k_state.pc;    cpu_instance.regs.d[0] = m68k_state.data_regs[0];    cpu_instance.regs.d[1] = m68k_state.data_regs[1];    cpu_instance.regs.d[2] = m68k_state.data_regs[2];    cpu_instance.regs.d[3] = m68k_state.data_regs[3];    cpu_instance.regs.d[4] = m68k_state.data_regs[4];    cpu_instance.regs.d[5] = m68k_state.data_regs[5];    cpu_instance.regs.d[6] = m68k_state.data_regs[6];    cpu_instance.regs.d[7] = m68k_state.data_regs[7];    cpu_instance.regs.a[0] = m68k_state.addr_regs[0];    cpu_instance.regs.a[1] = m68k_state.addr_regs[1];    cpu_instance.regs.a[2] = m68k_state.addr_regs[2];    cpu_instance.regs.a[3] = m68k_state.addr_regs[3];    cpu_instance.regs.a[4] = m68k_state.addr_regs[4];    cpu_instance.regs.a[5] = m68k_state.addr_regs[5];    cpu_instance.regs.a[6] = m68k_state.addr_regs[6];    cpu_instance.regs.a[7] = m68k_state.addr_regs[7];    cpu_instance.regs.sr = m68k_state.sr;    cpu_instance.regs.usp = m68k_state.addr_regs[7];    cpu_instance.regs.ssp = m68k_state.addr_regs[7];    // Retornar o número de ciclos executados    return m68k_state.cycles - cycles_start;}/** * @brief Gera uma interrupção * * @param level Nível da interrupção (1-7) */void md_m68k_interrupt(uint8_t level){    // Verificar se o nível da interrupção é maior que o nível de máscara atual    uint8_t mask = (m68k_state.sr >> 8) & 0x7;    if (level > mask && level > 0)    {        // Sair do estado STOP se estiver nele        m68k_state.stopped = 0;        // Se a CPU não estiver parada, processa a interrupção        if (!m68k_state.halted)        {            uint32_t old_pc = m68k_state.pc;            uint16_t old_sr = m68k_state.sr;            // Mudar para modo supervisor            m68k_state.sr |= 0x2000;            // Salvar PC e SR na pilha            m68k_state.addr_regs[7] -= 4;            memory_write_32(m68k_state.addr_regs[7], old_pc);            m68k_state.addr_regs[7] -= 2;            memory_write_16(m68k_state.addr_regs[7], old_sr);            // Definir o nível de máscara de interrupção            m68k_state.sr = (m68k_state.sr & 0xF8FF) | ((level & 0x7) << 8);            // Carregar o vetor de interrupção            uint32_t vector_addr = 0x60 + (level * 4);            m68k_state.pc = memory_read_32(vector_addr);            // Adicionar ciclos para processamento da interrupção            m68k_state.cycles += 44 + level * 4; // Aproximação        }    }}/** * @brief Obtém o valor de um registrador de dados * * @param reg Número do registrador (0-7) * @return Valor do registrador */uint32_t md_m68k_get_data_reg(uint8_t reg){    if (reg < 8)    {        return m68k_state.data_regs[reg];    }    return 0;}/** * @brief Define o valor de um registrador de dados * * @param reg Número do registrador (0-7) * @param value Valor a ser definido */void md_m68k_set_data_reg(uint8_t reg, uint32_t value){    if (reg < 8)    {        m68k_state.data_regs[reg] = value;    }}/** * @brief Obtém o valor de um registrador de endereço * * @param reg Número do registrador (0-7) * @return Valor do registrador */uint32_t md_m68k_get_addr_reg(uint8_t reg){    if (reg < 8)    {        return m68k_state.addr_regs[reg];    }    return 0;}/** * @brief Define o valor de um registrador de endereço * * @param reg Número do registrador (0-7) * @param value Valor a ser definido */void md_m68k_set_addr_reg(uint8_t reg, uint32_t value){    if (reg < 8)    {        m68k_state.addr_regs[reg] = value;    }}/** * @brief Obtém o valor do registrador de status * * @return Valor do SR */uint16_t md_m68k_get_sr(void){    return m68k_state.sr;}/** * @brief Define o valor do registrador de status * * @param value Novo valor do SR */void md_m68k_set_sr(uint16_t value){    m68k_state.sr = value;}/** * @brief Define o valor do contador de programa * * @param value Novo valor do PC */void md_m68k_set_pc(uint32_t value){    m68k_state.pc = value;}/** * @brief Lê um byte da memória * * @param address Endereço de memória * @return Byte lido */uint8_t md_m68k_read_memory_8(uint32_t address){    if (memory_read_8)    {        return memory_read_8(address);    }    printf("ERRO: Callback de leitura de memória (8 bits) não configurado\n");    return 0xFF;}/** * @brief Lê uma word da memória * * @param address Endereço de memória * @return Word lida */uint16_t md_m68k_read_memory_16(uint32_t address){    if (memory_read_16)    {        return memory_read_16(address);    }    printf("ERRO: Callback de leitura de memória (16 bits) não configurado\n");    return 0xFFFF;}/** * @brief Lê uma long word da memória * * @param address Endereço de memória * @return Long word lida */uint32_t md_m68k_read_memory_32(uint32_t address){    if (memory_read_32)    {        return memory_read_32(address);    }    printf("ERRO: Callback de leitura de memória (32 bits) não configurado\n");    return 0xFFFFFFFF;}/** * @brief Escreve um byte na memória * * @param address Endereço de memória * @param value Valor a ser escrito */void md_m68k_write_memory_8(uint32_t address, uint8_t value){    if (memory_write_8)    {        memory_write_8(address, value);    }    else    {        printf("ERRO: Callback de escrita de memória (8 bits) não configurado\n");    }}/** * @brief Escreve uma word na memória * * @param address Endereço de memória * @param value Valor a ser escrito */void md_m68k_write_memory_16(uint32_t address, uint16_t value){    if (memory_write_16)    {        memory_write_16(address, value);    }    else    {        printf("ERRO: Callback de escrita de memória (16 bits) não configurado\n");    }}/** * @brief Escreve uma long word na memória * * @param address Endereço de memória * @param value Valor a ser escrito */void md_m68k_write_memory_32(uint32_t address, uint32_t value){    if (memory_write_32)    {        memory_write_32(address, value);    }    else    {        printf("ERRO: Callback de escrita de memória (32 bits) não configurado\n");    }}/** * @brief Busca e executa a próxima instrução */static void m68k_fetch_execute(void){    // Ler o opcode da memória no endereço atual do PC    uint16_t opcode = md_m68k_read_memory_16(m68k_state.pc);    // Decodificar a instrução    md_m68k_instruction_t instruction;    int instruction_size = md_m68k_decode_instruction(opcode, m68k_state.pc, &instruction);    // Avançar o PC para a próxima instrução    m68k_state.pc += instruction_size;    // Executar a instrução    int cycles = md_m68k_execute_instruction(&instruction);    // Atualizar o contador de ciclos    m68k_state.cycles += cycles;}/** * @brief Verifica e processa interrupções pendentes */static void m68k_check_interrupts(void){    // Esta função seria expandida para verificar e processar interrupções de dispositivos    // Por enquanto, é apenas um espaço reservado}/** * @brief Implementação da função para obter o PC * * @return Valor atual do PC */uint32_t md_m68k_get_pc(void){    return m68k_state.pc;}/** * @brief Implementação da função para definir um sinal de interrupção * * @param level Nível da interrupção * @param state Estado da interrupção (1 para ativo, 0 para inativo) */void md_m68k_set_interrupt(int level, int state){    if (level >= 1 && level <= 7)    {        // Implementação da função para definir um sinal de interrupção    }}/** * @brief Implementação da função para ler um registrador * * @param reg Identificador do registrador * @return Valor do registrador */uint32_t md_m68k_read_reg(int reg){    if (reg >= 0 && reg < 8)    {        return m68k_state.data_regs[reg];    }    return 0;}/** * @brief Implementação da função para escrever em um registrador * * @param reg Identificador do registrador * @param value Valor a ser escrito */void md_m68k_write_reg(int reg, uint32_t value){    if (reg >= 0 && reg < 8)    {        m68k_state.data_regs[reg] = value;    }}/** * @brief Implementação da função para definir callbacks de leitura de memória * * @param read_8 Função para ler 8 bits * @param read_16 Função para ler 16 bits * @param read_32 Função para ler 32 bits */void md_m68k_set_memory_read_callbacks(    uint8_t (*read_8)(uint32_t address),    uint16_t (*read_16)(uint32_t address),    uint32_t (*read_32)(uint32_t address)){    memory_read_8 = read_8;    memory_read_16 = read_16;    memory_read_32 = read_32;}/** * @brief Implementação da função para definir callbacks de escrita em memória * * @param write_8 Função para escrever 8 bits * @param write_16 Função para escrever 16 bits * @param write_32 Função para escrever 32 bits */void md_m68k_set_memory_write_callbacks(    void (*write_8)(uint32_t address, uint8_t value),    void (*write_16)(uint32_t address, uint16_t value),    void (*write_32)(uint32_t address, uint32_t value)){    memory_write_8 = write_8;    memory_write_16 = write_16;    memory_write_32 = write_32;}/** * @brief Implementação da função de salvamento de estado * * @param buffer Buffer para salvar o estado * @param size Tamanho máximo do buffer * @return Número de bytes escritos no buffer */static int md_m68k_save_state(void *buffer, int size){    if (!buffer || size < sizeof(md_m68k_state_t))    {        return -1;    }    memcpy(buffer, &m68k_state, sizeof(md_m68k_state_t));    return sizeof(md_m68k_state_t);}/** * @brief Implementação da função de carregamento de estado * * @param buffer Buffer contendo o estado salvo * @param size Tamanho do buffer * @return 0 em caso de sucesso, código de erro caso contrário */static int md_m68k_load_state(const void *buffer, int size){    if (!buffer || size < sizeof(md_m68k_state_t))    {        return -1;    }    memcpy(&m68k_state, buffer, sizeof(md_m68k_state_t));    return 0;}/** * @brief Obtém a interface da CPU M68K * @return Ponteiro para a interface da CPU */emu_cpu_t md_m68k_get_interface(void){    return &cpu_instance;}