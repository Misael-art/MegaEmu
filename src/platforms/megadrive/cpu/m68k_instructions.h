/** * @file m68k_instructions.h * @brief Definições e protótipos para as instruções do processador M68K */#ifndef MD_M68K_INSTRUCTIONS_H#define MD_M68K_INSTRUCTIONS_H#include <stdint.h>#include "m68k_timing.h"#ifdef __cplusplusextern "C"{#endif    /**     * @brief Modos de endereçamento do M68K     */    typedef enum    {        M68K_ADDR_MODE_DATA_REG_DIRECT,         // Dn        M68K_ADDR_MODE_ADDR_REG_DIRECT,         // An        M68K_ADDR_MODE_ADDR_REG_INDIRECT,       // (An)        M68K_ADDR_MODE_ADDR_REG_INDIRECT_POST,  // (An)+        M68K_ADDR_MODE_ADDR_REG_INDIRECT_PRE,   // -(An)        M68K_ADDR_MODE_ADDR_REG_INDIRECT_DISP,  // (d16,An)        M68K_ADDR_MODE_ADDR_REG_INDIRECT_INDEX, // (d8,An,Xn)        M68K_ADDR_MODE_PC_INDIRECT_DISP,        // (d16,PC)        M68K_ADDR_MODE_PC_INDIRECT_INDEX,       // (d8,PC,Xn)        M68K_ADDR_MODE_ABSOLUTE_SHORT,          // (xxx).W        M68K_ADDR_MODE_ABSOLUTE_LONG,           // (xxx).L        M68K_ADDR_MODE_IMMEDIATE,               // #<data>        M68K_ADDR_MODE_IMPLIED,                 // Implícito (sem operando)        M68K_ADDR_MODE_INVALID                  // Modo inválido    } md_m68k_addr_mode_t;    /**     * @brief Tamanhos de operação do M68K     */    typedef enum    {        M68K_SIZE_BYTE = 1, // 8 bits        M68K_SIZE_WORD = 2, // 16 bits        M68K_SIZE_LONG = 4  // 32 bits    } md_m68k_size_t;    /**     * @brief Tipos de instruções do M68K     */    typedef enum    {        M68K_INST_ABCD,    // Add Decimal with Extend        M68K_INST_ADD,     // Add        M68K_INST_ADDA,    // Add Address        M68K_INST_ADDI,    // Add Immediate        M68K_INST_ADDQ,    // Add Quick        M68K_INST_ADDX,    // Add with Extend        M68K_INST_AND,     // Logical AND        M68K_INST_ANDI,    // AND Immediate        M68K_INST_ASL,     // Arithmetic Shift Left        M68K_INST_ASR,     // Arithmetic Shift Right        M68K_INST_BCC,     // Branch Conditionally        M68K_INST_BCHG,    // Test a Bit and Change        M68K_INST_BCLR,    // Test a Bit and Clear        M68K_INST_BRA,     // Branch Always        M68K_INST_BSET,    // Test a Bit and Set        M68K_INST_BSR,     // Branch to Subroutine        M68K_INST_BTST,    // Test a Bit        M68K_INST_CHK,     // Check Register Against Bounds        M68K_INST_CLR,     // Clear        M68K_INST_CMP,     // Compare        M68K_INST_CMPA,    // Compare Address        M68K_INST_CMPI,    // Compare Immediate        M68K_INST_CMPM,    // Compare Memory        M68K_INST_DBCC,    // Test Condition, Decrement, and Branch        M68K_INST_DIVS,    // Signed Divide        M68K_INST_DIVU,    // Unsigned Divide        M68K_INST_EOR,     // Logical Exclusive OR        M68K_INST_EORI,    // Exclusive OR Immediate        M68K_INST_EXG,     // Exchange Registers        M68K_INST_EXT,     // Sign Extend        M68K_INST_ILLEGAL, // Illegal Instruction        M68K_INST_JMP,     // Jump        M68K_INST_JSR,     // Jump to Subroutine        M68K_INST_LEA,     // Load Effective Address        M68K_INST_LINK,    // Link and Allocate        M68K_INST_LSL,     // Logical Shift Left        M68K_INST_LSR,     // Logical Shift Right        M68K_INST_MOVE,    // Move        M68K_INST_MOVEA,   // Move Address        M68K_INST_MOVEM,   // Move Multiple Registers        M68K_INST_MOVEP,   // Move Peripheral        M68K_INST_MOVEQ,   // Move Quick        M68K_INST_MULS,    // Signed Multiply        M68K_INST_MULU,    // Unsigned Multiply        M68K_INST_NBCD,    // Negate Decimal with Extend        M68K_INST_NEG,     // Negate        M68K_INST_NEGX,    // Negate with Extend        M68K_INST_NOP,     // No Operation        M68K_INST_NOT,     // Logical Complement        M68K_INST_OR,      // Logical OR        M68K_INST_ORI,     // OR Immediate        M68K_INST_PEA,     // Push Effective Address        M68K_INST_RESET,   // Reset External Devices        M68K_INST_ROL,     // Rotate Left        M68K_INST_ROR,     // Rotate Right        M68K_INST_ROXL,    // Rotate Left with Extend        M68K_INST_ROXR,    // Rotate Right with Extend        M68K_INST_RTE,     // Return from Exception        M68K_INST_RTR,     // Return and Restore Condition Codes        M68K_INST_RTS,     // Return from Subroutine        M68K_INST_SBCD,    // Subtract Decimal with Extend        M68K_INST_SCC,     // Set Conditionally        M68K_INST_STOP,    // Stop        M68K_INST_SUB,     // Subtract        M68K_INST_SUBA,    // Subtract Address        M68K_INST_SUBI,    // Subtract Immediate        M68K_INST_SUBQ,    // Subtract Quick        M68K_INST_SUBX,    // Subtract with Extend        M68K_INST_SWAP,    // Swap Register Halves        M68K_INST_TAS,     // Test and Set        M68K_INST_TRAP,    // Trap        M68K_INST_TRAPV,   // Trap on Overflow        M68K_INST_TST,     // Test        M68K_INST_UNLK,    // Unlink        M68K_INST_INVALID  // Instrução inválida    } md_m68k_inst_type_t;    /**     * @brief Estrutura para representar uma instrução decodificada     */    typedef struct    {        md_m68k_inst_type_t type; // Tipo da instrução        md_m68k_size_t size;      // Tamanho da operação        // Operandos        md_m68k_addr_mode_t src_mode; // Modo de endereçamento do operando fonte        md_m68k_addr_mode_t dst_mode; // Modo de endereçamento do operando destino        uint8_t src_reg;              // Registrador fonte        uint8_t dst_reg;              // Registrador destino        // Valores imediatos ou extensões        uint32_t immediate;   // Valor imediato (se houver)        int16_t displacement; // Deslocamento (se houver)        // Informações de ciclos        int32_t cycles_base; // Ciclos base da instrução        int32_t cycles_ea;   // Ciclos adicionais para cálculo de EA        // Dados extras        uint16_t opcode;   // Opcode original        uint32_t address;  // Endereço da instrução        uint8_t condition; // Código de condição (para Bcc, DBcc, etc)        uint16_t reg_mask; // Máscara de registradores (para MOVEM)        // Informações de timing        struct {            uint32_t base_cycles;     // Ciclos base da instrução            uint32_t ea_cycles;       // Ciclos para cálculo de EA            uint32_t mem_cycles;      // Ciclos de acesso à memória            uint32_t branch_cycles;   // Ciclos extras para branches            bool is_rmw;             // Instrução read-modify-write            bool uses_prefetch;      // Usa prefetch queue        } timing;        // Estado de execução        struct {            bool needs_prefetch;     // Precisa atualizar prefetch            bool changes_pc;         // Modifica o PC            bool is_privileged;      // Instrução privilegiada            bool affects_ccr;        // Afeta o CCR            uint8_t exception_vector; // Vetor de exceção (se houver)        } execution;    } md_m68k_instruction_t;    /**     * @brief Decodifica uma instrução a partir de um opcode     *     * @param opcode Opcode a ser decodificado     * @param pc Endereço atual do PC     * @param instruction Estrutura a ser preenchida com a instrução decodificada     * @return Tamanho da instrução em bytes     */    int32_t md_m68k_decode_instruction(uint16_t opcode, uint32_t pc, md_m68k_instruction_t *instruction);    /**     * @brief Executa uma instrução decodificada com timing preciso     *     * @param instruction Instrução a ser executada     * @param timing Sistema de timing     * @return Número de ciclos consumidos     */    int32_t md_m68k_execute_instruction(const md_m68k_instruction_t *instruction, md_m68k_timing_t *timing);    /**     * @brief Implementa a leitura de um operando com timing preciso     *     * @param mode Modo de endereçamento     * @param reg Registrador     * @param size Tamanho da operação     * @param value Ponteiro para receber o valor lido     * @param timing Sistema de timing     * @return Número de ciclos adicionais     */    int32_t md_m68k_read_operand(md_m68k_addr_mode_t mode, uint8_t reg, md_m68k_size_t size,
                                                                 uint32_t *value, md_m68k_timing_t *timing);    /**     * @brief Implementa a escrita em um operando com timing preciso     *     * @param mode Modo de endereçamento     * @param reg Registrador     * @param size Tamanho da operação     * @param value Valor a ser escrito     * @param timing Sistema de timing     * @return Número de ciclos adicionais     */    int32_t md_m68k_write_operand(md_m68k_addr_mode_t mode, uint8_t reg, md_m68k_size_t size,
                                                                 uint32_t value, md_m68k_timing_t *timing);    /**     * @brief Atualiza as flags com base em um resultado     *     * @param result Resultado da operação     * @param size Tamanho da operação     * @param update_mask Máscara de flags a serem atualizadas     */    void md_m68k_update_flags(uint32_t result, md_m68k_size_t size, uint16_t update_mask);    /**     * @brief Avalia uma condição de branch     *     * @param condition Código de condição     * @return 1 se a condição for verdadeira, 0 caso contrário     */    int32_t md_m68k_evaluate_condition(uint8_t condition);    /**     * @brief Calcula ciclos para um modo de endereçamento     *     * @param mode Modo de endereçamento     * @param reg Registrador     * @param is_read Operação de leitura (true) ou escrita (false)     * @param timing Sistema de timing     * @return Número de ciclos     */    uint32_t md_m68k_calculate_ea_timing(md_m68k_addr_mode_t mode, uint8_t reg,
                                                                 bool is_read, md_m68k_timing_t *timing);    /**     * @brief Calcula ciclos base para uma instrução     *     * @param instruction Instrução     * @return Número de ciclos base     */    uint32_t md_m68k_calculate_instruction_timing(const md_m68k_instruction_t *instruction);#ifdef __cplusplus}#endif#endif /* MD_M68K_INSTRUCTIONS_H */
