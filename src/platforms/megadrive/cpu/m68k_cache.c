#include "m68k_cache.h"#include "m68k.h"#include <string.h>// Cache globalstatic md_m68k_cache_t icache;// Macros para manipulação de endereços#define CACHE_INDEX(addr) (((addr) >> 1) & (M68K_ICACHE_SIZE - 1))#define CACHE_TAG(addr) ((addr) >> (1 + __builtin_ctz(M68K_ICACHE_SIZE)))#define CACHE_OFFSET(addr) (((addr) & (M68K_ICACHE_LINE_SIZE - 1)) >> 1)/** * @brief Inicializa o cache de instruções */void md_m68k_init_cache(void){    memset(&icache, 0, sizeof(icache));    icache.enabled = 1;}/** * @brief Habilita ou desabilita o cache */void md_m68k_enable_cache(int enable){    if (enable != icache.enabled)    {        icache.enabled = enable;        if (enable)        {            md_m68k_cache_invalidate();        }    }}/** * @brief Lê uma instrução do cache * * @param address Endereço da instrução * @return uint16_t Instrução lida */uint16_t md_m68k_cache_read_instruction(uint32_t address){    if (!icache.enabled)    {        return md_m68k_read_memory_16(address);    }    uint32_t index = CACHE_INDEX(address);    uint32_t tag = CACHE_TAG(address);    uint32_t offset = CACHE_OFFSET(address);    md_m68k_cache_line_t *line = &icache.lines[index];    // Verificar hit    if (line->valid && line->tag == tag)    {        // Cache hit        line->last_access = ++icache.access_count;        icache.hits++;        return line->data[offset];    }    // Cache miss    icache.misses++;    // Carregar linha do cache    line->tag = tag;    line->valid = 1;    line->dirty = 0;    line->last_access = ++icache.access_count;    // Carregar dados da memória    uint32_t base_addr = address & ~(M68K_ICACHE_LINE_SIZE - 1);    for (int i = 0; i < M68K_ICACHE_LINE_SIZE / 2; i++)    {        line->data[i] = md_m68k_read_memory_16(base_addr + i * 2);    }    // Retornar instrução solicitada    return line->data[offset];}/** * @brief Invalida todo o cache */void md_m68k_cache_invalidate(void){    for (int i = 0; i < M68K_ICACHE_SIZE; i++)    {        icache.lines[i].valid = 0;    }}/** * @brief Faz flush do cache para a memória */void md_m68k_cache_flush(void){    for (int i = 0; i < M68K_ICACHE_SIZE; i++)    {        md_m68k_cache_line_t *line = &icache.lines[i];        if (line->valid && line->dirty)        {            uint32_t base_addr = (line->tag << (1 + __builtin_ctz(M68K_ICACHE_SIZE))) |                                 (i << 1);            for (int j = 0; j < M68K_ICACHE_LINE_SIZE / 2; j++)            {                md_m68k_write_memory_16(base_addr + j * 2, line->data[j]);            }            line->dirty = 0;        }    }}/** * @brief Realiza prefetch de instruções * * @param address Endereço base para prefetch */void md_m68k_cache_prefetch(uint32_t address){    if (!icache.enabled)    {        return;    }    // Prefetch da próxima linha de cache    uint32_t next_line = (address + M68K_ICACHE_LINE_SIZE) & ~(M68K_ICACHE_LINE_SIZE - 1);    uint32_t index = CACHE_INDEX(next_line);    uint32_t tag = CACHE_TAG(next_line);    md_m68k_cache_line_t *line = &icache.lines[index];    // Se a linha já está no cache, não fazer nada    if (line->valid && line->tag == tag)    {        return;    }    // Carregar linha em background    line->tag = tag;    line->valid = 1;    line->dirty = 0;    line->last_access = ++icache.access_count;    for (int i = 0; i < M68K_ICACHE_LINE_SIZE / 2; i++)    {        line->data[i] = md_m68k_read_memory_16(next_line + i * 2);    }}/** * @brief Obtém estatísticas do cache */void md_m68k_cache_stats(uint32_t *hits, uint32_t *misses){    if (hits)        *hits = icache.hits;    if (misses)        *misses = icache.misses;}