#include "m68k_exceptions.h"#include "m68k.h"#include <string.h>#include <stdio.h>// Tabela de vetores de exceçãostatic md_m68k_exception_handler_t exception_handlers[64];// Estado das interrupçõesstatic struct{    uint8_t mask;         // Máscara de interrupção atual (IPL)    uint8_t pending;      // Interrupções pendentes    uint8_t in_service;   // Interrupções em serviço    uint32_t vector_base; // Endereço base da tabela de vetores} interrupt_state;// Cache de exceções para otimização#define EXCEPTION_CACHE_SIZE 8static struct{    md_m68k_exception_info_t info;    int valid;} exception_cache[EXCEPTION_CACHE_SIZE];static int exception_cache_index = 0;/** * @brief Inicializa o sistema de exceções */void md_m68k_init_exceptions(void){    // Limpar handlers    memset(exception_handlers, 0, sizeof(exception_handlers));    // Inicializar estado das interrupções    interrupt_state.mask = 7; // Todas as interrupções mascaradas inicialmente    interrupt_state.pending = 0;    interrupt_state.in_service = 0;    interrupt_state.vector_base = 0; // Endereço base padrão    // Limpar cache    memset(exception_cache, 0, sizeof(exception_cache));    exception_cache_index = 0;}/** * @brief Define um handler para um tipo de exceção */void md_m68k_set_exception_handler(md_m68k_exception_t type, md_m68k_exception_handler_t handler){    if (type < 64)    {        exception_handlers[type] = handler;    }}/** * @brief Gera uma exceção */void md_m68k_raise_exception(md_m68k_exception_t type, uint32_t address, uint32_t data){    md_m68k_exception_info_t info;    info.type = type;    info.address = address;    info.status_register = md_m68k_get_sr();    info.data = data;    // Determinar prioridade    switch (type)    {    case M68K_EXCEPTION_RESET:        info.priority = M68K_PRIORITY_RESET;        break;    case M68K_EXCEPTION_BUS_ERROR:    case M68K_EXCEPTION_ADDRESS_ERROR:        info.priority = M68K_PRIORITY_BUS_ERROR;        break;    case M68K_EXCEPTION_ILLEGAL_INSTRUCTION:    case M68K_EXCEPTION_ZERO_DIVIDE:    case M68K_EXCEPTION_CHK:    case M68K_EXCEPTION_TRAPV:    case M68K_EXCEPTION_PRIVILEGE_VIOLATION:    case M68K_EXCEPTION_TRACE:    case M68K_EXCEPTION_LINE_1010:    case M68K_EXCEPTION_LINE_1111:        info.priority = M68K_PRIORITY_ILLEGAL_INSTRUCTION;        break;    case M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_1:        info.priority = M68K_PRIORITY_AUTOVECTOR_1;        break;    case M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_2:        info.priority = M68K_PRIORITY_AUTOVECTOR_2;        break;    case M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_3:        info.priority = M68K_PRIORITY_AUTOVECTOR_3;        break;    case M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_4:        info.priority = M68K_PRIORITY_AUTOVECTOR_4;        break;    case M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_5:        info.priority = M68K_PRIORITY_AUTOVECTOR_5;        break;    case M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_6:        info.priority = M68K_PRIORITY_AUTOVECTOR_6;        break;    case M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_7:        info.priority = M68K_PRIORITY_AUTOVECTOR_7;        break;    default:        info.priority = M68K_PRIORITY_TRAP;        break;    }    // Verificar se é uma interrupção mascarável    if (type >= M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_1 &&        type <= M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_7)    {        uint8_t level = type - M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_1 + 1;        // Verificar máscara        if (level <= interrupt_state.mask)        {            // Interrupção mascarada, marcar como pendente            interrupt_state.pending |= (1 << (level - 1));            return;        }        // Marcar interrupção como em serviço        interrupt_state.in_service |= (1 << (level - 1));    }    // Adicionar ao cache    exception_cache[exception_cache_index].info = info;    exception_cache[exception_cache_index].valid = 1;    exception_cache_index = (exception_cache_index + 1) % EXCEPTION_CACHE_SIZE;    // Chamar handler se existir    if (type < 64 && exception_handlers[type])    {        // Salvar contexto        uint32_t old_pc = md_m68k_get_pc();        uint16_t old_sr = md_m68k_get_sr();        // Empilhar PC e SR        uint32_t sp = md_m68k_get_addr_reg(7) - 6;        md_m68k_set_addr_reg(7, sp);        md_m68k_write_memory_32(sp, old_pc);        md_m68k_write_memory_16(sp + 4, old_sr);        // Atualizar SR (modo supervisor e máscara de interrupção)        uint16_t new_sr = old_sr | 0x2000; // Set supervisor bit        if (info.priority > M68K_PRIORITY_AUTOVECTOR_1)        {            new_sr = (new_sr & 0xF8FF) | ((info.priority & 7) << 8);        }        md_m68k_set_sr(new_sr);        // Calcular endereço do vetor        uint32_t vector_address = interrupt_state.vector_base + (type * 4);        // Ler novo PC do vetor        uint32_t new_pc = md_m68k_read_memory_32(vector_address);        md_m68k_set_pc(new_pc);        // Chamar handler        exception_handlers[type](&info);    }}/** * @brief Define a máscara de interrupção */void md_m68k_set_interrupt_mask(uint8_t mask){    interrupt_state.mask = mask & 7;    // Verificar interrupções pendentes que podem ser processadas agora    if (interrupt_state.pending)    {        for (int i = 7; i > interrupt_state.mask; i--)        {            if (interrupt_state.pending & (1 << (i - 1)))            {                // Limpar flag pendente                interrupt_state.pending &= ~(1 << (i - 1));                // Gerar exceção                md_m68k_raise_exception(M68K_EXCEPTION_INTERRUPT_AUTOVECTOR_1 + i - 1,                                        md_m68k_get_pc(), 0);                break;            }        }    }}/** * @brief Obtém a máscara de interrupção atual */uint8_t md_m68k_get_interrupt_mask(void){    return interrupt_state.mask;}/** * @brief Verifica se há interrupções pendentes * @return 1 se houver interrupção pendente não mascarada, 0 caso contrário */int md_m68k_check_interrupts(void){    if (!interrupt_state.pending)    {        return 0;    }    // Verificar cada nível de interrupção, do mais alto para o mais baixo    for (int i = 7; i > interrupt_state.mask; i--)    {        if (interrupt_state.pending & (1 << (i - 1)))        {            return 1;        }    }    return 0;}