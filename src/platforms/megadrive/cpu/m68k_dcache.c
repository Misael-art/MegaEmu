#include "m68k_dcache.h"#include "m68k.h"#include <string.h>// Cache de dados globalstatic md_m68k_dcache_t dcache;// Macros para manipulação de endereços#define DCACHE_INDEX(addr) ((addr >> 5) & (M68K_DCACHE_SIZE - 1))#define DCACHE_TAG(addr) (addr >> (5 + __builtin_ctz(M68K_DCACHE_SIZE)))#define DCACHE_OFFSET(addr) (addr & (M68K_DCACHE_LINE_SIZE - 1))/** * @brief Inicializa o cache de dados */void md_m68k_init_dcache(void){    memset(&dcache, 0, sizeof(dcache));    dcache.enabled = 1;    dcache.policy = M68K_WRITE_BACK; // Default para write-back}/** * @brief Habilita ou desabilita o cache */void md_m68k_enable_dcache(int enable){    if (enable != dcache.enabled)    {        if (enable)        {            md_m68k_dcache_flush();        }        dcache.enabled = enable;    }}/** * @brief Define a política de escrita */void md_m68k_set_write_policy(md_m68k_write_policy_t policy){    if (policy != dcache.policy)    {        md_m68k_dcache_flush();        dcache.policy = policy;    }}/** * @brief Processa o buffer de escrita */static void process_write_buffer(void){    while (dcache.write_buffer_head != dcache.write_buffer_tail)    {        md_m68k_write_buffer_entry_t *entry = &dcache.write_buffer[dcache.write_buffer_tail];        if (!entry->valid)        {            break;        }        // Escrever na memória principal        switch (entry->size)        {        case 1:            md_m68k_write_memory_8(entry->address, entry->data);            break;        case 2:            md_m68k_write_memory_16(entry->address, entry->data);            break;        case 4:            md_m68k_write_memory_32(entry->address, entry->data);            break;        }        entry->valid = 0;        dcache.write_buffer_tail = (dcache.write_buffer_tail + 1) % M68K_DCACHE_WRITE_BUFFER;    }}/** * @brief Adiciona uma escrita ao buffer */static void add_to_write_buffer(uint32_t address, uint32_t data, uint8_t size){    // Se o buffer está cheio, processar algumas entradas    if (((dcache.write_buffer_head + 1) % M68K_DCACHE_WRITE_BUFFER) == dcache.write_buffer_tail)    {        process_write_buffer();    }    // Adicionar nova entrada    md_m68k_write_buffer_entry_t *entry = &dcache.write_buffer[dcache.write_buffer_head];    entry->address = address;    entry->data = data;    entry->size = size;    entry->valid = 1;    dcache.write_buffer_head = (dcache.write_buffer_head + 1) % M68K_DCACHE_WRITE_BUFFER;}/** * @brief Carrega uma linha do cache */static void load_cache_line(uint32_t address, md_m68k_dcache_line_t *line){    uint32_t base_addr = address & ~(M68K_DCACHE_LINE_SIZE - 1);    // Carregar dados da memória    for (int i = 0; i < M68K_DCACHE_LINE_SIZE; i++)    {        line->data[i] = md_m68k_read_memory_8(base_addr + i);    }    line->tag = DCACHE_TAG(address);    line->valid = 1;    line->dirty = 0;    line->last_access = ++dcache.access_count;    line->access_count = 0;    line->write_count = 0;}/** * @brief Faz writeback de uma linha do cache */static void writeback_cache_line(md_m68k_dcache_line_t *line, uint32_t index){    if (!line->valid || !line->dirty)    {        return;    }    uint32_t base_addr = (line->tag << (5 + __builtin_ctz(M68K_DCACHE_SIZE))) |                         (index << 5);    // Escrever dados na memória    for (int i = 0; i < M68K_DCACHE_LINE_SIZE; i++)    {        md_m68k_write_memory_8(base_addr + i, line->data[i]);    }    line->dirty = 0;    dcache.writebacks++;}/** * @brief Lê um byte do cache */uint32_t md_m68k_dcache_read_8(uint32_t address){    if (!dcache.enabled)    {        return md_m68k_read_memory_8(address);    }    uint32_t index = DCACHE_INDEX(address);    uint32_t tag = DCACHE_TAG(address);    uint32_t offset = DCACHE_OFFSET(address);    md_m68k_dcache_line_t *line = &dcache.lines[index];    // Verificar hit    if (line->valid && line->tag == tag)    {        // Cache hit        line->last_access = ++dcache.access_count;        line->access_count++;        dcache.hits++;        return line->data[offset];    }    // Cache miss    dcache.misses++;    // Se linha atual está suja, fazer writeback    if (line->valid && line->dirty)    {        writeback_cache_line(line, index);    }    // Carregar nova linha    load_cache_line(address, line);    return line->data[offset];}/** * @brief Lê uma word do cache */uint32_t md_m68k_dcache_read_16(uint32_t address){    uint32_t data = md_m68k_dcache_read_8(address) << 8;    data |= md_m68k_dcache_read_8(address + 1);    return data;}/** * @brief Lê uma longword do cache */uint32_t md_m68k_dcache_read_32(uint32_t address){    uint32_t data = md_m68k_dcache_read_16(address) << 16;    data |= md_m68k_dcache_read_16(address + 2);    return data;}/** * @brief Escreve um byte no cache */void md_m68k_dcache_write_8(uint32_t address, uint8_t data){    if (!dcache.enabled)    {        md_m68k_write_memory_8(address, data);        return;    }    uint32_t index = DCACHE_INDEX(address);    uint32_t tag = DCACHE_TAG(address);    uint32_t offset = DCACHE_OFFSET(address);    md_m68k_dcache_line_t *line = &dcache.lines[index];    // Write-through: escrever diretamente na memória    if (dcache.policy == M68K_WRITE_THROUGH)    {        add_to_write_buffer(address, data, 1);    }    // Verificar hit    if (line->valid && line->tag == tag)    {        // Cache hit        line->data[offset] = data;        line->last_access = ++dcache.access_count;        line->write_count++;        line->dirty = (dcache.policy == M68K_WRITE_BACK);        dcache.hits++;        return;    }    // Cache miss    dcache.misses++;    // Se linha atual está suja, fazer writeback    if (line->valid && line->dirty)    {        writeback_cache_line(line, index);    }    // Carregar nova linha    load_cache_line(address, line);    line->data[offset] = data;    line->dirty = (dcache.policy == M68K_WRITE_BACK);}/** * @brief Escreve uma word no cache */void md_m68k_dcache_write_16(uint32_t address, uint16_t data){    md_m68k_dcache_write_8(address, data >> 8);    md_m68k_dcache_write_8(address + 1, data & 0xFF);}/** * @brief Escreve uma longword no cache */void md_m68k_dcache_write_32(uint32_t address, uint32_t data){    md_m68k_dcache_write_16(address, data >> 16);    md_m68k_dcache_write_16(address + 2, data & 0xFFFF);}/** * @brief Faz flush do cache */void md_m68k_dcache_flush(void){    // Processar buffer de escrita    process_write_buffer();    // Writeback de todas as linhas sujas    for (int i = 0; i < M68K_DCACHE_SIZE; i++)    {        writeback_cache_line(&dcache.lines[i], i);    }}/** * @brief Invalida o cache */void md_m68k_dcache_invalidate(void){    // Writeback de linhas sujas antes de invalidar    md_m68k_dcache_flush();    // Invalidar todas as linhas    for (int i = 0; i < M68K_DCACHE_SIZE; i++)    {        dcache.lines[i].valid = 0;    }}/** * @brief Faz flush de uma linha específica */void md_m68k_dcache_flush_line(uint32_t address){    uint32_t index = DCACHE_INDEX(address);    uint32_t tag = DCACHE_TAG(address);    md_m68k_dcache_line_t *line = &dcache.lines[index];    if (line->valid && line->tag == tag && line->dirty)    {        writeback_cache_line(line, index);    }}/** * @brief Realiza prefetch de dados */void md_m68k_dcache_prefetch(uint32_t address){    if (!dcache.enabled)    {        return;    }    uint32_t index = DCACHE_INDEX(address);    uint32_t tag = DCACHE_TAG(address);    md_m68k_dcache_line_t *line = &dcache.lines[index];    // Se já está no cache, não fazer nada    if (line->valid && line->tag == tag)    {        return;    }    // Se linha atual está suja, fazer writeback    if (line->valid && line->dirty)    {        writeback_cache_line(line, index);    }    // Carregar nova linha    load_cache_line(address, line);}/** * @brief Obtém estatísticas do cache */void md_m68k_dcache_stats(uint32_t *hits, uint32_t *misses, uint32_t *writebacks){    if (hits)        *hits = dcache.hits;    if (misses)        *misses = dcache.misses;    if (writebacks)        *writebacks = dcache.writebacks;}