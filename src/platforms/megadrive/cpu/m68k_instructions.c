/** * @file m68k_instructions.c * @brief Implementação das instruções da CPU Motorola 68000 * * Este arquivo contém a implementação das funções para decodificação, * execução e manipulação de operandos para a CPU M68K do Mega Drive. */#include "m68k_instructions.h"#include "m68k.h"#include <stdio.h>#include <stdlib.h>/* Declarações de funções internas (privadas) */static int execute_move(const md_m68k_instruction_t *instruction);static int execute_nop(const md_m68k_instruction_t *instruction);static int execute_rts(const md_m68k_instruction_t *instruction);/* Declarações de funções internas adicionais */static int execute_add(const md_m68k_instruction_t *instruction);static int execute_sub(const md_m68k_instruction_t *instruction);static int execute_and(const md_m68k_instruction_t *instruction);static int execute_or(const md_m68k_instruction_t *instruction);static int execute_lsl(const md_m68k_instruction_t *instruction);static int execute_lsr(const md_m68k_instruction_t *instruction);static int execute_bra(const md_m68k_instruction_t *instruction);static int execute_bsr(const md_m68k_instruction_t *instruction);static int execute_bcc(const md_m68k_instruction_t *instruction);/* Adicionar novas declarações de funções internas */static int execute_muls(const md_m68k_instruction_t *instruction);static int execute_mulu(const md_m68k_instruction_t *instruction);static int execute_divs(const md_m68k_instruction_t *instruction);static int execute_divu(const md_m68k_instruction_t *instruction);static int execute_asl(const md_m68k_instruction_t *instruction);static int execute_asr(const md_m68k_instruction_t *instruction);static int execute_addx(const md_m68k_instruction_t *instruction);static int execute_subx(const md_m68k_instruction_t *instruction);static int execute_bchg(const md_m68k_instruction_t *instruction);static int execute_bclr(const md_m68k_instruction_t *instruction);static int execute_bset(const md_m68k_instruction_t *instruction);static int execute_btst(const md_m68k_instruction_t *instruction);static int execute_abcd(const md_m68k_instruction_t *instruction);static int execute_sbcd(const md_m68k_instruction_t *instruction);static int execute_cmpm(const md_m68k_instruction_t *instruction);static int execute_cmpa(const md_m68k_instruction_t *instruction);static int execute_ext(const md_m68k_instruction_t *instruction);static int execute_swap(const md_m68k_instruction_t *instruction);/** * @brief Decodifica uma instrução a partir do opcode * * @param opcode Opcode a ser decodificado * @param pc Endereço atual do contador de programa * @param instruction Ponteiro para a estrutura onde a instrução será armazenada * @return int Tamanho da instrução em bytes */int md_m68k_decode_instruction(uint16_t opcode, uint32_t pc, md_m68k_instruction_t *instruction){    // Inicializar a estrutura da instrução    instruction->opcode = opcode;    instruction->address = pc;    instruction->immediate = 0;    instruction->displacement = 0;    instruction->cycles_base = 0;    instruction->cycles_ea = 0;    instruction->condition = 0;    instruction->reg_mask = 0;    // Grupo de bits mais significativos do opcode    uint8_t group = (opcode >> 12) & 0xF;    // Verificar os grupos principais de instruções    switch (group)    {    case 0x1: // MOVE.B        instruction->type = M68K_INST_MOVE;        instruction->size = M68K_SIZE_BYTE;        instruction->dst_reg = (opcode >> 9) & 0x7;        instruction->dst_mode = ((opcode >> 6) & 0x7) + 1; // Ajustar para o enum        instruction->src_reg = opcode & 0x7;        instruction->src_mode = ((opcode >> 3) & 0x7) + 1; // Ajustar para o enum        instruction->cycles_base = 4;                      // Valor aproximado        return 2;                                          // Tamanho básico da instrução em bytes    case 0x3: // MOVE.W        instruction->type = M68K_INST_MOVE;        instruction->size = M68K_SIZE_WORD;        instruction->dst_reg = (opcode >> 9) & 0x7;        instruction->dst_mode = ((opcode >> 6) & 0x7) + 1; // Ajustar para o enum        instruction->src_reg = opcode & 0x7;        instruction->src_mode = ((opcode >> 3) & 0x7) + 1; // Ajustar para o enum        instruction->cycles_base = 4;                      // Valor aproximado        return 2;                                          // Tamanho básico da instrução em bytes    case 0x2: // MOVE.L        instruction->type = M68K_INST_MOVE;        instruction->size = M68K_SIZE_LONG;        instruction->dst_reg = (opcode >> 9) & 0x7;        instruction->dst_mode = ((opcode >> 6) & 0x7) + 1; // Ajustar para o enum        instruction->src_reg = opcode & 0x7;        instruction->src_mode = ((opcode >> 3) & 0x7) + 1; // Ajustar para o enum        instruction->cycles_base = 4;                      // Valor aproximado        return 2;                                          // Tamanho básico da instrução em bytes    case 0x4: // Misc (incluindo NOP)        if (opcode == 0x4E71)        {            instruction->type = M68K_INST_NOP;            instruction->size = M68K_SIZE_WORD;            instruction->src_mode = M68K_ADDR_MODE_IMPLIED;            instruction->dst_mode = M68K_ADDR_MODE_IMPLIED;            instruction->cycles_base = 4;            return 2;        }        else if (opcode == 0x4E75)        {            instruction->type = M68K_INST_RTS;            instruction->size = M68K_SIZE_WORD;            instruction->src_mode = M68K_ADDR_MODE_IMPLIED;            instruction->dst_mode = M68K_ADDR_MODE_IMPLIED;            instruction->cycles_base = 16;            return 2;        }        break;    case 0xD: // ADD, ADDX        if ((opcode & 0xF000) == 0xD000) {            instruction->type = M68K_INST_ADD;            instruction->size = (opcode & 0x00C0) >> 6;            instruction->dst_reg = (opcode >> 9) & 0x7;            instruction->src_reg = opcode & 0x7;            instruction->src_mode = ((opcode >> 3) & 0x7) + 1;            instruction->cycles_base = 4;            return 2;        }        break;    case 0x9: // SUB, SUBX        if ((opcode & 0xF000) == 0x9000) {            instruction->type = M68K_INST_SUB;            instruction->size = (opcode & 0x00C0) >> 6;            instruction->dst_reg = (opcode >> 9) & 0x7;            instruction->src_reg = opcode & 0x7;            instruction->src_mode = ((opcode >> 3) & 0x7) + 1;            instruction->cycles_base = 4;            return 2;        }        break;    case 0xC: // AND, MULU, MULS        if ((opcode & 0xF000) == 0xC000) {            instruction->type = M68K_INST_AND;            instruction->size = (opcode & 0x00C0) >> 6;            instruction->dst_reg = (opcode >> 9) & 0x7;            instruction->src_reg = opcode & 0x7;            instruction->src_mode = ((opcode >> 3) & 0x7) + 1;            instruction->cycles_base = 4;            return 2;        }        break;    case 0x8: // OR, DIVS, DIVU        if ((opcode & 0xF000) == 0x8000) {            instruction->type = M68K_INST_OR;            instruction->size = (opcode & 0x00C0) >> 6;            instruction->dst_reg = (opcode >> 9) & 0x7;            instruction->src_reg = opcode & 0x7;            instruction->src_mode = ((opcode >> 3) & 0x7) + 1;            instruction->cycles_base = 4;            return 2;        }        break;    case 0x6: // Bcc, BSR, BRA        {            uint8_t condition = (opcode >> 8) & 0xF;            int8_t displacement = (int8_t)(opcode & 0xFF);            if (condition == 0x0) { // BRA                instruction->type = M68K_INST_BRA;                instruction->displacement = displacement;                instruction->cycles_base = 10;                return 2;            }            else if (condition == 0x1) { // BSR                instruction->type = M68K_INST_BSR;                instruction->displacement = displacement;                instruction->cycles_base = 18;                return 2;            }            else { // Bcc                instruction->type = M68K_INST_BCC;                instruction->condition = condition;                instruction->displacement = displacement;                instruction->cycles_base = 10;                return 2;            }        }        break;    default:        // Instrução não implementada ou desconhecida        instruction->type = M68K_INST_INVALID;        instruction->size = M68K_SIZE_WORD;        instruction->src_mode = M68K_ADDR_MODE_INVALID;        instruction->dst_mode = M68K_ADDR_MODE_INVALID;        return 2; // Tamanho padrão    }    // Caso não reconheça a instrução    instruction->type = M68K_INST_INVALID;    return 2;}/** * @brief Executa uma instrução decodificada * * @param instruction Ponteiro para a instrução a ser executada * @return int Número de ciclos consumidos */int md_m68k_execute_instruction(const md_m68k_instruction_t *instruction){    int cycles = instruction->cycles_base;    // Executar a instrução de acordo com seu tipo    switch (instruction->type)    {    case M68K_INST_MOVE:        cycles += execute_move(instruction);        break;    case M68K_INST_NOP:        cycles += execute_nop(instruction);        break;    case M68K_INST_RTS:        cycles += execute_rts(instruction);        break;    case M68K_INST_ADD:        cycles += execute_add(instruction);        break;    case M68K_INST_SUB:        cycles += execute_sub(instruction);        break;    case M68K_INST_AND:        cycles += execute_and(instruction);        break;    case M68K_INST_OR:        cycles += execute_or(instruction);        break;    case M68K_INST_BRA:        cycles += execute_bra(instruction);        break;    case M68K_INST_BSR:        cycles += execute_bsr(instruction);        break;    case M68K_INST_BCC:        cycles += execute_bcc(instruction);        break;    default:        // Instrução não implementada        printf("AVISO: Instrução não implementada: %04X em %08X\n",               instruction->opcode, instruction->address);        break;    }    return cycles;}/** * @brief Lê o valor de um operando * * @param mode Modo de endereçamento * @param reg Registrador * @param size Tamanho da operação * @param value Ponteiro para onde o valor será armazenado * @return int Número de ciclos adicionais */int md_m68k_read_operand(md_m68k_addr_mode_t mode, uint8_t reg, md_m68k_size_t size, uint32_t *value){    int cycles = 0;    uint32_t addr;    switch (mode)    {    case M68K_ADDR_MODE_DATA_REG_DIRECT:        // Ler de um registrador de dados        if (size == M68K_SIZE_BYTE)            *value = (md_m68k_get_data_reg(reg) & 0xFF);        else if (size == M68K_SIZE_WORD)            *value = (md_m68k_get_data_reg(reg) & 0xFFFF);        else // M68K_SIZE_LONG            *value = md_m68k_get_data_reg(reg);        cycles = 0; // Não há ciclos adicionais para leitura de registrador        break;    case M68K_ADDR_MODE_ADDR_REG_DIRECT:        // Ler de um registrador de endereço        if (size == M68K_SIZE_BYTE)            *value = (md_m68k_get_addr_reg(reg) & 0xFF);        else if (size == M68K_SIZE_WORD)            *value = (md_m68k_get_addr_reg(reg) & 0xFFFF);        else // M68K_SIZE_LONG            *value = md_m68k_get_addr_reg(reg);        cycles = 0; // Não há ciclos adicionais para leitura de registrador        break;    case M68K_ADDR_MODE_ADDR_REG_INDIRECT:        // Ler da memória no endereço contido no registrador de endereço        {            addr = md_m68k_get_addr_reg(reg);            if (size == M68K_SIZE_BYTE)                *value = md_m68k_read_memory_8(addr);            else if (size == M68K_SIZE_WORD)                *value = md_m68k_read_memory_16(addr);            else // M68K_SIZE_LONG                *value = md_m68k_read_memory_32(addr);            cycles = 4; // Ciclos aproximados        }        break;    case M68K_ADDR_MODE_ADDR_REG_INDIRECT_POST:        // (An)+        addr = md_m68k_get_addr_reg(reg);        if (size == M68K_SIZE_BYTE)            *value = md_m68k_read_memory_8(addr);        else if (size == M68K_SIZE_WORD)            *value = md_m68k_read_memory_16(addr);        else // M68K_SIZE_LONG            *value = md_m68k_read_memory_32(addr);        // Pós-incrementar o registrador        md_m68k_set_addr_reg(reg, addr + (size == M68K_SIZE_BYTE ? 1 :                                         size == M68K_SIZE_WORD ? 2 : 4));        cycles = 4;        break;    case M68K_ADDR_MODE_ADDR_REG_INDIRECT_PRE:        // -(An)        addr = md_m68k_get_addr_reg(reg) - (size == M68K_SIZE_BYTE ? 1 :                                           size == M68K_SIZE_WORD ? 2 : 4);        md_m68k_set_addr_reg(reg, addr);        if (size == M68K_SIZE_BYTE)            *value = md_m68k_read_memory_8(addr);        else if (size == M68K_SIZE_WORD)            *value = md_m68k_read_memory_16(addr);        else // M68K_SIZE_LONG            *value = md_m68k_read_memory_32(addr);        cycles = 6;        break;    case M68K_ADDR_MODE_ADDR_REG_INDIRECT_DISP:        // (d16,An)        addr = md_m68k_get_addr_reg(reg) + (int16_t)instruction->displacement;        if (size == M68K_SIZE_BYTE)            *value = md_m68k_read_memory_8(addr);        else if (size == M68K_SIZE_WORD)            *value = md_m68k_read_memory_16(addr);        else // M68K_SIZE_LONG            *value = md_m68k_read_memory_32(addr);        cycles = 8;        break;    case M68K_ADDR_MODE_ABSOLUTE_SHORT:        // (xxx).W        addr = (int16_t)instruction->immediate;        if (size == M68K_SIZE_BYTE)            *value = md_m68k_read_memory_8(addr);        else if (size == M68K_SIZE_WORD)            *value = md_m68k_read_memory_16(addr);        else // M68K_SIZE_LONG            *value = md_m68k_read_memory_32(addr);        cycles = 8;        break;    case M68K_ADDR_MODE_ABSOLUTE_LONG:        // (xxx).L        addr = instruction->immediate;        if (size == M68K_SIZE_BYTE)            *value = md_m68k_read_memory_8(addr);        else if (size == M68K_SIZE_WORD)            *value = md_m68k_read_memory_16(addr);        else // M68K_SIZE_LONG            *value = md_m68k_read_memory_32(addr);        cycles = 12;        break;    case M68K_ADDR_MODE_IMMEDIATE:        // #<data>        *value = instruction->immediate;        cycles = 4;        break;    default:        // Modo de endereçamento não implementado        printf("AVISO: Modo de endereçamento não implementado para leitura: %d\n", mode);        *value = 0;        cycles = 4;        break;    }    return cycles;}/** * @brief Escreve um valor em um operando * * @param mode Modo de endereçamento * @param reg Registrador * @param size Tamanho da operação * @param value Valor a ser escrito * @return int Número de ciclos adicionais */int md_m68k_write_operand(md_m68k_addr_mode_t mode, uint8_t reg, md_m68k_size_t size, uint32_t value){    int cycles = 0;    uint32_t addr;    switch (mode)    {    case M68K_ADDR_MODE_DATA_REG_DIRECT:        // Escrever em um registrador de dados        if (size == M68K_SIZE_BYTE)            md_m68k_set_data_reg(reg, (md_m68k_get_data_reg(reg) & 0xFFFFFF00) | (value & 0xFF));        else if (size == M68K_SIZE_WORD)            md_m68k_set_data_reg(reg, (md_m68k_get_data_reg(reg) & 0xFFFF0000) | (value & 0xFFFF));        else // M68K_SIZE_LONG            md_m68k_set_data_reg(reg, value);        cycles = 0; // Não há ciclos adicionais para escrita em registrador        break;    case M68K_ADDR_MODE_ADDR_REG_DIRECT:        // Escrever em um registrador de endereço        if (size == M68K_SIZE_WORD)            md_m68k_set_addr_reg(reg, (int16_t)value); // Extensão de sinal para WORD        else                                           // M68K_SIZE_LONG            md_m68k_set_addr_reg(reg, value);        cycles = 0; // Não há ciclos adicionais para escrita em registrador        break;    case M68K_ADDR_MODE_ADDR_REG_INDIRECT:        // Escrever na memória no endereço contido no registrador de endereço        {            addr = md_m68k_get_addr_reg(reg);            if (size == M68K_SIZE_BYTE)                md_m68k_write_memory_8(addr, value & 0xFF);            else if (size == M68K_SIZE_WORD)                md_m68k_write_memory_16(addr, value & 0xFFFF);            else // M68K_SIZE_LONG                md_m68k_write_memory_32(addr, value);            cycles = 4; // Ciclos aproximados        }        break;    case M68K_ADDR_MODE_ADDR_REG_INDIRECT_POST:        // (An)+        addr = md_m68k_get_addr_reg(reg);        if (size == M68K_SIZE_BYTE)            md_m68k_write_memory_8(addr, value);        else if (size == M68K_SIZE_WORD)            md_m68k_write_memory_16(addr, value);        else // M68K_SIZE_LONG            md_m68k_write_memory_32(addr, value);        // Pós-incrementar o registrador        md_m68k_set_addr_reg(reg, addr + (size == M68K_SIZE_BYTE ? 1 :                                         size == M68K_SIZE_WORD ? 2 : 4));        cycles = 4;        break;    case M68K_ADDR_MODE_ADDR_REG_INDIRECT_PRE:        // -(An)        addr = md_m68k_get_addr_reg(reg) - (size == M68K_SIZE_BYTE ? 1 :                                           size == M68K_SIZE_WORD ? 2 : 4);        md_m68k_set_addr_reg(reg, addr);        if (size == M68K_SIZE_BYTE)            md_m68k_write_memory_8(addr, value);        else if (size == M68K_SIZE_WORD)            md_m68k_write_memory_16(addr, value);        else // M68K_SIZE_LONG            md_m68k_write_memory_32(addr, value);        cycles = 6;        break;    case M68K_ADDR_MODE_ADDR_REG_INDIRECT_DISP:        // (d16,An)        addr = md_m68k_get_addr_reg(reg) + (int16_t)instruction->displacement;        if (size == M68K_SIZE_BYTE)            md_m68k_write_memory_8(addr, value);        else if (size == M68K_SIZE_WORD)            md_m68k_write_memory_16(addr, value);        else // M68K_SIZE_LONG            md_m68k_write_memory_32(addr, value);        cycles = 8;        break;    case M68K_ADDR_MODE_ABSOLUTE_SHORT:        // (xxx).W        addr = (int16_t)instruction->immediate;        if (size == M68K_SIZE_BYTE)            md_m68k_write_memory_8(addr, value);        else if (size == M68K_SIZE_WORD)            md_m68k_write_memory_16(addr, value);        else // M68K_SIZE_LONG            md_m68k_write_memory_32(addr, value);        cycles = 8;        break;    case M68K_ADDR_MODE_ABSOLUTE_LONG:        // (xxx).L        addr = instruction->immediate;        if (size == M68K_SIZE_BYTE)            md_m68k_write_memory_8(addr, value);        else if (size == M68K_SIZE_WORD)            md_m68k_write_memory_16(addr, value);        else // M68K_SIZE_LONG            md_m68k_write_memory_32(addr, value);        cycles = 12;        break;    case M68K_ADDR_MODE_IMMEDIATE:        // #<data>        cycles = 4;        break;    default:        // Modo de endereçamento não implementado        printf("AVISO: Modo de endereçamento não implementado para escrita: %d\n", mode);        cycles = 4;        break;    }    return cycles;}/** * @brief Atualiza as flags com base no resultado de uma operação * * @param result Resultado da operação * @param size Tamanho da operação * @param update_mask Máscara indicando quais flags devem ser atualizadas */void md_m68k_update_flags(uint32_t result, md_m68k_size_t size, uint16_t update_mask){    uint16_t ccr = md_m68k_get_sr() & 0xFF;    uint32_t mask;    // Determinar a máscara com base no tamanho    if (size == M68K_SIZE_BYTE)        mask = 0xFF;    else if (size == M68K_SIZE_WORD)        mask = 0xFFFF;    else // M68K_SIZE_LONG        mask = 0xFFFFFFFF;    // Atualizar cada flag se necessário    if (update_mask & 0x01)    { // N - Negative        if (result & (mask >> 1) + 1)            ccr |= 0x08;        else            ccr &= ~0x08;    }    if (update_mask & 0x02)    { // Z - Zero        if ((result & mask) == 0)            ccr |= 0x04;        else            ccr &= ~0x04;    }    if (update_mask & 0x04)    { // V - Overflow (simplificado)        // Normalmente calculado durante a instrução específica        ccr &= ~0x02;    }    if (update_mask & 0x08)    { // C - Carry (simplificado)        // Normalmente calculado durante a instrução específica        ccr &= ~0x01;    }    // Atualizar o registrador de status    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);}/** * @brief Avalia uma condição com base nas flags do processador * * @param condition Código da condição a ser avaliada * @return int 1 se a condição for verdadeira, 0 caso contrário */int md_m68k_evaluate_condition(uint8_t condition){    uint16_t sr = md_m68k_get_sr();    int n = (sr >> 3) & 1; // Negative flag    int z = (sr >> 2) & 1; // Zero flag    int v = (sr >> 1) & 1; // Overflow flag    int c = sr & 1;        // Carry flag    switch (condition)    {    case 0x0:        return 1; // T - True    case 0x1:        return 0; // F - False    case 0x2:        return !c && !z; // HI - High    case 0x3:        return c || z; // LS - Low or Same    case 0x4:        return !c; // CC/HS - Carry Clear/Higher or Same    case 0x5:        return c; // CS/LO - Carry Set/Lower    case 0x6:        return !z; // NE - Not Equal    case 0x7:        return z; // EQ - Equal    case 0x8:        return !v; // VC - Overflow Clear    case 0x9:        return v; // VS - Overflow Set    case 0xA:        return !n; // PL - Plus    case 0xB:        return n; // MI - Minus    case 0xC:        return n == v; // GE - Greater or Equal    case 0xD:        return n != v; // LT - Less Than    case 0xE:        return !z && (n == v); // GT - Greater Than    case 0xF:        return z || (n != v); // LE - Less or Equal    default:        return 0;    }}/* Implementações de instruções específicas *//** * @brief Executa a instrução MOVE * * @param instruction Ponteiro para a instrução * @return int Ciclos adicionais */static int execute_move(const md_m68k_instruction_t *instruction){    uint32_t value;    int cycles = 0;    // Ler o valor da fonte    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                   instruction->size, &value);    // Escrever o valor no destino    cycles += md_m68k_write_operand(instruction->dst_mode, instruction->dst_reg,                                    instruction->size, value);    // Atualizar as flags N, Z, V e C    md_m68k_update_flags(value, instruction->size, 0x0F);    return cycles;}/** * @brief Executa a instrução NOP * * @param instruction Ponteiro para a instrução * @return int Ciclos adicionais */static int execute_nop(const md_m68k_instruction_t *instruction){    // NOP não faz nada    (void)instruction; // Evitar warning de parâmetro não utilizado    return 0;}/** * @brief Executa a instrução RTS * * @param instruction Ponteiro para a instrução * @return int Ciclos adicionais */static int execute_rts(const md_m68k_instruction_t *instruction){    (void)instruction; // Evitar warning de parâmetro não utilizado    // Recuperar o endereço de retorno da pilha    uint32_t sp = md_m68k_get_addr_reg(7); // A7 = SP    uint32_t ret_addr = md_m68k_read_memory_32(sp);    // Atualizar o SP    md_m68k_set_addr_reg(7, sp + 4);    // Atualizar o PC    md_m68k_set_pc(ret_addr);    return 0;}/** * @brief Executa a instrução ADD */static int execute_add(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value, result;    int cycles = 0;    // Ler operando fonte    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  instruction->size, &src_value);    // Ler operando destino    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &dst_value);    // Realizar a adição    result = dst_value + src_value;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (result & (1 << (instruction->size * 8 - 1)))        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if ((result & ((1 << (instruction->size * 8)) - 1)) == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V - Overflow (simplificado)    if ((src_value & dst_value & ~result & 0x80000000) ||        (~src_value & ~dst_value & result & 0x80000000))        ccr |= 0x02;    else        ccr &= ~0x02;    // C - Carry    if (result < src_value || result < dst_value)        ccr |= 0x01;    else        ccr &= ~0x01;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles;}/** * @brief Executa a instrução SUB */static int execute_sub(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value, result;    int cycles = 0;    // Ler operando fonte    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  instruction->size, &src_value);    // Ler operando destino    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &dst_value);    // Realizar a subtração    result = dst_value - src_value;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    // Atualizar flags (similar ao ADD)    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (result & (1 << (instruction->size * 8 - 1)))        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if ((result & ((1 << (instruction->size * 8)) - 1)) == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V - Overflow (simplificado)    if ((src_value & ~dst_value & ~result & 0x80000000) ||        (~src_value & dst_value & result & 0x80000000))        ccr |= 0x02;    else        ccr &= ~0x02;    // C - Carry    if (src_value > dst_value)        ccr |= 0x01;    else        ccr &= ~0x01;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles;}/** * @brief Executa a instrução AND */static int execute_and(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value, result;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  instruction->size, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &dst_value);    // Realizar AND    result = dst_value & src_value;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    // Atualizar flags N e Z    md_m68k_update_flags(result, instruction->size, 0x0C);    return cycles;}/** * @brief Executa a instrução OR */static int execute_or(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value, result;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  instruction->size, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &dst_value);    // Realizar OR    result = dst_value | src_value;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    // Atualizar flags N e Z    md_m68k_update_flags(result, instruction->size, 0x0C);    return cycles;}/** * @brief Executa a instrução BRA (Branch Always) */static int execute_bra(const md_m68k_instruction_t *instruction) {    // Calcular o endereço de destino    int32_t displacement = (int8_t)instruction->displacement;    uint32_t target = md_m68k_get_pc() + displacement;    // Atualizar PC    md_m68k_set_pc(target);    return 0;}/** * @brief Executa a instrução BSR (Branch to Subroutine) */static int execute_bsr(const md_m68k_instruction_t *instruction) {    int cycles = 0;    uint32_t return_addr = md_m68k_get_pc();    // Empilhar endereço de retorno    uint32_t sp = md_m68k_get_addr_reg(7) - 4;    md_m68k_set_addr_reg(7, sp);    md_m68k_write_memory_32(sp, return_addr);    cycles += 8; // Ciclos para escrita na pilha    // Calcular e saltar para o endereço de destino    int32_t displacement = (int8_t)instruction->displacement;    uint32_t target = md_m68k_get_pc() + displacement;    md_m68k_set_pc(target);    return cycles;}/** * @brief Executa a instrução Bcc (Branch Conditionally) */static int execute_bcc(const md_m68k_instruction_t *instruction) {    // Avaliar a condição    if (md_m68k_evaluate_condition(instruction->condition)) {        // Condição verdadeira - realizar o branch        int32_t displacement = (int8_t)instruction->displacement;        uint32_t target = md_m68k_get_pc() + displacement;        md_m68k_set_pc(target);        return 0; // Ciclos já incluídos no cycles_base    }    return -4; // Subtrair ciclos se o branch não for tomado}/** * @brief Executa a instrução MULS (Multiply Signed) */static int execute_muls(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  M68K_SIZE_WORD, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  M68K_SIZE_WORD, &dst_value);    // Realizar multiplicação com sinal    int32_t result = (int16_t)src_value * (int16_t)dst_value;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   M68K_SIZE_LONG, result);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (result < 0)        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if (result == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V, C são sempre zerados    ccr &= ~0x03;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 70; // Ciclos base para multiplicação}/** * @brief Executa a instrução MULU (Multiply Unsigned) */static int execute_mulu(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  M68K_SIZE_WORD, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  M68K_SIZE_WORD, &dst_value);    // Realizar multiplicação sem sinal    uint32_t result = (uint16_t)src_value * (uint16_t)dst_value;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   M68K_SIZE_LONG, result);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (result & 0x80000000)        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if (result == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V, C são sempre zerados    ccr &= ~0x03;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 70; // Ciclos base para multiplicação}/** * @brief Executa a instrução LSL (Logical Shift Left) */static int execute_lsl(const md_m68k_instruction_t *instruction) {    uint32_t value, count;    int cycles = 0;    // Obter o valor a ser deslocado    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &value);    // Obter contagem de deslocamento    if (instruction->src_mode == M68K_ADDR_MODE_IMMEDIATE)        count = instruction->immediate & 0x3F; // Máximo 63 posições    else        count = md_m68k_get_data_reg(instruction->src_reg) & 0x3F;    // Realizar deslocamento    uint32_t result = value << count;    uint32_t mask = (instruction->size == M68K_SIZE_BYTE ? 0xFF :                     instruction->size == M68K_SIZE_WORD ? 0xFFFF : 0xFFFFFFFF);    result &= mask;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (result & (1 << (instruction->size * 8 - 1)))        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if (result == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // X, C - Último bit deslocado para fora    if (count > 0 && (value & (1 << (instruction->size * 8 - count))))        ccr |= 0x11;    else        ccr &= ~0x11;    // V é sempre zerado    ccr &= ~0x02;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + (count * 2); // 2 ciclos por posição}/** * @brief Executa a instrução LSR (Logical Shift Right) */static int execute_lsr(const md_m68k_instruction_t *instruction) {    uint32_t value, count;    int cycles = 0;    // Obter o valor a ser deslocado    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &value);    // Obter contagem de deslocamento    if (instruction->src_mode == M68K_ADDR_MODE_IMMEDIATE)        count = instruction->immediate & 0x3F;    else        count = md_m68k_get_data_reg(instruction->src_reg) & 0x3F;    // Realizar deslocamento    uint32_t result = value >> count;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N é sempre zerado    ccr &= ~0x08;    // Z - Zero    if (result == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // X, C - Último bit deslocado para fora    if (count > 0 && (value & (1 << (count - 1))))        ccr |= 0x11;    else        ccr &= ~0x11;    // V é sempre zerado    ccr &= ~0x02;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + (count * 2); // 2 ciclos por posição}/** * @brief Executa a instrução DIVS (Divide Signed) */static int execute_divs(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  M68K_SIZE_WORD, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  M68K_SIZE_LONG, &dst_value);    // Converter para valores com sinal    int32_t dividend = (int32_t)dst_value;    int16_t divisor = (int16_t)src_value;    // Verificar divisão por zero    if (divisor == 0) {        // Gerar trap de divisão por zero        printf("ERRO: Divisão por zero em DIVS\n");        return cycles + 8;    }    // Realizar divisão    int32_t quotient = dividend / divisor;    int16_t remainder = dividend % divisor;    // Verificar overflow    if (quotient > 32767 || quotient < -32768) {        // Overflow - setar flag V e não armazenar resultado        uint16_t ccr = md_m68k_get_sr() & 0xFF;        ccr |= 0x02; // Set V        md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);        return cycles + 8;    }    // Combinar quociente e resto    uint32_t result = ((uint32_t)(remainder & 0xFFFF) << 16) | (quotient & 0xFFFF);    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   M68K_SIZE_LONG, result);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (quotient < 0)        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if (quotient == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V, C são zerados    ccr &= ~0x03;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 158; // Ciclos base para divisão}/** * @brief Executa a instrução DIVU (Divide Unsigned) */static int execute_divu(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  M68K_SIZE_WORD, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  M68K_SIZE_LONG, &dst_value);    // Verificar divisão por zero    if (src_value == 0) {        // Gerar trap de divisão por zero        printf("ERRO: Divisão por zero em DIVU\n");        return cycles + 8;    }    // Realizar divisão sem sinal    uint32_t quotient = dst_value / src_value;    uint16_t remainder = dst_value % src_value;    // Verificar overflow    if (quotient > 0xFFFF) {        // Overflow - setar flag V e não armazenar resultado        uint16_t ccr = md_m68k_get_sr() & 0xFF;        ccr |= 0x02; // Set V        md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);        return cycles + 8;    }    // Combinar quociente e resto    uint32_t result = ((uint32_t)remainder << 16) | (quotient & 0xFFFF);    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   M68K_SIZE_LONG, result);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (quotient & 0x8000)        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if ((quotient & 0xFFFF) == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V, C são zerados    ccr &= ~0x03;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 140; // Ciclos base para divisão}/** * @brief Executa a instrução ASL (Arithmetic Shift Left) */static int execute_asl(const md_m68k_instruction_t *instruction) {    uint32_t value, count;    int cycles = 0;    // Obter o valor a ser deslocado    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &value);    // Obter contagem de deslocamento    if (instruction->src_mode == M68K_ADDR_MODE_IMMEDIATE)        count = instruction->immediate & 0x3F; // Máximo 63 posições    else        count = md_m68k_get_data_reg(instruction->src_reg) & 0x3F;    // Realizar deslocamento    uint32_t result = value;    uint32_t msb_mask = 1 << (instruction->size * 8 - 1);    uint32_t old_msb = result & msb_mask;    uint32_t mask = (instruction->size == M68K_SIZE_BYTE ? 0xFF :                     instruction->size == M68K_SIZE_WORD ? 0xFFFF : 0xFFFFFFFF);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    ccr &= ~0x1F; // Limpar X,N,Z,V,C    if (count > 0) {        result = (result << count) & mask;        // X,C - Último bit deslocado para fora        if (value & (1 << (instruction->size * 8 - count)))            ccr |= 0x11;        // N - Negative        if (result & msb_mask)            ccr |= 0x08;        // Z - Zero        if ((result & mask) == 0)            ccr |= 0x04;        // V - Set se o bit de sinal mudou durante o deslocamento        uint32_t new_msb = result & msb_mask;        if (old_msb != new_msb)            ccr |= 0x02;    }    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    return cycles + (count * 2); // 2 ciclos por posição}/** * @brief Executa a instrução ASR (Arithmetic Shift Right) */static int execute_asr(const md_m68k_instruction_t *instruction) {    uint32_t value, count;    int cycles = 0;    // Obter o valor a ser deslocado    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &value);    // Obter contagem de deslocamento    if (instruction->src_mode == M68K_ADDR_MODE_IMMEDIATE)        count = instruction->immediate & 0x3F;    else        count = md_m68k_get_data_reg(instruction->src_reg) & 0x3F;    // Realizar deslocamento    uint32_t result = value;    uint32_t msb_mask = 1 << (instruction->size * 8 - 1);    uint32_t msb = result & msb_mask;    uint32_t mask = (instruction->size == M68K_SIZE_BYTE ? 0xFF :                     instruction->size == M68K_SIZE_WORD ? 0xFFFF : 0xFFFFFFFF);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    ccr &= ~0x1F; // Limpar X,N,Z,V,C    if (count > 0) {        // Deslocamento aritmético mantém o bit de sinal        for (uint32_t i = 0; i < count; i++) {            // X,C recebem o último bit deslocado para fora            if (result & 1)                ccr |= 0x11;            else                ccr &= ~0x11;            result = (result >> 1) & mask;            if (msb) // Replicar o bit de sinal                result |= msb;        }        // N - Negative (mantido do bit de sinal original)        if (msb)            ccr |= 0x08;        // Z - Zero        if ((result & mask) == 0)            ccr |= 0x04;        // V é sempre zerado em ASR        ccr &= ~0x02;    }    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    return cycles + (count * 2); // 2 ciclos por posição}/** * @brief Executa a instrução ADDX (Add with Extend) */static int execute_addx(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value, result;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  instruction->size, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &dst_value);    // Obter X flag    uint16_t sr = md_m68k_get_sr();    int x_flag = (sr & 0x10) ? 1 : 0;    // Realizar adição com extensão    result = dst_value + src_value + x_flag;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    // Atualizar flags    uint16_t ccr = sr & 0xFF;    uint32_t mask = (instruction->size == M68K_SIZE_BYTE ? 0xFF :                     instruction->size == M68K_SIZE_WORD ? 0xFFFF : 0xFFFFFFFF);    // N - Negative    if (result & (1 << (instruction->size * 8 - 1)))        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero (não é limpo se o resultado é diferente de zero)    if ((result & mask) == 0)        ccr |= 0x04;    // V - Overflow    if ((src_value & dst_value & ~result & 0x80000000) ||        (~src_value & ~dst_value & result & 0x80000000))        ccr |= 0x02;    else        ccr &= ~0x02;    // C,X - Carry e Extend    if (result < src_value || (result == src_value && x_flag))        ccr |= 0x11;    else        ccr &= ~0x11;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 4;}/** * @brief Executa a instrução SUBX (Subtract with Extend) */static int execute_subx(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value, result;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  instruction->size, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size, &dst_value);    // Obter X flag    uint16_t sr = md_m68k_get_sr();    int x_flag = (sr & 0x10) ? 1 : 0;    // Realizar subtração com extensão    result = dst_value - src_value - x_flag;    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, result);    // Atualizar flags    uint16_t ccr = sr & 0xFF;    uint32_t mask = (instruction->size == M68K_SIZE_BYTE ? 0xFF :                     instruction->size == M68K_SIZE_WORD ? 0xFFFF : 0xFFFFFFFF);    // N - Negative    if (result & (1 << (instruction->size * 8 - 1)))        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero (não é limpo se o resultado é diferente de zero)    if ((result & mask) == 0)        ccr |= 0x04;    // V - Overflow    if ((src_value & ~dst_value & ~result & 0x80000000) ||        (~src_value & dst_value & result & 0x80000000))        ccr |= 0x02;    else        ccr &= ~0x02;    // C,X - Carry e Extend    if (src_value + x_flag > dst_value)        ccr |= 0x11;    else        ccr &= ~0x11;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 4;}/** * @brief Executa a instrução BCHG (Test a Bit and Change) */static int execute_bchg(const md_m68k_instruction_t *instruction) {    uint32_t value;    int cycles = 0;    // Ler operando    cycles += md_m68k_read_operand(instruction->dst_mode, instruction->dst_reg,                                  instruction->size, &value);    // Obter número do bit    uint8_t bit_num;    if (instruction->src_mode == M68K_ADDR_MODE_IMMEDIATE)        bit_num = instruction->immediate & 0x1F;    else        bit_num = md_m68k_get_data_reg(instruction->src_reg) & 0x1F;    // Testar bit    uint32_t bit_mask = 1 << bit_num;    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // Z - Zero (setado se o bit era zero)    if (!(value & bit_mask))        ccr |= 0x04;    else        ccr &= ~0x04;    // Inverter o bit    value ^= bit_mask;    // Escrever resultado    cycles += md_m68k_write_operand(instruction->dst_mode, instruction->dst_reg,                                   instruction->size, value);    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 8;}/** * @brief Executa a instrução BCLR (Test a Bit and Clear) */static int execute_bclr(const md_m68k_instruction_t *instruction) {    uint32_t value;    int cycles = 0;    // Ler operando    cycles += md_m68k_read_operand(instruction->dst_mode, instruction->dst_reg,                                  instruction->size, &value);    // Obter número do bit    uint8_t bit_num;    if (instruction->src_mode == M68K_ADDR_MODE_IMMEDIATE)        bit_num = instruction->immediate & 0x1F;    else        bit_num = md_m68k_get_data_reg(instruction->src_reg) & 0x1F;    // Testar bit    uint32_t bit_mask = 1 << bit_num;    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // Z - Zero (setado se o bit era zero)    if (!(value & bit_mask))        ccr |= 0x04;    else        ccr &= ~0x04;    // Limpar o bit    value &= ~bit_mask;    // Escrever resultado    cycles += md_m68k_write_operand(instruction->dst_mode, instruction->dst_reg,                                   instruction->size, value);    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 8;}/** * @brief Executa a instrução BSET (Test a Bit and Set) */static int execute_bset(const md_m68k_instruction_t *instruction) {    uint32_t value;    int cycles = 0;    // Ler operando    cycles += md_m68k_read_operand(instruction->dst_mode, instruction->dst_reg,                                  instruction->size, &value);    // Obter número do bit    uint8_t bit_num;    if (instruction->src_mode == M68K_ADDR_MODE_IMMEDIATE)        bit_num = instruction->immediate & 0x1F;    else        bit_num = md_m68k_get_data_reg(instruction->src_reg) & 0x1F;    // Testar bit    uint32_t bit_mask = 1 << bit_num;    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // Z - Zero (setado se o bit era zero)    if (!(value & bit_mask))        ccr |= 0x04;    else        ccr &= ~0x04;    // Setar o bit    value |= bit_mask;    // Escrever resultado    cycles += md_m68k_write_operand(instruction->dst_mode, instruction->dst_reg,                                   instruction->size, value);    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 8;}/** * @brief Executa a instrução BTST (Test a Bit) */static int execute_btst(const md_m68k_instruction_t *instruction) {    uint32_t value;    int cycles = 0;    // Ler operando    cycles += md_m68k_read_operand(instruction->dst_mode, instruction->dst_reg,                                  instruction->size, &value);    // Obter número do bit    uint8_t bit_num;    if (instruction->src_mode == M68K_ADDR_MODE_IMMEDIATE)        bit_num = instruction->immediate & 0x1F;    else        bit_num = md_m68k_get_data_reg(instruction->src_reg) & 0x1F;    // Testar bit    uint32_t bit_mask = 1 << bit_num;    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // Z - Zero (setado se o bit é zero)    if (!(value & bit_mask))        ccr |= 0x04;    else        ccr &= ~0x04;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 4;}/** * @brief Executa a instrução ABCD (Add Decimal with Extend) */static int execute_abcd(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  M68K_SIZE_BYTE, &src_value);    cycles += md_m68k_read_operand(instruction->dst_mode, instruction->dst_reg,                                  M68K_SIZE_BYTE, &dst_value);    // Obter X flag    uint16_t sr = md_m68k_get_sr();    int x_flag = (sr & 0x10) ? 1 : 0;    // Realizar adição BCD    uint8_t src_lo = src_value & 0x0F;    uint8_t src_hi = (src_value >> 4) & 0x0F;    uint8_t dst_lo = dst_value & 0x0F;    uint8_t dst_hi = (dst_value >> 4) & 0x0F;    // Adicionar dígitos menos significativos    int temp = dst_lo + src_lo + x_flag;    uint8_t result_lo = temp % 10;    int carry = temp >= 10 ? 1 : 0;    // Adicionar dígitos mais significativos    temp = dst_hi + src_hi + carry;    uint8_t result_hi = temp % 10;    carry = temp >= 10 ? 1 : 0;    // Combinar resultado    uint8_t result = (result_hi << 4) | result_lo;    // Escrever resultado    cycles += md_m68k_write_operand(instruction->dst_mode, instruction->dst_reg,                                   M68K_SIZE_BYTE, result);    // Atualizar flags    uint16_t ccr = sr & 0xFF;    // Z - Zero (não é limpo se o resultado é diferente de zero)    if (result == 0)        ccr |= 0x04;    // C,X - Carry e Extend    if (carry)        ccr |= 0x11;    else        ccr &= ~0x11;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 6;}/** * @brief Executa a instrução SBCD (Subtract Decimal with Extend) */static int execute_sbcd(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  M68K_SIZE_BYTE, &src_value);    cycles += md_m68k_read_operand(instruction->dst_mode, instruction->dst_reg,                                  M68K_SIZE_BYTE, &dst_value);    // Obter X flag    uint16_t sr = md_m68k_get_sr();    int x_flag = (sr & 0x10) ? 1 : 0;    // Realizar subtração BCD    uint8_t src_lo = src_value & 0x0F;    uint8_t src_hi = (src_value >> 4) & 0x0F;    uint8_t dst_lo = dst_value & 0x0F;    uint8_t dst_hi = (dst_value >> 4) & 0x0F;    // Subtrair dígitos menos significativos    int borrow = 0;    int temp = dst_lo - src_lo - x_flag;    uint8_t result_lo;    if (temp < 0) {        temp += 10;        borrow = 1;    }    result_lo = temp;    // Subtrair dígitos mais significativos    temp = dst_hi - src_hi - borrow;    uint8_t result_hi;    if (temp < 0) {        temp += 10;        borrow = 1;    } else {        borrow = 0;    }    result_hi = temp;    // Combinar resultado    uint8_t result = (result_hi << 4) | result_lo;    // Escrever resultado    cycles += md_m68k_write_operand(instruction->dst_mode, instruction->dst_reg,                                   M68K_SIZE_BYTE, result);    // Atualizar flags    uint16_t ccr = sr & 0xFF;    // Z - Zero (não é limpo se o resultado é diferente de zero)    if (result == 0)        ccr |= 0x04;    // C,X - Carry e Extend    if (borrow)        ccr |= 0x11;    else        ccr &= ~0x11;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 6;}/** * @brief Executa a instrução CMPM (Compare Memory) */static int execute_cmpm(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value;    int cycles = 0;    // Ler operandos (pós-incremento)    cycles += md_m68k_read_operand(M68K_ADDR_MODE_ADDR_REG_INDIRECT_POST, instruction->src_reg,                                  instruction->size, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_ADDR_REG_INDIRECT_POST, instruction->dst_reg,                                  instruction->size, &dst_value);    // Realizar comparação (subtração sem armazenar resultado)    uint32_t result = dst_value - src_value;    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    uint32_t mask = (instruction->size == M68K_SIZE_BYTE ? 0xFF :                     instruction->size == M68K_SIZE_WORD ? 0xFFFF : 0xFFFFFFFF);    // N - Negative    if (result & (1 << (instruction->size * 8 - 1)))        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if ((result & mask) == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V - Overflow    if ((src_value & ~dst_value & ~result & 0x80000000) ||        (~src_value & dst_value & result & 0x80000000))        ccr |= 0x02;    else        ccr &= ~0x02;    // C - Carry    if (src_value > dst_value)        ccr |= 0x01;    else        ccr &= ~0x01;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 12;}/** * @brief Executa a instrução CMPA (Compare Address) */static int execute_cmpa(const md_m68k_instruction_t *instruction) {    uint32_t src_value, dst_value;    int cycles = 0;    // Ler operandos    cycles += md_m68k_read_operand(instruction->src_mode, instruction->src_reg,                                  instruction->size, &src_value);    cycles += md_m68k_read_operand(M68K_ADDR_MODE_ADDR_REG_DIRECT, instruction->dst_reg,                                  M68K_SIZE_LONG, &dst_value);    // Extensão de sinal para o operando fonte se necessário    if (instruction->size == M68K_SIZE_WORD)        src_value = (int16_t)src_value;    // Realizar comparação (subtração sem armazenar resultado)    uint32_t result = dst_value - src_value;    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (result & 0x80000000)        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if (result == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V - Overflow    if ((src_value & ~dst_value & ~result & 0x80000000) ||        (~src_value & dst_value & result & 0x80000000))        ccr |= 0x02;    else        ccr &= ~0x02;    // C - Carry    if (src_value > dst_value)        ccr |= 0x01;    else        ccr &= ~0x01;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 6;}/** * @brief Executa a instrução EXT (Sign Extend) */static int execute_ext(const md_m68k_instruction_t *instruction) {    uint32_t value;    int cycles = 0;    // Ler operando    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  instruction->size == M68K_SIZE_WORD ? M68K_SIZE_BYTE : M68K_SIZE_WORD,                                  &value);    // Realizar extensão de sinal    if (instruction->size == M68K_SIZE_WORD) {        // Byte para Word        value = (int8_t)value;    } else {        // Word para Long        value = (int16_t)value;    }    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   instruction->size, value);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (value & (instruction->size == M68K_SIZE_WORD ? 0x8000 : 0x80000000))        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if (value == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V,C são sempre zerados    ccr &= ~0x03;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 4;}/** * @brief Executa a instrução SWAP (Swap Register Halves) */static int execute_swap(const md_m68k_instruction_t *instruction) {    uint32_t value;    int cycles = 0;    // Ler operando    cycles += md_m68k_read_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                  M68K_SIZE_LONG, &value);    // Trocar words    value = ((value & 0xFFFF) << 16) | ((value >> 16) & 0xFFFF);    // Escrever resultado    cycles += md_m68k_write_operand(M68K_ADDR_MODE_DATA_REG_DIRECT, instruction->dst_reg,                                   M68K_SIZE_LONG, value);    // Atualizar flags    uint16_t ccr = md_m68k_get_sr() & 0xFF;    // N - Negative    if (value & 0x80000000)        ccr |= 0x08;    else        ccr &= ~0x08;    // Z - Zero    if (value == 0)        ccr |= 0x04;    else        ccr &= ~0x04;    // V,C são sempre zerados    ccr &= ~0x03;    md_m68k_set_sr((md_m68k_get_sr() & 0xFF00) | ccr);    return cycles + 4;}