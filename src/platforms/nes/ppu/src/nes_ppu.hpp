#include <stdint.h>/** * @file nes_ppu.hpp * @brief Definição da classe NESPPU para a Picture Processing Unit do NES em C++ * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-13 */#pragma once#include <cstdint>#include <memory>#include <string>#include <vector>#include <array>#include <functional>// Compatibilidade com código Cextern "C"{#include "nes_ppu.h"}namespace MegaEmu{    namespace Platforms    {        namespace NES        {            // Forward declarations            class NESCPU;            /**             * @enum MirrorMode             * @brief Modos de espelhamento de VRAM para o NES             */            enum class MirrorMode            {                Horizontal = NES_MIRROR_HORIZONTAL,                Vertical = NES_MIRROR_VERTICAL,                SingleScreenA = NES_MIRROR_SINGLE_SCREEN_A,                SingleScreenB = NES_MIRROR_SINGLE_SCREEN_B,                FourScreen = NES_MIRROR_FOUR_SCREEN            };            // Estruturas para renderização            struct Tile            {                std::array<uint8_t, 16> data; // 8x8 pixels, 2 bits por pixel                uint8_t getPixel(int32_t x, int32_t y) const                {                    int32_t byte_idx = y;                    int32_t bit_idx = 7 - x;                    uint8_t low_bit = (data[byte_idx] >> bit_idx) & 1;                    uint8_t high_bit = (data[byte_idx + 8] >> bit_idx) & 1;                    return (high_bit << 1) | low_bit;                }            };            struct Sprite            {                uint8_t y;          // Posição Y                uint8_t tile_index; // Índice do tile                uint8_t attributes; // Atributos (paleta, flip, prioridade)                uint8_t x;          // Posição X            };            // Estrutura otimizada de cache de tiles            struct TileCacheOptimized {                struct CacheEntry {                    Tile tile;                    uint16_t patternTable;                    uint8_t tileIndex;                    uint32_t lastAccess;                    bool valid;                };                static constexpr size_t CACHE_SIZE = 512;                std::array<CacheEntry, CACHE_SIZE> entries;                uint32_t accessCounter;                void invalidate() {                    for (auto &entry : entries) {                        entry.valid = false;                    }                    accessCounter = 0;                }                size_t getOptimalIndex(uint16_t patternTable, uint8_t tileIndex) {                    size_t lruIndex = 0;                    uint32_t oldestAccess = UINT32_MAX;                    for (size_t i = 0; i < CACHE_SIZE; ++i) {                        if (!entries[i].valid) return i;                        if (entries[i].patternTable == patternTable &&                            entries[i].tileIndex == tileIndex) return i;                        if (entries[i].lastAccess < oldestAccess) {                            oldestAccess = entries[i].lastAccess;                            lruIndex = i;                        }                    }                    return lruIndex;                }            };            // Sistema de prefetch otimizado            struct PrefetchSystemOptimized {                struct PrefetchEntry {                    uint16_t addr;                    uint8_t data;                    uint8_t priority;                    bool valid;                };                static constexpr size_t QUEUE_SIZE = 16;                std::array<PrefetchEntry, QUEUE_SIZE> entries;                size_t head;                size_t tail;                bool enabled;                void initialize() {                    head = tail = 0;                    enabled = true;                    for (auto &entry : entries) {                        entry.valid = false;                        entry.priority = 0;                    }                }                void push(uint16_t addr, uint8_t data, uint8_t priority) {                    if (!enabled) return;                    size_t nextTail = (tail + 1) % QUEUE_SIZE;                    if (nextTail != head) {                        entries[tail] = {addr, data, priority, true};                        tail = nextTail;                    }                }                bool pop(uint16_t &addr, uint8_t &data) {                    if (head == tail) return false;                    size_t highestPriorityIdx = head;                    uint8_t highestPriority = entries[head].priority;                    for (size_t i = head; i != tail; i = (i + 1) % QUEUE_SIZE) {                        if (entries[i].priority > highestPriority) {                            highestPriority = entries[i].priority;                            highestPriorityIdx = i;                        }                    }                    if (highestPriorityIdx != head) {                        std::swap(entries[head], entries[highestPriorityIdx]);                    }                    addr = entries[head].addr;                    data = entries[head].data;                    entries[head].valid = false;                    head = (head + 1) % QUEUE_SIZE;                    return true;                }            };            /**             * @class NESPPU             * @brief Implementação C++ da Picture Processing Unit (PPU) do NES             *             * Esta classe encapsula a funcionalidade do PPU do NES e fornece             * uma interface mais orientada a objetos para interação com outros             * componentes do sistema.             */            class NESPPU            {            public:                static constexpr int32_t SCREEN_WIDTH = 256;                static constexpr int32_t SCREEN_HEIGHT = 240;                static constexpr int32_t VRAM_SIZE = 0x4000;                static constexpr int32_t OAM_SIZE = 256;                static constexpr int32_t TILES_PER_TABLE = 256;                static constexpr int32_t PATTERN_TABLE_SIZE = 0x1000;                // Tipos de callbacks                using NMICallback = std::function<void(void)>;                using IRQCallback = std::function<void(void)>;                // Interface CPU-PPU                struct CPUInterface                {                    uint8_t *cpuMemory;      // Ponteiro para memória da CPU                    NMICallback nmiCallback; // Callback para NMI                    IRQCallback irqCallback; // Callback para IRQ                };                /**                 * @brief Construtor da classe NESPPU                 * @param cpu Ponteiro para a CPU                 * @param cartridge Ponteiro para o cartucho                 */                NESPPU(void *cpu, void *cartridge);                /**                 * @brief Destrutor da classe NESPPU                 */                ~NESPPU();                /**                 * @brief Inicializa o PPU                 */                void initialize();                /**                 * @brief Reseta o PPU para seu estado inicial                 */                void reset();                /**                 * @brief Lê um registrador do PPU                 * @param addr Endereço do registrador (0x2000-0x2007)                 * @return Valor lido do registrador                 */                uint8_t readRegister(uint16_t addr) const;                /**                 * @brief Escreve em um registrador do PPU                 * @param addr Endereço do registrador (0x2000-0x2007)                 * @param value Valor a ser escrito                 */                void writeRegister(uint16_t addr, uint8_t value);                /**                 * @brief Executa um ciclo do PPU                 */                void step();                /**                 * @brief Executa um quadro completo do PPU                 */                void executeFrame();                /**                 * @brief Atualiza o PPU por um número específico de ciclos                 * @param cycles Número de ciclos a executar                 */                void update(uint32_t cycles);                /**                 * @brief Renderiza o quadro atual no buffer fornecido                 * @param frameBuffer Buffer para render (deve ter tamanho adequado)                 */                void renderFrame(uint32_t *frameBuffer);                /**                 * @brief Obtém o buffer de quadro interno                 * @return Ponteiro para o buffer de quadro                 */                const uint32_t *getFrameBuffer() const;                /**                 * @brief Verifica se um quadro foi completado                 * @return true se um quadro foi completado                 */                bool isFrameComplete() const;                /**                 * @brief Define o modo de espelhamento                 * @param mode Modo de espelhamento                 */                void setMirrorMode(MirrorMode mode);                /**                 * @brief Verifica se uma NMI foi disparada                 * @return true se uma NMI foi disparada                 */                bool isNMITriggered() const;                /**                 * @brief Limpa o sinalizador de NMI                 */                void clearNMI();                /**                 * @brief Realiza uma transferência DMA para a OAM                 * @param data Ponteiro para os dados a serem transferidos                 */                void oamDMA(const uint8_t *data);                /**                 * @brief Lê um uint8_t da paleta de cores                 * @param address Endereço da paleta (0-31)                 * @return Valor da cor na paleta                 */                uint8_t readPalette(uint8_t address) const;                /**                 * @brief Lê um uint8_t da memória do PPU                 * @param addr Endereço (0-0x3FFF)                 * @return Valor lido                 */                uint8_t read(uint16_t addr) const;                /**                 * @brief Escreve um uint8_t na memória do PPU                 * @param addr Endereço (0-0x3FFF)                 * @param value Valor a ser escrito                 */                void write(uint16_t addr, uint8_t value);                /**                 * @brief Lê um uint8_t da OAM                 * @param addr Endereço (0-0xFF)                 * @return Valor lido                 */                uint8_t readOAM(uint16_t addr) const;                /**                 * @brief Escreve um uint8_t na OAM                 * @param addr Endereço (0-0xFF)                 * @param value Valor a ser escrito                 */                void writeOAM(uint16_t addr, uint8_t value);                /**                 * @brief Obtém o contador de frames                 * @return Número de frames processados                 */                uint32_t getFrameCount() const;                /**                 * @brief Obtém a scanline atual                 * @return Número da scanline atual                 */                int16_t getCurrentScanline() const;                /**                 * @brief Obtém o ciclo atual                 * @return Número do ciclo atual                 */                int16_t getCurrentCycle() const;                // Interface de comunicação CPU-PPU                void connectCPU(const CPUInterface &interface);                void triggerNMI();                bool isNMIPending() const;                // Registradores de comunicação CPU-PPU ($2000-$2007)                uint8_t readRegister2000();                void writeRegister2000(uint8_t value);                uint8_t readRegister2001();                void writeRegister2001(uint8_t value);                uint8_t readRegister2002();                void writeRegister2002(uint8_t value);                uint8_t readRegister2003();                void writeRegister2003(uint8_t value);                uint8_t readRegister2004();                void writeRegister2004(uint8_t value);                uint8_t readRegister2005();                void writeRegister2005(uint8_t value);                uint8_t readRegister2006();                void writeRegister2006(uint8_t value);                uint8_t readRegister2007();                void writeRegister2007(uint8_t value);                // DMA                void startOAMDMA(const uint8_t *data);                bool isDMAActive() const;                void tickDMA();                // Constantes de timing                static constexpr int32_t CYCLES_PER_SCANLINE = 341;                static constexpr int32_t VISIBLE_SCANLINES = 240;                static constexpr int32_t POST_RENDER_SCANLINE = 240;                static constexpr int32_t VBLANK_START_SCANLINE = 241;                static constexpr int32_t PRE_RENDER_SCANLINE = 261;                static constexpr int32_t CYCLES_PER_CPU = 3; // 3 PPU cycles per CPU cycle                // Estados de renderização                enum class RenderState                {                    Visible,    // Scanlines 0-239                    PostRender, // Scanline 240                    VBlank,     // Scanlines 241-260                    PreRender   // Scanline 261                };                // Métodos de timing                void tickPPU();                void synchronizeCPU();                int32_t getCPUCycles() const;                RenderState getRenderState() const;            private:                // Estrutura C original                nes_ppu_t *m_ppu;                // Flags para gerenciamento de estado                bool m_initialized;                // Conversão de modo de espelhamento                nes_mirror_mode_t convertMirrorMode(MirrorMode mode) const;                // Registradores internos                uint8_t m_status;                uint8_t m_control;                uint8_t m_mask;                uint8_t m_oamAddr;                uint16_t m_vAddr;                uint16_t m_tAddr;                uint8_t m_fineX;                bool m_writeLatch;                // Memória                std::array<uint8_t, VRAM_SIZE> m_vram;                std::array<uint8_t, OAM_SIZE> m_oam;                std::array<uint8_t, 32> m_palette;                // Estado de renderização                int32_t m_scanline;                int32_t m_cycle;                int32_t m_spriteCount;                bool m_evenFrame;                // Novas estruturas de dados para renderização                std::array<uint8_t, 32> m_attributeTable;                std::array<uint32_t, 64> m_paletteRGB; // Paleta de cores RGB                std::vector<uint32_t> m_frameBuffer;   // Buffer de frame interno                // Interface CPU                CPUInterface m_cpuInterface;                bool m_nmiPending;                bool m_dmaActive;                uint16_t m_dmaAddress;                uint8_t m_dmaData;                int32_t m_dmaCycle;                // Estado de timing                RenderState m_renderState;                int32_t m_cpuCycles;                bool m_isOddFrame;                // Sistemas otimizados                TileCacheOptimized m_tileCacheOpt;                PrefetchSystemOptimized m_prefetchOpt;                std::array<uint8_t, 64> m_tileRowBufferOpt;                // Métricas de performance                struct PerformanceMetrics {                    uint32_t cacheHits;                    uint32_t cacheMisses;                    uint32_t prefetchHits;                    uint32_t prefetchMisses;                    uint64_t totalRenderTime;                    uint32_t frameCount;                    void reset() {                        cacheHits = cacheMisses = 0;                        prefetchHits = prefetchMisses = 0;                        totalRenderTime = 0;                        frameCount = 0;                    }                } m_metrics;                // Métodos de otimização                void updateRenderingState();                void prefetchTiles();                void renderScanline();                void optimizedRenderBackground();                void optimizedRenderSprites();                Tile &getCachedTile(uint16_t patternTable, uint8_t tileIndex);                // Buffer management                void clearScanlineBuffer();                void commitScanlineToFrame();                // Sprite evaluation otimizado                struct SpriteEvaluation                {                    std::array<uint8_t, 8> indices;                    uint8_t count;                    bool spriteZeroIncluded;                };                SpriteEvaluation evaluateSpritesForScanline(int32_t scanline);                // Métodos de timing internos                void updateRenderState();                void processScanline();                void processVisibleScanline();                void processPreRenderScanline();                void processVBlankScanline();                void skipCycle(); // Para frames ímpares em modo background                // Funções auxiliares                void updateVBlank();                void evaluateSprites();                void renderBackground();                void renderSprites();                void incrementVRAMAddress();                // Novas funções auxiliares                Tile getTile(uint16_t patternTable, uint8_t tileIndex) const;                uint32_t getColor(uint8_t paletteIndex, uint8_t colorIndex) const;                void renderTile(const Tile &tile, int32_t x, int32_t y, uint8_t palette, bool flipH, bool flipV);                void renderNameTable(uint16_t baseAddr, int32_t scrollX, int32_t scrollY);                // Novos métodos privados                void updateNMIState();                void processRegister2000(uint8_t value);                void processRegister2001(uint8_t value);                uint8_t processRegister2002();                void processRegister2003(uint8_t value);                void processRegister2004(uint8_t value);                void processRegister2005(uint8_t value);                void processRegister2006(uint8_t value);                void processRegister2007(uint8_t value);                // Métodos de prefetch                void initializePrefetch();                void updatePrefetch();                void prefetchTileRow(uint16_t baseAddr, int32_t row);                void processPrefetchQueue();                // Otimizações de memória                void optimizeMemoryAccess();                void updateMemoryMap();                // Métodos de otimização                uint8_t getCachedAttribute(uint16_t addr);                void updateAttributeCache(uint16_t addr, uint8_t data);                void invalidateAttributeCache();            };        } // namespace NES    } // namespace Platforms} // namespace MegaEmu