/** * @file nes_ppu.cpp * @brief Implementação da classe NESPPU para a Picture Processing Unit do NES em C++ * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-13 */#include "nes_ppu.hpp"#include <stdexcept>#include <iostream>#include <cstring>#include <chrono>namespace MegaEmu{    namespace Platforms    {        namespace NES        {            NESPPU::NESPPU()                : m_status(0), m_control(0), m_mask(0), m_oamAddr(0), m_vAddr(0), m_tAddr(0), m_fineX(0), m_writeLatch(false), m_scanline(0), m_cycle(0), m_spriteCount(0), m_evenFrame(true)            {                m_vram.fill(0);                m_oam.fill(0);                m_palette.fill(0);            }            NESPPU::~NESPPU() = default;            uint8_t NESPPU::getStatus() const            {                return m_status;            }            uint8_t NESPPU::getControl() const            {                return m_control;            }            uint8_t NESPPU::getMask() const            {                return m_mask;            }            void NESPPU::writeControl(uint8_t value)            {                m_control = value;            }            void NESPPU::writeMask(uint8_t value)            {                m_mask = value;            }            void NESPPU::writeOAMAddress(uint8_t value)            {                m_oamAddr = value;            }            void NESPPU::writeScroll(uint8_t value)            {                if (!m_writeLatch)                {                    m_fineX = value & 0x07;                    m_tAddr = (m_tAddr & 0xFFE0) | (value >> 3);                }                else                {                    m_tAddr = (m_tAddr & 0x8FFF) | ((value & 0x07) << 12);                    m_tAddr = (m_tAddr & 0xFC1F) | ((value & 0xF8) << 2);                }                m_writeLatch = !m_writeLatch;            }            void NESPPU::writeAddress(uint8_t value)            {                if (!m_writeLatch)                {                    m_tAddr = (m_tAddr & 0x00FF) | ((value & 0x3F) << 8);                }                else                {                    m_tAddr = (m_tAddr & 0xFF00) | value;                    m_vAddr = m_tAddr;                }                m_writeLatch = !m_writeLatch;            }            void NESPPU::writeData(uint8_t value)            {                writeVRAM(m_vAddr, value);                incrementVRAMAddress();            }            uint8_t NESPPU::readVRAM(uint16_t address) const            {                address &= 0x3FFF;                if (address >= 0x3F00 && address < 0x4000)                {                    return m_palette[address & 0x1F];                }                return m_vram[address];            }            void NESPPU::writeVRAM(uint16_t address, uint8_t value)            {                address &= 0x3FFF;                if (address >= 0x3F00 && address < 0x4000)                {                    m_palette[address & 0x1F] = value;                }                else                {                    m_vram[address] = value;                }            }            uint8_t NESPPU::readOAM(uint8_t address) const            {                return m_oam[address];            }            void NESPPU::writeOAM(uint8_t address, uint8_t value)            {                m_oam[address] = value;            }            void NESPPU::tick(int cycles)            {                for (int i = 0; i < cycles; ++i)                {                    if (++m_cycle > 340)                    {                        m_cycle = 0;                        if (++m_scanline > 261)                        {                            m_scanline = 0;                            m_evenFrame = !m_evenFrame;                        }                        updateVBlank();                    }                }            }            void NESPPU::renderFrame(uint32_t *frameBuffer)            {                if (m_mask & 0x18)                { // Se background ou sprites estão habilitados                    renderBackground();                    renderSprites();                }            }            bool NESPPU::isInVBlank() const            {                return (m_status & 0x80) != 0;            }            int NESPPU::getSpriteCount() const            {                return m_spriteCount;            }            void NESPPU::updateVBlank()            {                if (m_scanline == 241)                {                    m_status |= 0x80; // Set VBlank flag                }                else if (m_scanline == 261)                {                    m_status &= ~0x80; // Clear VBlank flag                }            }            void NESPPU::evaluateSprites()            {                m_spriteCount = 0;                for (int i = 0; i < 64; i++)                {                    uint8_t y = m_oam[i * 4];                    if (y <= 0xEF)                    {                        m_spriteCount++;                    }                }            }            void NESPPU::renderBackground()            {                if (!(m_mask & 0x08))                    return; // Background desabilitado                uint16_t patternTable = (m_control & 0x10) ? 0x1000 : 0x0000;                uint16_t nameTableAddr = 0x2000 | (m_vAddr & 0x0FFF);                // Renderiza a nametable atual                renderNameTable(nameTableAddr, m_fineX, m_scanline);            }            void NESPPU::renderNameTable(uint16_t baseAddr, int scrollX, int scrollY)            {                int tileY = scrollY / 8;                int fineY = scrollY % 8;                for (int x = 0; x < 32; ++x)                {                    int screenX = x * 8 - scrollX;                    if (screenX < -8 || screenX >= SCREEN_WIDTH)                        continue;                    uint16_t tileAddr = baseAddr + tileY * 32 + x;                    uint8_t tileIndex = readVRAM(tileAddr);                    // Obtém atributos do tile                    int attrX = x / 4;                    int attrY = tileY / 4;                    uint16_t attrAddr = 0x23C0 | (baseAddr & 0x0C00) | (attrY << 3) | attrX;                    uint8_t attr = readVRAM(attrAddr);                    uint8_t palette = (attr >> ((((tileY & 2) << 1) | (x & 2)) & 0x07)) & 0x03;                    // Renderiza o tile                    Tile tile = getTile(patternTable, tileIndex);                    renderTile(tile, screenX, scrollY - fineY, palette, false, false);                }            }            void NESPPU::renderSprites()            {                if (!(m_mask & 0x10))                    return; // Sprites desabilitados                bool tallSprites = m_control & 0x20;                uint16_t patternTable = tallSprites ? 0x0000 : ((m_control & 0x08) ? 0x1000 : 0x0000);                m_spriteCount = 0;                for (int i = 0; i < 64; ++i)                {                    Sprite sprite;                    sprite.y = m_oam[i * 4 + 0];                    sprite.tile_index = m_oam[i * 4 + 1];                    sprite.attributes = m_oam[i * 4 + 2];                    sprite.x = m_oam[i * 4 + 3];                    if (sprite.y >= 0xEF)                        continue;                    m_spriteCount++;                    bool flipH = sprite.attributes & 0x40;                    bool flipV = sprite.attributes & 0x80;                    uint8_t palette = 4 | (sprite.attributes & 0x03);                    Tile tile = getTile(patternTable, sprite.tile_index);                    renderTile(tile, sprite.x, sprite.y + 1, palette, flipH, flipV);                    if (tallSprites)                    {                        // Renderiza a segunda metade do sprite 8x16                        Tile tile2 = getTile(patternTable, sprite.tile_index + 1);                        renderTile(tile2, sprite.x, sprite.y + 9, palette, flipH, flipV);                    }                }            }            void NESPPU::incrementVRAMAddress()            {                if (m_control & 0x04)                {                    m_vAddr += 32;                }                else                {                    m_vAddr += 1;                }                m_vAddr &= 0x7FFF;            }            Tile NESPPU::getTile(uint16_t patternTable, uint8_t tileIndex) const            {                Tile tile;                uint16_t baseAddr = patternTable + (tileIndex * 16);                for (int i = 0; i < 16; ++i)                {                    tile.data[i] = readVRAM(baseAddr + i);                }                return tile;            }            uint32_t NESPPU::getColor(uint8_t paletteIndex, uint8_t colorIndex) const            {                uint8_t paletteAddr = 0x3F00 + (paletteIndex * 4) + colorIndex;                uint8_t colorValue = readVRAM(paletteAddr);                return m_paletteRGB[colorValue & 0x3F];            }            void NESPPU::renderTile(const Tile &tile, int x, int y, uint8_t palette, bool flipH, bool flipV)            {                for (int tileY = 0; tileY < 8; ++tileY)                {                    int screenY = y + (flipV ? 7 - tileY : tileY);                    if (screenY < 0 || screenY >= SCREEN_HEIGHT)                        continue;                    for (int tileX = 0; tileX < 8; ++tileX)                    {                        int screenX = x + (flipH ? 7 - tileX : tileX);                        if (screenX < 0 || screenX >= SCREEN_WIDTH)                            continue;                        uint8_t pixel = tile.getPixel(tileX, tileY);                        if (pixel != 0)                        { // Pixel não transparente                            uint32_t color = getColor(palette, pixel);                            m_frameBuffer[screenY * SCREEN_WIDTH + screenX] = color;                        }                    }                }            }            void NESPPU::connectCPU(const CPUInterface &interface)            {                m_cpuInterface = interface;                m_nmiPending = false;                m_dmaActive = false;                m_dmaCycle = 0;            }            void NESPPU::triggerNMI()            {                if (m_control & 0x80)                { // NMI habilitado                    m_nmiPending = true;                    if (m_cpuInterface.nmiCallback)                    {                        m_cpuInterface.nmiCallback();                    }                }            }            void NESPPU::clearNMI()            {                m_nmiPending = false;            }            bool NESPPU::isNMIPending() const            {                return m_nmiPending;            }            void NESPPU::startOAMDMA(const uint8_t *data)            {                m_dmaActive = true;                m_dmaAddress = 0;                m_dmaData = data[0];                m_dmaCycle = 0;            }            bool NESPPU::isDMAActive() const            {                return m_dmaActive;            }            void NESPPU::tickDMA()            {                if (!m_dmaActive)                    return;                if (m_dmaCycle % 2 == 0)                {                    // Ciclo de leitura                    m_dmaData = m_cpuInterface.cpuMemory[m_dmaAddress];                }                else                {                    // Ciclo de escrita                    writeOAM(m_oamAddr, m_dmaData);                    m_oamAddr++;                    m_dmaAddress++;                    if (m_dmaAddress & 0xFF == 0)                    {                        m_dmaActive = false;                    }                }                m_dmaCycle++;            }            void NESPPU::updateNMIState()            {                bool oldNMI = m_nmiPending;                m_nmiPending = (m_status & 0x80) && (m_control & 0x80);                if (!oldNMI && m_nmiPending)                {                    triggerNMI();                }            }            void NESPPU::processRegister2000(uint8_t value)            {                bool oldNMIEnabled = m_control & 0x80;                m_control = value;                if (!oldNMIEnabled && (value & 0x80) && (m_status & 0x80))                {                    triggerNMI();                }            }            void NESPPU::processRegister2001(uint8_t value)            {                m_mask = value;            }            uint8_t NESPPU::processRegister2002()            {                uint8_t status = m_status;                m_status &= ~0x80; // Clear VBlank flag                m_writeLatch = false;                return status;            }            void NESPPU::processRegister2003(uint8_t value)            {                m_oamAddr = value;            }            void NESPPU::processRegister2004(uint8_t value)            {                writeOAM(m_oamAddr++, value);            }            void NESPPU::processRegister2005(uint8_t value)            {                writeScroll(value);            }            void NESPPU::processRegister2006(uint8_t value)            {                writeAddress(value);            }            void NESPPU::processRegister2007(uint8_t value)            {                writeData(value);            }            uint8_t NESPPU::readRegister(uint16_t addr)            {                switch (addr & 0x7)                {                case 0:                    return m_control;                case 1:                    return m_mask;                case 2:                    return processRegister2002();                case 3:                    return m_oamAddr;                case 4:                    return readOAM(m_oamAddr);                case 7:                {                    uint8_t value = m_vram[m_vAddr & 0x3FFF];                    incrementVRAMAddress();                    return value;                }                default:                    return 0;                }            }            void NESPPU::writeRegister(uint16_t addr, uint8_t value)            {                switch (addr & 0x7)                {                case 0:                    processRegister2000(value);                    break;                case 1:                    processRegister2001(value);                    break;                case 3:                    processRegister2003(value);                    break;                case 4:                    processRegister2004(value);                    break;                case 5:                    processRegister2005(value);                    break;                case 6:                    processRegister2006(value);                    break;                case 7:                    processRegister2007(value);                    break;                }            }            void NESPPU::tickPPU()            {                // Processar ciclo atual                if (m_renderState == RenderState::Visible)                {                    processVisibleScanline();                }                else if (m_renderState == RenderState::PreRender)                {                    processPreRenderScanline();                }                else if (m_renderState == RenderState::VBlank)                {                    processVBlankScanline();                }                // Atualizar ciclos                m_cycle++;                if (m_cycle >= CYCLES_PER_SCANLINE)                {                    m_cycle = 0;                    m_scanline++;                    if (m_scanline > PRE_RENDER_SCANLINE)                    {                        m_scanline = 0;                        m_evenFrame = !m_evenFrame;                        // Skip cycle on odd frames if rendering is enabled                        if (m_evenFrame && (m_mask & 0x08))                        {                            skipCycle();                        }                    }                    updateRenderState();                }                // Atualizar ciclos CPU                m_cpuCycles = m_cycle / CYCLES_PER_CPU;            }            void NESPPU::synchronizeCPU()            {                // Sincronizar com a CPU                if (m_dmaActive)                {                    tickDMA();                }                // Processar interrupções                updateNMIState();            }            int NESPPU::getCPUCycles() const            {                return m_cpuCycles;            }            NESPPU::RenderState NESPPU::getRenderState() const            {                return m_renderState;            }            void NESPPU::updateRenderState()            {                if (m_scanline < VISIBLE_SCANLINES)                {                    m_renderState = RenderState::Visible;                }                else if (m_scanline == POST_RENDER_SCANLINE)                {                    m_renderState = RenderState::PostRender;                }                else if (m_scanline >= VBLANK_START_SCANLINE && m_scanline < PRE_RENDER_SCANLINE)                {                    m_renderState = RenderState::VBlank;                }                else                {                    m_renderState = RenderState::PreRender;                }            }            void NESPPU::processVisibleScanline()            {                if (!(m_mask & 0x18))                    return;                switch (m_cycle)                {                case 0:                    // Idle cycle                    break;                case 1:                    clearScanlineBuffer();                    optimizeMemoryAccess();                    break;                case 2 ... 257:                    renderScanline();                    break;                case 258 ... 320:                    // Sprite fetches for next scanline                    if (m_cycle == 257)                    {                        m_vAddr = (m_vAddr & ~0x041F) | (m_tAddr & 0x041F);                    }                    break;                case 321 ... 336:                    updatePrefetch();                    break;                case 337 ... 340:                    processPrefetchQueue();                    break;                }            }            void NESPPU::processPreRenderScanline()            {                if (!(m_mask & 0x18))                    return;                switch (m_cycle)                {                case 0:                    // Idle cycle                    break;                case 1:                    // Clear VBlank and sprite overflow flags                    m_status &= ~0xE0;                    break;                case 257:                    // Copy horizontal bits                    m_vAddr = (m_vAddr & ~0x041F) | (m_tAddr & 0x041F);                    break;                case 280 ... 304:                    // Copy vertical bits                    if (m_mask & 0x18)                    {                        m_vAddr = (m_vAddr & ~0x7BE0) | (m_tAddr & 0x7BE0);                    }                    break;                }            }            void NESPPU::processVBlankScanline()            {                if (m_scanline == VBLANK_START_SCANLINE && m_cycle == 1)                {                    m_status |= 0x80; // Set VBlank flag                    if (m_control & 0x80)                    {                        triggerNMI();                    }                }            }            void NESPPU::skipCycle()            {                if (m_cycle == 0)                {                    m_cycle = 1;                }            }            void NESPPU::updateRenderingState()            {                m_backgroundEnabled = m_mask & 0x08;                m_spritesEnabled = m_mask & 0x10;                // Invalidar cache se necessário                if (!m_backgroundEnabled && !m_spritesEnabled)                {                    m_tileCache.invalidate();                }            }            Tile &NESPPU::getCachedTile(uint16_t patternTable, uint8_t tileIndex) const            {                size_t cacheIndex = tileIndex % TileCache::CACHE_SIZE;                const auto &entry = m_tileCache.entries[cacheIndex];                if (!entry.valid || entry.patternTable != patternTable || entry.tileIndex != tileIndex)                {                    Tile tile;                    uint16_t baseAddr = patternTable + (tileIndex * 16);                    for (int i = 0; i < 16; ++i)                    {                        tile.data[i] = readVRAM(baseAddr + i);                    }                    return tile;                }                return entry.tile;            }            void NESPPU::clearScanlineBuffer()            {                std::fill(m_scanlineBuffer.begin(), m_scanlineBuffer.end(), 0);            }            void NESPPU::commitScanlineToFrame()            {                if (m_scanline >= 0 && m_scanline < SCREEN_HEIGHT)                {                    std::copy(m_scanlineBuffer.begin(), m_scanlineBuffer.end(),                              m_frameBuffer.begin() + m_scanline * SCREEN_WIDTH);                }            }            NESPPU::SpriteEvaluation NESPPU::evaluateSpritesForScanline(int scanline)            {                SpriteEvaluation eval = {0};                for (int i = 0; i < 64 && eval.count < 8; ++i)                {                    uint8_t spriteY = m_oam[i * 4];                    if (spriteY <= 0xEF)                    {                        int spriteHeight = (m_control & 0x20) ? 16 : 8;                        if (scanline >= spriteY && scanline < spriteY + spriteHeight)                        {                            eval.indices[eval.count++] = i;                            if (i == 0)                                eval.spriteZeroIncluded = true;                        }                    }                }                return eval;            }            void NESPPU::optimizedRenderBackground()            {                if (!m_backgroundEnabled)                    return;                auto startTime = std::chrono::high_resolution_clock::now();                clearScanlineBuffer();                uint16_t patternTable = (m_control & 0x10) ? 0x1000 : 0x0000;                uint16_t nameTableAddr = 0x2000 | (m_vAddr & 0x0FFF);                int tileY = m_scanline / 8;                int fineY = m_scanline % 8;                // Processar tiles da linha atual                for (int x = 0; x < 32; ++x)                {                    int screenX = x * 8 - m_fineX;                    if (screenX >= -8 && screenX < SCREEN_WIDTH)                    {                        uint8_t tileIndex = m_tileRowBufferOpt[x];                        // Buscar tile do cache otimizado                        size_t cacheIndex = m_tileCacheOpt.getOptimalIndex(patternTable, tileIndex);                        auto &cacheEntry = m_tileCacheOpt.entries[cacheIndex];                        if (!cacheEntry.valid ||                            cacheEntry.patternTable != patternTable ||                            cacheEntry.tileIndex != tileIndex)                        {                            // Cache miss - carregar tile                            uint16_t baseAddr = patternTable + (tileIndex * 16);                            for (int i = 0; i < 16; ++i)                            {                                cacheEntry.tile.data[i] = readVRAM(baseAddr + i);                            }                            cacheEntry.patternTable = patternTable;                            cacheEntry.tileIndex = tileIndex;                            cacheEntry.valid = true;                            m_metrics.cacheMisses++;                        }                        else                        {                            m_metrics.cacheHits++;                        }                        cacheEntry.lastAccess = m_tileCacheOpt.accessCounter++;                        // Renderizar linha do tile                        for (int px = 0; px < 8; ++px)                        {                            int bufferX = screenX + px;                            if (bufferX >= 0 && bufferX < SCREEN_WIDTH)                            {                                uint8_t pixel = cacheEntry.tile.getPixel(px, fineY);                                if (pixel != 0)                                {                                    m_scanlineBuffer[bufferX] = getColor(0, pixel);                                }                            }                        }                    }                }                // Preparar próxima linha                updatePrefetch();                auto endTime = std::chrono::high_resolution_clock::now();                m_metrics.totalRenderTime += std::chrono::duration_cast<std::chrono::microseconds>(                                                 endTime - startTime)                                                 .count();            }            void NESPPU::initializePrefetch()            {                m_prefetchOpt.initialize();                m_tileRowBufferOpt.fill(0);                m_metrics.reset();            }            void NESPPU::updatePrefetch()            {                if (!m_prefetchOpt.enabled)                    return;                int nextRow = (m_scanline + 1) % SCREEN_HEIGHT;                if (nextRow < VISIBLE_SCANLINES)                {                    uint16_t baseAddr = 0x2000 | (m_vAddr & 0x0C00);                    prefetchTileRow(baseAddr, nextRow / 8);                }            }            void NESPPU::prefetchTileRow(uint16_t baseAddr, int row)            {                uint16_t nameTableAddr = baseAddr + row * 32;                // Prefetch com prioridades                for (int i = 0; i < 32; ++i)                {                    uint16_t addr = nameTableAddr + i;                    uint8_t tileIndex = readVRAM(addr);                    // Prioridade baseada na posição horizontal                    uint8_t priority = (i < 16) ? 2 : 1; // Prioridade maior para tiles visíveis                    m_prefetchOpt.push(addr, tileIndex, priority);                }                // Processar fila de prefetch                uint16_t addr;                uint8_t data;                int processed = 0;                while (m_prefetchOpt.pop(addr, data) && processed < 32)                {                    int x = addr & 0x1F;                    m_tileRowBufferOpt[x] = data;                    processed++;                    m_metrics.prefetchHits++;                }            }            void NESPPU::optimizedRenderSprites()            {                if (!m_spritesEnabled)                    return;                auto eval = evaluateSpritesForScanline(m_scanline);                bool tallSprites = m_control & 0x20;                for (int i = eval.count - 1; i >= 0; --i)                {                    int spriteIndex = eval.indices[i];                    Sprite sprite;                    sprite.y = m_oam[spriteIndex * 4 + 0];                    sprite.tile_index = m_oam[spriteIndex * 4 + 1];                    sprite.attributes = m_oam[spriteIndex * 4 + 2];                    sprite.x = m_oam[spriteIndex * 4 + 3];                    bool flipH = sprite.attributes & 0x40;                    bool flipV = sprite.attributes & 0x80;                    uint8_t palette = 4 | (sprite.attributes & 0x03);                    int spriteY = m_scanline - (sprite.y + 1);                    if (flipV)                        spriteY = (tallSprites ? 15 : 7) - spriteY;                    uint16_t patternTable = tallSprites ? 0x0000 : ((m_control & 0x08) ? 0x1000 : 0x0000);                    uint8_t tileIndex = sprite.tile_index;                    if (tallSprites && spriteY >= 8)                    {                        tileIndex++;                        spriteY -= 8;                    }                    Tile &tile = getCachedTile(patternTable, tileIndex);                    for (int x = 0; x < 8; ++x)                    {                        int screenX = sprite.x + (flipH ? 7 - x : x);                        if (screenX >= 0 && screenX < SCREEN_WIDTH)                        {                            uint8_t pixel = tile.getPixel(x, spriteY);                            if (pixel != 0)                            {                                if (spriteIndex == 0 && eval.spriteZeroIncluded &&                                    m_scanlineBuffer[screenX] != 0)                                {                                    m_status |= 0x40; // Sprite 0 hit                                }                                if (!(sprite.attributes & 0x20) || m_scanlineBuffer[screenX] == 0)                                {                                    m_scanlineBuffer[screenX] = getColor(palette, pixel);                                }                            }                        }                    }                }            }            void NESPPU::renderScanline()            {                if (m_scanline < 0 || m_scanline >= SCREEN_HEIGHT)                    return;                clearScanlineBuffer();                if (m_backgroundEnabled)                {                    optimizedRenderBackground();                }                if (m_spritesEnabled)                {                    optimizedRenderSprites();                }                commitScanlineToFrame();            }            void NESPPU::prefetchTiles()            {                // Implementation of prefetchTiles method            }            void NESPPU::initializePrefetch()            {                m_prefetchEnabled = true;                m_prefetchQueue.clear();                m_tileRowBuffer.fill(0);                invalidateAttributeCache();            }            void NESPPU::updatePrefetch()            {                if (!m_prefetchEnabled)                    return;                // Prefetch próxima linha de tiles                int nextRow = (m_scanline + 1) % SCREEN_HEIGHT;                if (nextRow < VISIBLE_SCANLINES)                {                    uint16_t baseAddr = 0x2000 | (m_vAddr & 0x0C00);                    prefetchTileRow(baseAddr, nextRow / 8);                }            }            void NESPPU::prefetchTileRow(uint16_t baseAddr, int row)            {                uint16_t nameTableAddr = baseAddr + row * 32;                uint16_t attrTableAddr = baseAddr + 0x3C0 + (row / 4) * 8;                // Prefetch nametable entries                for (int i = 0; i < 32; ++i)                {                    uint16_t addr = nameTableAddr + i;                    uint8_t tileIndex = readVRAM(addr);                    m_prefetchQueue.push(addr, tileIndex);                }                // Prefetch attribute table entries                for (int i = 0; i < 8; ++i)                {                    uint16_t addr = attrTableAddr + i;                    uint8_t attrByte = readVRAM(addr);                    updateAttributeCache(addr, attrByte);                }            }            void NESPPU::processPrefetchQueue()            {                uint16_t addr;                uint8_t data;                while (m_prefetchQueue.pop(addr, data))                {                    int x = addr & 0x1F;                    m_tileRowBuffer[x] = data;                }            }            void NESPPU::optimizeMemoryAccess()            {                // Otimizar padrões de acesso à memória                if (m_backgroundEnabled)                {                    processPrefetchQueue();                }                // Atualizar mapeamento de memória se necessário                updateMemoryMap();            }            void NESPPU::updateMemoryMap()            {                // Implementar lógica de mapeamento de memória otimizado                // baseado no estado atual do PPU            }            uint8_t NESPPU::getCachedAttribute(uint16_t addr)            {                addr &= 0x3FF; // Normalizar endereço                for (auto &cache : m_attrCache)                {                    if (cache.valid && cache.addr == addr)                    {                        return cache.data;                    }                }                return readVRAM(0x23C0 | addr);            }            void NESPPU::updateAttributeCache(uint16_t addr, uint8_t data)            {                addr &= 0x3FF;                for (auto &cache : m_attrCache)                {                    if (!cache.valid || cache.addr == addr)                    {                        cache.addr = addr;                        cache.data = data;                        cache.valid = true;                        return;                    }                }                // Se não encontrou entrada livre, substitui a primeira                m_attrCache[0] = {data, addr, true};            }            void NESPPU::invalidateAttributeCache()            {                for (auto &cache : m_attrCache)                {                    cache.valid = false;                }            }        } // namespace NES    } // namespace Platforms} // namespace MegaEmu