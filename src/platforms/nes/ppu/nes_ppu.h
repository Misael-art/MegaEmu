/** * @file nes_ppu.h * @brief Definições para a Picture Processing Unit (PPU) do NES */ #ifndef NES_PPU_H #define NES_PPU_H #include<stdint.h> #include<stdbool.h> #include "../../../core/core_types.h" #include "../../../utils/error_handling.h" #include "../../../utils/enhanced_log.h" #ifdef __cplusplusextern "C" {#endif /* Registradores do PPU */ #define NES_PPU_REG_CTRL 0x2000 #define NES_PPU_REG_MASK 0x2001 #define NES_PPU_REG_STATUS 0x2002 #define NES_PPU_REG_OAM_ADDR 0x2003 #define NES_PPU_REG_OAM_DATA 0x2004 #define NES_PPU_REG_SCROLL 0x2005 #define NES_PPU_REG_ADDR 0x2006 #define NES_PPU_REG_DATA 0x2007 /* Flags do registrador PPUCTRL */ #define NES_PPUCTRL_NAMETABLE_X 0x01 #define NES_PPUCTRL_NAMETABLE_Y 0x02 #define NES_PPUCTRL_INCREMENT 0x04 #define NES_PPUCTRL_SPRITE_TABLE 0x08 #define NES_PPUCTRL_BACKGROUND_TABLE 0x10 #define NES_PPUCTRL_SPRITE_SIZE 0x20 #define NES_PPUCTRL_MASTER_SLAVE 0x40 #define NES_PPUCTRL_NMI_ENABLE 0x80 /* Flags adicionais do registrador PPUCTRL */ #define NES_PPUCTRL_NAMETABLE_SELECT 0x03 /* Flags do registrador PPUMASK */ #define NES_PPUMASK_GRAYSCALE 0x01 #define NES_PPUMASK_SHOW_LEFT_BG 0x02 #define NES_PPUMASK_SHOW_LEFT_SPR 0x04 #define NES_PPUMASK_SHOW_BACKGROUND 0x08 #define NES_PPUMASK_SHOW_SPRITES 0x10 #define NES_PPUMASK_EMPHASIZE_RED 0x20 #define NES_PPUMASK_EMPHASIZE_GREEN 0x40 #define NES_PPUMASK_EMPHASIZE_BLUE 0x80 /* Flags do registrador PPUSTATUS */ #define NES_PPUSTATUS_SPRITE_OVERFLOW 0x20 #define NES_PPUSTATUS_SPRITE_ZERO_HIT 0x40 #define NES_PPUSTATUS_VBLANK 0x80 /* Dimensões da tela */ #define NES_SCREEN_WIDTH 256 #define NES_SCREEN_HEIGHT 240 /* Tamanhos de memória */ #define NES_PPU_VRAM_SIZE 2048 #define NES_PPU_OAM_SIZE 256 #define NES_PPU_PALETTE_SIZE 32 /* Tipos de sistema (padrão de TV) */ typedef enum {NES_TV_NTSC, NES_TV_PAL, NES_TV_DENDY} nes_tv_system_t; /* Configurações de overscan */ typedef struct {bool enabled; uint8_t top; uint8_t bottom; uint8_t left; uint8_t right;} nes_overscan_t; /* Modos de espelhamento */ typedef enum {NES_MIRROR_HORIZONTAL, NES_MIRROR_VERTICAL, NES_MIRROR_SINGLE_SCREEN_A, NES_MIRROR_SINGLE_SCREEN_B, NES_MIRROR_FOUR_SCREEN} nes_mirror_mode_t; /* Estrutura para scrolling split */ typedef struct {bool enabled; int16_t scanline; uint16_t reg_vram_addr; uint8_t fine_x; uint8_t direction;} nes_split_scroll_t; /* Estrutura do PPU */ typedef struct {/* Registradores */ uint8_t reg_ctrl; /* Registrador de controle */ uint8_t reg_mask; /* Registrador de máscara */ uint8_t reg_status; /* Registrador de status */ uint8_t reg_oam_addr; /* Registrador de endereço OAM */ uint8_t reg_scroll_x; /* Registrador de scroll X */ uint8_t reg_scroll_y; /* Registrador de scroll Y */ uint16_t reg_vram_addr; /* Registrador de endereço VRAM */ uint16_t reg_vram_temp; /* Registrador temporário de endereço VRAM */ uint8_t fine_x; /* Scroll X fino (3 bits) */ bool write_toggle; /* Toggle de escrita */ uint8_t read_buffer; /* Buffer de leitura */ /* Estado do frame */ int16_t scanline; /* Linha atual */ int16_t cycle; /* Ciclo atual */ uint32_t frame_count; /* Contador de frames */ bool odd_frame; /* Frame ímpar */ /* Estado de NMI */ bool nmi_output; /* NMI habilitado */ bool nmi_previous; /* Estado anterior do NMI */ bool nmi_occurred; /* NMI ocorreu */ uint8_t nmi_delay; /* Atraso do NMI */ /* Memória */ uint8_t * vram; /* Memória de vídeo */ uint8_t * oam; /* Object Attribute Memory */ uint8_t * palette; /* Paleta de cores */ uint32_t * frame_buffer; /* Buffer de frame */ /* Sprites */ uint8_t sprite_count; /* Número de sprites na linha */ uint8_t sprite_data[8][4]; /* Dados dos sprites: [0]=y, [1]=tile, [2]=attr, [3]=x */ uint8_t oam_addr; /* Endereço atual no OAM */ bool sprite_zero_hit_possible; /* Indica se o sprite zero pode causar hit */ bool sprite_zero_being_rendered; /* Indica se o sprite zero está sendo renderizado */ /* Modo de espelhamento */ nes_mirror_mode_t mirror_mode; /* Ponteiros externos */ void * cpu; /* Ponteiro para a CPU */ void * cartridge; /* Ponteiro para o cartucho */ /* Recursos adicionais */ nes_tv_system_t tv_system; nes_overscan_t overscan; nes_split_scroll_t split_scroll; uint32_t * palettes_data; uint8_t current_palette_set; /* Suporte a distorção e efeitos de CRT */ bool enable_distortion; float distortion_amount; uint8_t * distortion_table;} nes_ppu_t; /* Protótipos de funções */ void apply_color_mask(nes_ppu_t * ppu); /* Funções de interface */ nes_ppu_t * nes_ppu_init(void *cpu, void *cartridge); void nes_ppu_shutdown(nes_ppu_t * ppu); void nes_ppu_reset(nes_ppu_t * ppu); /* Funções de acesso aos registradores */ uint8_t nes_ppu_read_register(nes_ppu_t * ppu, uint16_t addr); void nes_ppu_write_register(nes_ppu_t * ppu, uint16_t addr, uint8_t value); /* Funções de execução */ void nes_ppu_execute(nes_ppu_t * ppu); void nes_ppu_step(nes_ppu_t * ppu); void nes_ppu_start_frame(nes_ppu_t * ppu); void nes_ppu_update(nes_ppu_t * ppu, uint32_t cycles); void nes_ppu_render_frame(nes_ppu_t * ppu, uint32_t *frame_buffer); /* Funções de acesso à memória */ uint8_t nes_ppu_read(nes_ppu_t * ppu, uint16_t addr); void nes_ppu_write(nes_ppu_t * ppu, uint16_t addr, uint8_t value); /* Funções de acesso ao OAM */ uint8_t nes_ppu_read_oam(nes_ppu_t * ppu, uint16_t addr); void nes_ppu_write_oam(nes_ppu_t * ppu, uint16_t addr, uint8_t value); void nes_ppu_write_oam_dma(nes_ppu_t * ppu, uint8_t *data); /* Funções de saída */ uint32_t * nes_ppu_get_frame_buffer(nes_ppu_t * ppu); bool nes_ppu_frame_complete(nes_ppu_t * ppu); /* Funções de controle */ void nes_ppu_set_mirror_mode(nes_ppu_t * ppu, nes_mirror_mode_t mode); bool nes_ppu_nmi_triggered(nes_ppu_t * ppu); void nes_ppu_clear_nmi(nes_ppu_t * ppu); /* Funções para suporte a TV systems, overscan e scrolling split */ void nes_ppu_set_tv_system(nes_ppu_t * ppu, nes_tv_system_t system); void nes_ppu_set_overscan(nes_ppu_t * ppu, nes_overscan_t overscan); void nes_ppu_configure_split_scroll(nes_ppu_t * ppu, nes_split_scroll_t config); void nes_ppu_load_palette_set(nes_ppu_t * ppu, uint8_t palette_set); void nes_ppu_set_distortion(nes_ppu_t * ppu, bool enable, float amount); /**     * @brief Lê um uint8_t da paleta de cores     *     * @param ppu Ponteiro para o estado da PPU     * @param address Endereço da paleta (0-31)     * @return uint8_t Valor da cor na paleta     */ uint8_t nes_ppu_read_palette_public(nes_ppu_t * ppu, uint8_t address); /* Funções públicas */ void apply_color_mask(nes_ppu_t * ppu); void nes_ppu_oam_dma(nes_ppu_t * ppu, const uint8_t *data); #ifdef __cplusplus} #endif #endif /* NES_PPU_H */
