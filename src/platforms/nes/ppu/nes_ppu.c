/** * @file nes_ppu.c * @brief Implementação da Picture Processing Unit (PPU) do NES */ #include "platforms/nes/ppu/nes_ppu.h" #include "platforms/nes/cpu/nes_cpu.h" #include "platforms/nes/cartridge/nes_cartridge.h" #include "utils/error_handling.h" #include "utils/enhanced_log.h" #include "utils/log_categories.h" #include<stdlib.h> #include<string.h> #include<stdio.h> #include "../cpu/rp2a03.h" #include "../nes.h" // Macros de log específicas para a PPU#define PPU_LOG_INFO(msg, ...) EMU_LOG_INFO(EMU_LOG_CAT_VIDEO, msg, ##__VA_ARGS__)#define PPU_LOG_ERROR(msg, ...) EMU_LOG_ERROR(EMU_LOG_CAT_VIDEO, msg, ##__VA_ARGS__)#define PPU_LOG_TRACE(msg, ...) EMU_LOG_TRACE(EMU_LOG_CAT_VIDEO, msg, ##__VA_ARGS__)#define PPU_LOG_WARN(msg, ...) EMU_LOG_WARN(EMU_LOG_CAT_VIDEO, msg, ##__VA_ARGS__)#define PPU_LOG_DEBUG(msg, ...) EMU_LOG_DEBUG(EMU_LOG_CAT_VIDEO, msg, ##__VA_ARGS__)// Paleta de cores do NES em formato ARGB (0xAARRGGBB) para compatibilidade com SDL// Baseado na paleta padrão do FCEUX, com formato convertido de RGBA para ARGBstatic const uint32_t NES_PALETTE[64] = {    0xFF7C7C7C, 0xFF0000FC, 0xFF0000BC, 0xFF4428BC, 0xFF940084, 0xFFA80020, 0xFFA81000, 0xFF881400,    0xFF503000, 0xFF007800, 0xFF006800, 0xFF005800, 0xFF004058, 0xFF000000, 0xFF000000, 0xFF000000,    0xFFBCBCBC, 0xFF0078F8, 0xFF0058F8, 0xFF6844FC, 0xFFD800CC, 0xFFE40058, 0xFFF83800, 0xFFE45C10,    0xFFAC7C00, 0xFF00B800, 0xFF00A800, 0xFF00A844, 0xFF008888, 0xFF000000, 0xFF000000, 0xFF000000,    0xFFF8F8F8, 0xFF3CBCFC, 0xFF6888FC, 0xFF9878F8, 0xFFF878F8, 0xFFF85898, 0xFFF87858, 0xFFFC9838,    0xFFF8B800, 0xFFB8F818, 0xFF58D854, 0xFF58F898, 0xFF00E8D8, 0xFF787878, 0xFF000000, 0xFF000000,    0xFFFCFCFC, 0xFFA4E4FC, 0xFFB8B8F8, 0xFFD8B8F8, 0xFFF8B8F8, 0xFFF8A4C0, 0xFFF0D0B0, 0xFFFCE0A8,    0xFFF8D878, 0xFFD8F878, 0xFFB8F8B8, 0xFFB8F8D8, 0xFF00FCFC, 0xFFF8F8F8, 0xFF000000, 0xFF000000};// Protótipos de funções estáticasstatic uint16_t nes_ppu_mirror_address(nes_ppu_t *ppu, uint16_t address);static void render_background(nes_ppu_t *ppu, uint32_t *frame_buffer);static void render_sprites(nes_ppu_t *ppu, uint32_t *frame_buffer);static void nes_ppu_increment_scroll_x(nes_ppu_t *ppu);static void nes_ppu_increment_scroll_y(nes_ppu_t *ppu);static void nes_ppu_copy_horizontal_bits(nes_ppu_t *ppu);static void nes_ppu_copy_vertical_bits(nes_ppu_t *ppu);static uint8_t nes_ppu_read_vram(nes_ppu_t *ppu, uint16_t address);static void nes_ppu_write_vram(nes_ppu_t *ppu, uint16_t address, uint8_t value);static uint8_t nes_ppu_read_palette(nes_ppu_t *ppu, uint8_t address);static void nes_ppu_write_palette(nes_ppu_t *ppu, uint8_t address, uint8_t value);static void nes_ppu_cycle_internal(nes_ppu_t *ppu);/** * @brief Mapeia um endereço de memória considerando o modo de espelhamento * * @param ppu Ponteiro para a PPU * @param address Endereço a mapear * @return uint16_t Endereço mapeado */static uint16_t nes_ppu_mirror_address(nes_ppu_t *ppu, uint16_t address){    if (!ppu)    {        PPU_LOG_ERROR("PPU é nulo");        return 0;    }    // Normaliza o endereço para o intervalo de nametables (0x2000-0x3EFF)    if (address < 0x2000 || address > 0x3EFF)    {        PPU_LOG_ERROR("Endereço fora do intervalo de nametables: 0x%04X", address);        return 0;    }    uint16_t mirrored_addr = address; // Inicializa com o endereço original    switch (ppu->mirror_mode)    {    case NES_MIRROR_HORIZONTAL:        // Espelhamento horizontal: A e C são espelhados, B e D são espelhados        if ((address >= 0x2400 && address < 0x2800) || address >= 0x2C00)        {            mirrored_addr = 0x2000 + (address & 0x3FF);        }        break;    case NES_MIRROR_VERTICAL:        // Espelhamento vertical: A e B são espelhados, C e D são espelhados        if (address >= 0x2800)        {            mirrored_addr = 0x2000 + (address & 0x7FF);        }        break;    case NES_MIRROR_SINGLE_SCREEN_A:        // Espelhamento de tela única A: todos os endereços são mapeados para a primeira nametable        mirrored_addr = 0x2000 + (address & 0x3FF);        break;    case NES_MIRROR_SINGLE_SCREEN_B:        // Espelhamento de tela única B: todos os endereços são mapeados para a segunda nametable        mirrored_addr = 0x2400 + (address & 0x3FF);        break;    case NES_MIRROR_FOUR_SCREEN:        // Sem espelhamento, cada nametable é independente        mirrored_addr = address;        break;    default:        PPU_LOG_ERROR("Modo de espelhamento inválido: %d", ppu->mirror_mode);        mirrored_addr = address;        break;    }    PPU_LOG_DEBUG("nes_ppu_mirror_address: 0x%04X -> 0x%04X", address, mirrored_addr);    return mirrored_addr;}/** * @brief Inicializa a PPU do NES * * @param cpu Ponteiro para a CPU * @param cartridge Ponteiro para o cartucho * @return nes_ppu_t* Ponteiro para a estrutura inicializada ou NULL em caso de erro */nes_ppu_t *nes_ppu_init(void *cpu, void *cartridge){    if (!cpu || !cartridge)    {        PPU_LOG_ERROR("nes_ppu_init: parâmetros inválidos - cpu=%p, cartridge=%p", cpu, cartridge);        return NULL;    }    PPU_LOG_INFO("Iniciando inicialização da PPU");    nes_ppu_t *ppu = (nes_ppu_t *)malloc(sizeof(nes_ppu_t));    if (!ppu)    {        PPU_LOG_ERROR("Falha ao alocar memória para a PPU");        return NULL;    }    // Inicializa a estrutura com zeros    memset(ppu, 0, sizeof(nes_ppu_t));    // Atribui os ponteiros externos    ppu->cpu = cpu;    ppu->cartridge = cartridge;    PPU_LOG_DEBUG("Ponteiros externos configurados: cpu=%p, cartridge=%p", cpu, cartridge);    // Aloca memória para a VRAM    ppu->vram = (uint8_t *)malloc(NES_PPU_VRAM_SIZE);    if (!ppu->vram)    {        PPU_LOG_ERROR("Falha ao alocar memória para a VRAM");        nes_ppu_shutdown(ppu);        return NULL;    }    memset(ppu->vram, 0, NES_PPU_VRAM_SIZE);    PPU_LOG_DEBUG("VRAM alocada: %d bytes em %p", NES_PPU_VRAM_SIZE, ppu->vram);    // Aloca memória para o OAM    ppu->oam = (uint8_t *)malloc(NES_PPU_OAM_SIZE);    if (!ppu->oam)    {        PPU_LOG_ERROR("Falha ao alocar memória para o OAM");        nes_ppu_shutdown(ppu);        return NULL;    }    memset(ppu->oam, 0, NES_PPU_OAM_SIZE);    PPU_LOG_DEBUG("OAM alocada: %d bytes em %p", NES_PPU_OAM_SIZE, ppu->oam);    // Aloca memória para a paleta    ppu->palette = (uint8_t *)malloc(NES_PPU_PALETTE_SIZE);    if (!ppu->palette)    {        PPU_LOG_ERROR("Falha ao alocar memória para a paleta");        nes_ppu_shutdown(ppu);        return NULL;    }    memset(ppu->palette, 0, NES_PPU_PALETTE_SIZE);    PPU_LOG_DEBUG("Paleta alocada: %d bytes em %p", NES_PPU_PALETTE_SIZE, ppu->palette);    // Inicializa paleta padrão para testes    // Valores padrão para o Super Mario Bros    ppu->palette[0] = 0x0F; // Background color (black)    // Paleta de background 0    ppu->palette[1] = 0x30; // Light blue    ppu->palette[2] = 0x16; // Red    ppu->palette[3] = 0x0F; // Black    // Paleta de background 1    ppu->palette[4] = 0x0F; // Espelho da cor de fundo    ppu->palette[5] = 0x27; // Brown    ppu->palette[6] = 0x16; // Red    ppu->palette[7] = 0x0F; // Black    // Paleta de background 2    ppu->palette[8] = 0x0F;  // Espelho da cor de fundo    ppu->palette[9] = 0x16;  // Red    ppu->palette[10] = 0x27; // Brown    ppu->palette[11] = 0x0F; // Black    // Paleta de background 3    ppu->palette[12] = 0x0F; // Espelho da cor de fundo    ppu->palette[13] = 0x27; // Brown    ppu->palette[14] = 0x16; // Red    ppu->palette[15] = 0x0F; // Black    // Paletas de sprite    ppu->palette[16] = 0x0F; // Espelho da cor de fundo    // Paleta de sprite 0 (Mario)    ppu->palette[17] = 0x16; // Red (Mario's hat)    ppu->palette[18] = 0x27; // Brown (Mario's hair)    ppu->palette[19] = 0x18; // Skin tone    // Paleta de sprite 1    ppu->palette[20] = 0x0F; // Espelho da cor de fundo    ppu->palette[21] = 0x1A; // Green    ppu->palette[22] = 0x30; // Light green    ppu->palette[23] = 0x27; // Brown    // Paleta de sprite 2    ppu->palette[24] = 0x0F; // Espelho da cor de fundo    ppu->palette[25] = 0x16; // Red    ppu->palette[26] = 0x37; // Orange    ppu->palette[27] = 0x27; // Brown    // Paleta de sprite 3    ppu->palette[28] = 0x0F; // Espelho da cor de fundo    ppu->palette[29] = 0x0F; // Black    ppu->palette[30] = 0x2A; // Purple    ppu->palette[31] = 0x16; // Red    PPU_LOG_DEBUG("Paletas inicializadas com valores padrão do Super Mario Bros");    // Aloca memória para o frame buffer    ppu->frame_buffer = (uint32_t *)malloc(NES_SCREEN_WIDTH * NES_SCREEN_HEIGHT * sizeof(uint32_t));    if (!ppu->frame_buffer)    {        PPU_LOG_ERROR("Falha ao alocar memória para o frame buffer");        nes_ppu_shutdown(ppu);        return NULL;    }    // Inicializa paletas com valores padrão    // A cor 0 (transparente/fundo) é a mesma para todas as paletas    ppu->palette[0] = 0x0F; // Preto por padrão    ppu->palette[4] = 0x0F; // Espelhado para todas as paletas    ppu->palette[8] = 0x0F;    ppu->palette[12] = 0x0F;    ppu->palette[16] = 0x0F;    ppu->palette[20] = 0x0F;    ppu->palette[24] = 0x0F;    ppu->palette[28] = 0x0F;    // Inicializa cada paleta com cores distintas para facilitar debugging    // Paleta 0 - Background    ppu->palette[1] = 0x01; // Azul escuro    ppu->palette[2] = 0x11; // Azul médio    ppu->palette[3] = 0x30; // Branco    // Paleta 1 - Background    ppu->palette[5] = 0x06; // Vermelho    ppu->palette[6] = 0x16; // Laranja    ppu->palette[7] = 0x30; // Branco    // Paleta 2 - Background    ppu->palette[9] = 0x09;  // Verde    ppu->palette[10] = 0x19; // Verde claro    ppu->palette[11] = 0x30; // Branco    // Paleta 3 - Background    ppu->palette[13] = 0x0C; // Marrom    ppu->palette[14] = 0x1C; // Amarelo    ppu->palette[15] = 0x30; // Branco    // Paletas para sprites (4-7)    ppu->palette[17] = 0x14; // Roxo    ppu->palette[18] = 0x24; // Rosa    ppu->palette[19] = 0x30; // Branco    ppu->palette[21] = 0x02; // Azul    ppu->palette[22] = 0x12; // Azul claro    ppu->palette[23] = 0x30; // Branco    ppu->palette[25] = 0x08; // Verde escuro    ppu->palette[26] = 0x18; // Verde lima    ppu->palette[27] = 0x30; // Branco    ppu->palette[29] = 0x0A; // Cinza escuro    ppu->palette[30] = 0x1A; // Cinza claro    ppu->palette[31] = 0x30; // Branco    // Inicializa o modo de espelhamento    ppu->mirror_mode = NES_MIRROR_HORIZONTAL; // Padrão    // Inicializa o sprite 0 para debugging    ppu->oam[0] = 30; // Y position    ppu->oam[1] = 1;  // Tile index    ppu->oam[2] = 0;  // Attributes    ppu->oam[3] = 30; // X position    // Inicializa o frame count    ppu->frame_count = 0;    // Inicializa com o reset para configurar os registradores adequadamente    nes_ppu_reset(ppu);    PPU_LOG_INFO("PPU inicializada com sucesso");    return ppu;}/** * @brief Libera os recursos utilizados pela PPU * * @param ppu Ponteiro para a PPU */void nes_ppu_shutdown(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_shutdown: PPU inválida");        return;    }    PPU_LOG_INFO("Desligando PPU do NES");    // Libera o buffer de frame    if (ppu->frame_buffer)    {        PPU_LOG_DEBUG("Liberando frame buffer");        free(ppu->frame_buffer);        ppu->frame_buffer = NULL;    }    // Libera a paleta    if (ppu->palette)    {        PPU_LOG_DEBUG("Liberando paleta");        free(ppu->palette);        ppu->palette = NULL;    }    // Libera o OAM    if (ppu->oam)    {        PPU_LOG_DEBUG("Liberando OAM");        free(ppu->oam);        ppu->oam = NULL;    }    // Libera a VRAM    if (ppu->vram)    {        PPU_LOG_DEBUG("Liberando VRAM");        free(ppu->vram);        ppu->vram = NULL;    }    // Libera a estrutura principal    free(ppu);}/** * @brief Reseta o estado da PPU para os valores iniciais * * @param ppu Ponteiro para a PPU */void nes_ppu_reset(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_reset: PPU é NULL");        return;    }    PPU_LOG_INFO("Iniciando reset da PPU");    // Reseta os registradores    ppu->reg_ctrl = 0x00;    ppu->reg_mask = 0x00;    ppu->reg_status = 0x00;    ppu->reg_oam_addr = 0x00;    ppu->reg_scroll_x = 0x00;    ppu->reg_scroll_y = 0x00;    ppu->reg_vram_addr = 0x0000;    ppu->reg_vram_temp = 0x0000;    ppu->fine_x = 0;    ppu->write_toggle = false;    ppu->read_buffer = 0;    PPU_LOG_DEBUG("Registradores resetados para valores iniciais");    // Ativar PPU após reset para garantir a renderização    // Habilita background e sprites    ppu->reg_mask = NES_PPUMASK_SHOW_BACKGROUND | NES_PPUMASK_SHOW_SPRITES;    // Configura para usar a primeira pattern table para background    ppu->reg_ctrl = NES_PPUCTRL_BACKGROUND_TABLE;    PPU_LOG_DEBUG("PPU configurada para renderização:");    PPU_LOG_DEBUG("  PPUMASK = 0x%02X (background e sprites habilitados)", ppu->reg_mask);    PPU_LOG_DEBUG("  PPUCTRL = 0x%02X (pattern table 0x1000 para background)", ppu->reg_ctrl);    // Reseta o estado do frame    ppu->scanline = -1;    ppu->cycle = 0;    ppu->frame_count = 0;    ppu->odd_frame = false;    PPU_LOG_DEBUG("Estado do frame resetado: scanline=%d, cycle=%d, frame=%d",                  ppu->scanline, ppu->cycle, ppu->frame_count);    // Reseta o estado de NMI    ppu->nmi_output = false;    ppu->nmi_previous = false;    ppu->nmi_occurred = false;    ppu->nmi_delay = 0;    PPU_LOG_DEBUG("Estado de NMI resetado");    // Reseta o OAM    memset(ppu->oam, 0xFF, NES_PPU_OAM_SIZE); // 0xFF é o valor padrão para OAM    ppu->oam_addr = 0;    ppu->sprite_count = 0;    ppu->sprite_zero_hit_possible = false;    ppu->sprite_zero_being_rendered = false;    PPU_LOG_DEBUG("OAM resetada: addr=0x%02X, sprite_count=%d", ppu->oam_addr, ppu->sprite_count);    // Verifica se o cartucho está disponível    if (ppu->cartridge)    {        nes_cartridge_t *cart = (nes_cartridge_t *)ppu->cartridge;        PPU_LOG_DEBUG("Cartucho disponível:");        PPU_LOG_DEBUG("  Mapper: %d", cart->mapper_number);        PPU_LOG_DEBUG("  CHR-ROM: %d bytes", cart->chr_rom_size);        PPU_LOG_DEBUG("  CHR-RAM: %d bytes", cart->chr_ram_size);        PPU_LOG_DEBUG("  Mirror mode: %d", cart->mirror_mode);    }    else    {        PPU_LOG_WARN("Cartucho não disponível durante o reset");    }    PPU_LOG_INFO("Reset da PPU concluído");}/** * @brief Configura o modo de espelhamento * * @param ppu Ponteiro para a PPU * @param mode Modo de espelhamento */void nes_ppu_set_mirror_mode(nes_ppu_t *ppu, nes_mirror_mode_t mode){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_set_mirror_mode: PPU é NULL");        return;    }    const char *mode_names[] = {        "HORIZONTAL", "VERTICAL", "SINGLE_SCREEN_A",        "SINGLE_SCREEN_B", "FOUR_SCREEN"};    if (mode >= 0 && mode <= NES_MIRROR_FOUR_SCREEN)    {        PPU_LOG_INFO("Modo de espelhamento configurado: %s (%d)", mode_names[mode], mode);    }    else    {        PPU_LOG_ERROR("Modo de espelhamento inválido: %d", mode);        // Use horizontal como fallback        mode = NES_MIRROR_HORIZONTAL;    }    ppu->mirror_mode = mode;    PPU_LOG_DEBUG("Modo de espelhamento definido para %d", mode);}/** * @brief Lê um byte dos registradores da PPU * * @param ppu Ponteiro para a PPU * @param address Endereço do registrador ($2000-$2007) * @return uint8_t Valor lido */uint8_t nes_ppu_read_register(nes_ppu_t *ppu, uint16_t address){    if (!ppu)    {        return 0;    }    // Mapeia endereço para faixa de registradores    uint16_t reg_addr = 0x2000 + (address % 8);    switch (reg_addr)    {    case 0x2000: // PPUCTRL    case 0x2001: // PPUMASK    case 0x2003: // OAMADDR    case 0x2005: // PPUSCROLL    case 0x2006: // PPUADDR        // Estes registradores são write-only, retornam lixo de dados        PPU_LOG_DEBUG("Leitura de registrador write-only: $%04X", reg_addr);        return 0xFF; // Hardware real retorna o último byte no barramento    case 0x2002: // PPUSTATUS    {        // Salva o valor atual do status        uint8_t status = ppu->reg_status;        // Limpa o bit de VBlank após a leitura        ppu->reg_status &= ~NES_PPUSTATUS_VBLANK;        // Reseta toggle de escritas em PPUSCROLL/PPUADDR        ppu->write_toggle = 0;        PPU_LOG_DEBUG("Leitura de PPUSTATUS: $%02X", status);        return status;    }    case 0x2004: // OAMDATA    {        uint8_t data = ppu->oam[ppu->reg_oam_addr];        PPU_LOG_DEBUG("Leitura de OAMDATA[$%02X]: $%02X", ppu->reg_oam_addr, data);        return data;    }    case 0x2007: // PPUDATA    {        uint16_t addr = ppu->reg_vram_addr;        uint8_t data;        // Leituras de PPUDATA são bufferizadas        if (addr >= 0x3F00)        {            // Leituras da paleta são imediatas            data = nes_ppu_read_vram(ppu, addr);            // Mas o buffer ainda é atualizado com o valor de espelhamento            ppu->read_buffer = nes_ppu_read_vram(ppu, addr - 0x1000);        }        else        {            // Retorna o valor do buffer            data = ppu->read_buffer;            // E atualiza o buffer com o valor atual            ppu->read_buffer = nes_ppu_read_vram(ppu, addr);        }        // Incrementa o endereço (1 ou 32 dependendo do bit PPUCTRL)        if (ppu->reg_ctrl & NES_PPUCTRL_INCREMENT)        {            ppu->reg_vram_addr += 32;        }        else        {            ppu->reg_vram_addr += 1;        }        // Mantém o endereço na faixa válida        ppu->reg_vram_addr &= 0x3FFF;        PPU_LOG_DEBUG("Leitura de PPUDATA[$%04X]: $%02X", addr, data);        return data;    }    default:        PPU_LOG_WARN("Leitura de registrador PPU desconhecido: $%04X", address);        return 0;    }}/** * @brief Escreve um byte nos registradores da PPU * * @param ppu Ponteiro para a PPU * @param address Endereço do registrador ($2000-$2007) * @param value Valor a escrever */void nes_ppu_write_register(nes_ppu_t *ppu, uint16_t address, uint8_t value){    if (!ppu)    {        return;    }    // Mapeia endereço para faixa de registradores    uint16_t reg_addr = 0x2000 + (address % 8);    switch (reg_addr)    {    case 0x2000: // PPUCTRL        ppu->reg_ctrl = value;        // Atualiza bits de seleção de nametable no registro temporário        ppu->reg_vram_temp = (ppu->reg_vram_temp & 0xF3FF) | ((value & 0x03) << 10);        // Atualiza flag de NMI output        ppu->nmi_output = (value & NES_PPUCTRL_NMI_ENABLE) != 0;        PPU_LOG_DEBUG("Escrita em PPUCTRL: $%02X", value);        break;    case 0x2001: // PPUMASK        ppu->reg_mask = value;        PPU_LOG_DEBUG("Escrita em PPUMASK: $%02X", value);        break;    case 0x2002: // PPUSTATUS        PPU_LOG_WARN("Tentativa de escrita em registrador read-only: PPUSTATUS");        break;    case 0x2003: // OAMADDR        ppu->reg_oam_addr = value;        PPU_LOG_DEBUG("Escrita em OAMADDR: $%02X", value);        break;    case 0x2004: // OAMDATA        ppu->oam[ppu->reg_oam_addr] = value;        ppu->reg_oam_addr++; // Auto-incrementa        PPU_LOG_DEBUG("Escrita em OAMDATA[$%02X]: $%02X", ppu->reg_oam_addr - 1, value);        break;    case 0x2005: // PPUSCROLL        if (ppu->write_toggle == 0)        {            // Primeira escrita (X)            ppu->reg_scroll_x = value;            ppu->fine_x = value & 0x07; // 3 bits finos            // Atualiza coarse X (5 bits) no registro temporário            ppu->reg_vram_temp = (ppu->reg_vram_temp & 0xFFE0) | (value >> 3);            ppu->write_toggle = 1;            PPU_LOG_DEBUG("Escrita em PPUSCROLL (X): $%02X", value);        }        else        {            // Segunda escrita (Y)            ppu->reg_scroll_y = value;            // Atualiza fine Y (3 bits) no registro temporário            ppu->reg_vram_temp = (ppu->reg_vram_temp & 0x8FFF) | ((value & 0x07) << 12);            // Atualiza coarse Y (5 bits) no registro temporário            ppu->reg_vram_temp = (ppu->reg_vram_temp & 0xFC1F) | ((value >> 3) << 5);            ppu->write_toggle = 0;            PPU_LOG_DEBUG("Escrita em PPUSCROLL (Y): $%02X", value);        }        break;    case 0x2006: // PPUADDR        if (ppu->write_toggle == 0)        {            // Primeira escrita (byte alto)            ppu->reg_vram_temp = (ppu->reg_vram_temp & 0x00FF) | ((value & 0x3F) << 8);            ppu->write_toggle = 1;            PPU_LOG_DEBUG("Escrita em PPUADDR (alto): $%02X", value);        }        else        {            // Segunda escrita (byte baixo)            ppu->reg_vram_temp = (ppu->reg_vram_temp & 0xFF00) | value;            ppu->reg_vram_addr = ppu->reg_vram_temp;            ppu->write_toggle = 0;            PPU_LOG_DEBUG("Escrita em PPUADDR (baixo): $%02X, endereço final: $%04X", value, ppu->reg_vram_addr);        }        break;    case 0x2007: // PPUDATA    {        uint16_t addr = ppu->reg_vram_addr;        // Escreve na VRAM        nes_ppu_write_vram(ppu, addr, value);        // Incrementa o endereço (1 ou 32 dependendo do bit PPUCTRL)        if (ppu->reg_ctrl & NES_PPUCTRL_INCREMENT)        {            ppu->reg_vram_addr += 32;        }        else        {            ppu->reg_vram_addr += 1;        }        // Mantém o endereço na faixa válida        ppu->reg_vram_addr &= 0x3FFF;        PPU_LOG_DEBUG("Escrita em PPUDATA[$%04X]: $%02X", addr, value);    }    break;    default:        PPU_LOG_WARN("Escrita em registrador PPU desconhecido: $%04X = $%02X", address, value);        break;    }}/** * @brief Lê um byte da VRAM * * @param ppu Ponteiro para a PPU * @param address Endereço para ler * @return uint8_t Valor lido */static uint8_t nes_ppu_read_vram(nes_ppu_t *ppu, uint16_t address){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_read_vram: ppu é NULL");        return 0;    }    // Normaliza o endereço para o range 0x0000-0x3FFF    address &= 0x3FFF;    PPU_LOG_DEBUG("nes_ppu_read_vram: lendo endereço 0x%04X", address);    // Pattern tables: 0x0000-0x1FFF (CHR ROM/RAM)    if (address < 0x2000)    {        // Leitura do CHR ROM/RAM através do cartridge        if (ppu->cartridge)        {            PPU_LOG_DEBUG("nes_ppu_read_vram: acessando CHR ROM/RAM via cartucho em 0x%04X", address);            // Acesso ao cartridge            nes_cartridge_t *cart = (nes_cartridge_t *)ppu->cartridge;            if (cart)            {                uint8_t value = nes_cartridge_chr_read(cart, address);                PPU_LOG_DEBUG("nes_ppu_read_vram: CHR ROM/RAM retornou 0x%02X", value);                return value;            }        }        PPU_LOG_WARN("nes_ppu_read_vram: cartucho não disponível, lendo da VRAM diretamente");        // Fallback para leitura direta da VRAM        if (address < NES_PPU_VRAM_SIZE)        {            uint8_t value = ppu->vram[address];            PPU_LOG_DEBUG("nes_ppu_read_vram: leitura direta da VRAM[0x%04X] = 0x%02X", address, value);            return value;        }    }    // Nametables: 0x2000-0x3EFF    else if (address < 0x3F00)    {        // Espelhamento dos nametables        uint16_t mirrored_addr = nes_ppu_mirror_address(ppu, address);        PPU_LOG_DEBUG("nes_ppu_read_vram: nametable em 0x%04X espelhado para 0x%04X", address, mirrored_addr);        // Range válido para VRAM        if (mirrored_addr < NES_PPU_VRAM_SIZE)        {            uint8_t value = ppu->vram[mirrored_addr];            PPU_LOG_DEBUG("nes_ppu_read_vram: leitura de nametable VRAM[0x%04X] = 0x%02X", mirrored_addr, value);            return value;        }    }    // Palettes: 0x3F00-0x3FFF    else    {        // Espelhamento da paleta        uint8_t palette_addr = (address & 0x1F);        PPU_LOG_DEBUG("nes_ppu_read_vram: acessando paleta em 0x%04X (índice 0x%02X)", address, palette_addr);        // Espelhamento de endereços específicos da paleta        if (palette_addr >= 16 && palette_addr % 4 == 0)        {            palette_addr = palette_addr - 16;            PPU_LOG_DEBUG("nes_ppu_read_vram: espelhamento de paleta ajustado para índice 0x%02X", palette_addr);        }        if (palette_addr < NES_PPU_PALETTE_SIZE)        {            uint8_t value = ppu->palette[palette_addr];            PPU_LOG_DEBUG("nes_ppu_read_vram: leitura de paleta[0x%02X] = 0x%02X", palette_addr, value);            return value;        }    }    PPU_LOG_ERROR("nes_ppu_read_vram: endereço inválido: 0x%04X", address);    return 0;}/** * @brief Escreve um byte na VRAM * * @param ppu Ponteiro para a PPU * @param address Endereço para escrever * @param value Valor a escrever */static void nes_ppu_write_vram(nes_ppu_t *ppu, uint16_t address, uint8_t value){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_write_vram: ppu é NULL");        return;    }    // Normaliza o endereço para o range 0x0000-0x3FFF    address &= 0x3FFF;    PPU_LOG_DEBUG("nes_ppu_write_vram: escrevendo valor 0x%02X no endereço 0x%04X", value, address);    // Pattern tables: 0x0000-0x1FFF (CHR ROM/RAM)    if (address < 0x2000)    {        // Escrita no CHR ROM/RAM através do cartridge        if (ppu->cartridge)        {            PPU_LOG_DEBUG("nes_ppu_write_vram: tentando escrever no CHR ROM/RAM via cartucho em 0x%04X", address);            // Acesso ao cartridge            nes_cartridge_t *cart = (nes_cartridge_t *)ppu->cartridge;            if (cart)            {                nes_cartridge_chr_write(cart, address, value);                PPU_LOG_DEBUG("nes_ppu_write_vram: escrita no CHR ROM/RAM completada");                return;            }        }        PPU_LOG_WARN("nes_ppu_write_vram: cartucho não disponível, escrevendo na VRAM diretamente");        // Fallback para escrita direta na VRAM        if (address < NES_PPU_VRAM_SIZE)        {            ppu->vram[address] = value;            PPU_LOG_DEBUG("nes_ppu_write_vram: escrita direta na VRAM[0x%04X] = 0x%02X", address, value);            return;        }    }    // Nametables: 0x2000-0x3EFF    else if (address < 0x3F00)    {        // Espelhamento dos nametables        uint16_t mirrored_addr = nes_ppu_mirror_address(ppu, address);        PPU_LOG_DEBUG("nes_ppu_write_vram: nametable em 0x%04X espelhado para 0x%04X", address, mirrored_addr);        // Range válido para VRAM        if (mirrored_addr < NES_PPU_VRAM_SIZE)        {            ppu->vram[mirrored_addr] = value;            PPU_LOG_DEBUG("nes_ppu_write_vram: escrita em nametable VRAM[0x%04X] = 0x%02X", mirrored_addr, value);            return;        }    }    // Palettes: 0x3F00-0x3FFF    else    {        // Espelhamento da paleta        uint8_t palette_addr = (address & 0x1F);        PPU_LOG_DEBUG("nes_ppu_write_vram: acessando paleta em 0x%04X (índice 0x%02X)", address, palette_addr);        // Espelhamento de endereços específicos da paleta        if (palette_addr >= 16 && palette_addr % 4 == 0)        {            palette_addr = palette_addr - 16;            PPU_LOG_DEBUG("nes_ppu_write_vram: espelhamento de paleta ajustado para índice 0x%02X", palette_addr);        }        if (palette_addr < NES_PPU_PALETTE_SIZE)        {            ppu->palette[palette_addr] = value;            PPU_LOG_DEBUG("nes_ppu_write_vram: escrita em paleta[0x%02X] = 0x%02X", palette_addr, value);            return;        }    }    PPU_LOG_ERROR("nes_ppu_write_vram: endereço inválido: 0x%04X", address);}/** * @brief Lê um byte da paleta * * @param ppu Ponteiro para a PPU * @param address Endereço para ler (0-31) * @return uint8_t Valor lido */static uint8_t nes_ppu_read_palette(nes_ppu_t *ppu, uint8_t address){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_read_palette: PPU inválida");        return 0;    }    // Verifica limites do endereço    if (address >= NES_PPU_PALETTE_SIZE)    {        PPU_LOG_ERROR("nes_ppu_read_palette: endereço fora dos limites: $%02X", address);        return 0;    }    // Espelhamento das paletas    if (address >= 16 && (address & 0x03) == 0)    {        address -= 16;    }    return ppu->palette[address];}/** * @brief Escreve um byte na paleta * * @param ppu Ponteiro para a PPU * @param address Endereço para escrever * @param value Valor a escrever */static void nes_ppu_write_palette(nes_ppu_t *ppu, uint8_t address, uint8_t value){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_write_palette: PPU inválida");        return;    }    // Verifica limites do endereço    if (address >= NES_PPU_PALETTE_SIZE)    {        PPU_LOG_ERROR("nes_ppu_write_palette: endereço fora dos limites: $%02X", address);        return;    }    // Espelhamento das paletas    if (address >= 16 && (address & 0x03) == 0)    {        address -= 16;    }    ppu->palette[address] = value;}/** * @brief Transfere dados para a OAM via DMA * * @param ppu Ponteiro para a PPU * @param data Ponteiro para os dados a transferir (256 bytes) */void nes_ppu_oam_dma(nes_ppu_t *ppu, const uint8_t *data){    if (!ppu || !data)    {        return;    }    // Copia 256 bytes para a OAM a partir da posição atual    for (int i = 0; i < 256; i++)    {        ppu->oam[(ppu->reg_oam_addr + i) & 0xFF] = data[i];    }    PPU_LOG_DEBUG("DMA para OAM concluído");}/** * @brief Verifica se o frame atual foi completado * * @param ppu Ponteiro para a PPU * @return bool Verdadeiro se o frame foi completado, falso caso contrário */bool nes_ppu_frame_complete(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_frame_complete: ppu é NULL");        return false;    }    // O frame é considerado completo quando estamos no início de um novo frame    // Tipicamente quando scanline = -1 (pre-render) e cycle = 0    return (ppu->scanline == -1 && ppu->cycle == 0);}/** * @brief Obtém o buffer de frame atual * * @param ppu Ponteiro para a PPU * @return uint32_t* Ponteiro para o buffer de frame */uint32_t *nes_ppu_get_frame_buffer(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_get_frame_buffer: ppu é NULL");        return NULL;    }    return ppu->frame_buffer;}/** * @brief Verifica se um NMI foi disparado * * @param ppu Ponteiro para a PPU * @return bool Verdadeiro se NMI foi disparado, falso caso contrário */bool nes_ppu_nmi_triggered(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_nmi_triggered: ppu é NULL");        return false;    }    return ppu->nmi_occurred && (ppu->reg_ctrl & NES_PPUCTRL_NMI_ENABLE);}/** * @brief Limpa o flag de NMI * * @param ppu Ponteiro para a PPU */void nes_ppu_clear_nmi(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_clear_nmi: ppu é NULL");        return;    }    ppu->nmi_occurred = false;}/** * @brief Atualiza o estado da PPU por um número de ciclos * * @param ppu Ponteiro para a PPU * @param cycles Número de ciclos da CPU a processar (cada ciclo da CPU = 3 ciclos da PPU) */void nes_ppu_update(nes_ppu_t *ppu, uint32_t cycles){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_update: PPU inválida");        return;    }    // A PPU executa 3 ciclos para cada ciclo da CPU    uint32_t ppu_cycles = cycles * 3;    // Executa o número especificado de ciclos da PPU    for (uint32_t i = 0; i < ppu_cycles; i++)    {        // Executa um ciclo da PPU        nes_ppu_step(ppu);    }}/** * @brief Renderiza o frame atual da PPU * * @param ppu Ponteiro para a PPU * @param frame_buffer Buffer para receber a imagem renderizada (se NULL, usa o buffer interno) */void nes_ppu_render_frame(nes_ppu_t *ppu, uint32_t *frame_buffer){    if (!ppu || !frame_buffer)    {        PPU_LOG_ERROR("Parâmetros inválidos em nes_ppu_render_frame");        return;    }    PPU_LOG_DEBUG("Iniciando renderização do frame");    // Limpa o buffer antes de renderizar    memset(frame_buffer, 0, NES_SCREEN_WIDTH * NES_SCREEN_HEIGHT * sizeof(uint32_t));    // Verifica se a renderização está habilitada    if (!(ppu->reg_mask & NES_PPUMASK_SHOW_BACKGROUND) &&        !(ppu->reg_mask & NES_PPUMASK_SHOW_SPRITES))    {        PPU_LOG_WARN("Renderização desabilitada - pulando frame");        return;    }    // Renderiza background se habilitado    if (ppu->reg_mask & NES_PPUMASK_SHOW_BACKGROUND)    {        PPU_LOG_TRACE("Renderizando background");        render_background(ppu, frame_buffer);    }    // Renderiza sprites se habilitado    if (ppu->reg_mask & NES_PPUMASK_SHOW_SPRITES)    {        PPU_LOG_TRACE("Renderizando sprites");        render_sprites(ppu, frame_buffer);    }    // Aplica máscara de cores    apply_color_mask(ppu);    PPU_LOG_DEBUG("Frame renderizado com sucesso");}/** * @brief Renderiza o background * @param ppu Ponteiro para a PPU */static void render_background(nes_ppu_t *ppu, uint32_t *frame_buffer){    if (!ppu || !frame_buffer)    {        PPU_LOG_ERROR("render_background: ppu ou frame_buffer é NULL");        return;    }    PPU_LOG_INFO("Iniciando renderização de background");    // Verifica se o background está habilitado    if (!(ppu->reg_mask & NES_PPUMASK_SHOW_BACKGROUND))    {        PPU_LOG_INFO("Background desabilitado via PPUMASK, preenchendo com cor de fundo");        uint32_t bg_color = NES_PALETTE[nes_ppu_read_palette(ppu, 0) & 0x3F];        PPU_LOG_DEBUG("Cor de fundo: 0x%08X", bg_color);        for (int i = 0; i < NES_SCREEN_WIDTH * NES_SCREEN_HEIGHT; i++)        {            frame_buffer[i] = bg_color;        }        return;    }    // Obtém o endereço base da nametable    uint16_t nametable_addr = 0x2000 | (ppu->reg_vram_addr & 0x0FFF);    PPU_LOG_DEBUG("Endereço base da nametable: 0x%04X", nametable_addr);    // Obtém o endereço base da tabela de padrões do background    uint16_t pattern_table = (ppu->reg_ctrl & NES_PPUCTRL_BACKGROUND_TABLE) ? 0x1000 : 0;    PPU_LOG_DEBUG("Endereço base da pattern table: 0x%04X", pattern_table);    // Para cada tile na tela    for (int y = 0; y < 30; y++)    {        for (int x = 0; x < 32; x++)        {            // Lê o índice do tile da nametable            uint16_t tile_addr = nametable_addr + y * 32 + x;            uint8_t tile_index = nes_ppu_read_vram(ppu, tile_addr);            // Lê o atributo para este tile            uint16_t attr_addr = 0x23C0 | (nametable_addr & 0x0C00) | ((y >> 2) << 3) | (x >> 2);            uint8_t attr = nes_ppu_read_vram(ppu, attr_addr);            // Calcula qual parte do byte de atributo usar            int shift = ((y & 2) << 1) | (x & 2);            uint8_t palette_index = (attr >> shift) & 0x3;            PPU_LOG_DEBUG("Tile (%d,%d): index=%02X, attr=%02X, palette=%d",                          x, y, tile_index, attr, palette_index);            // Para cada linha do tile            for (int tile_y = 0; tile_y < 8; tile_y++)            {                // Calcula os endereços dos planos de bits do tile                uint16_t pattern_addr_low = (uint16_t)(pattern_table + (tile_index * 16) + tile_y);                uint16_t pattern_addr_high = (uint16_t)(pattern_addr_low + 8);                // Lê os dois planos de bits do tile                uint8_t pattern_data_low = nes_ppu_read(ppu, pattern_addr_low);                uint8_t pattern_data_high = nes_ppu_read(ppu, pattern_addr_high);                PPU_LOG_DEBUG("Tile (%d,%d) linha %d: addr_low=0x%04X, addr_high=0x%04X, pattern_low=%02X pattern_high=%02X",                              x, y, tile_y, pattern_addr_low, pattern_addr_high, pattern_data_low, pattern_data_high);                // Para cada pixel do tile                for (int tile_x = 0; tile_x < 8; tile_x++)                {                    // Combina os bits dos dois planos para formar o índice de cor                    int bit_low = (pattern_data_low >> (7 - tile_x)) & 1;                    int bit_high = (pattern_data_high >> (7 - tile_x)) & 1;                    uint8_t color_index = (bit_high << 1) | bit_low;                    // Se o pixel não é transparente                    if (color_index > 0)                    {                        // Calcula o endereço na paleta                        uint8_t palette_addr = 0x3F00 + (palette_index << 2) + color_index;                        uint8_t color = nes_ppu_read_palette(ppu, palette_addr & 0x1F);                        PPU_LOG_DEBUG("Pixel (%d,%d) em (%d,%d): color_index=%d, palette_addr=0x%02X, color=0x%02X",                                      tile_x, tile_y, x * 8 + tile_x, y * 8 + tile_y, color_index, palette_addr, color);                        // Calcula a posição no frame buffer                        int pixel_x = x * 8 + tile_x;                        int pixel_y = y * 8 + tile_y;                        if (pixel_x < NES_SCREEN_WIDTH && pixel_y < NES_SCREEN_HEIGHT)                        {                            uint32_t final_color = NES_PALETTE[color & 0x3F];                            ppu->frame_buffer[pixel_y * NES_SCREEN_WIDTH + pixel_x] = final_color;                        }                    }                }            }        }    }    PPU_LOG_INFO("Renderização de background concluída");}/** * @brief Renderiza os sprites * @param ppu Ponteiro para a PPU */static void render_sprites(nes_ppu_t *ppu, uint32_t *frame_buffer){    if (!ppu || !frame_buffer)    {        PPU_LOG_ERROR("render_sprites: ppu ou frame_buffer é NULL");        return;    }    PPU_LOG_INFO("Iniciando renderização de sprites");    // Se os sprites estão desabilitados, retorna    if (!(ppu->reg_mask & NES_PPUMASK_SHOW_SPRITES))    {        PPU_LOG_INFO("Sprites desabilitados via PPUMASK");        return;    }    // Diagnóstico: Verificar se temos acesso ao cartucho    if (!ppu->cartridge)    {        PPU_LOG_ERROR("render_sprites: Cartucho é NULL, não é possível renderizar sprites");        return;    }    PPU_LOG_DEBUG("Pattern table dos sprites: 0x%04X",                  (ppu->reg_ctrl & NES_PPUCTRL_SPRITE_TABLE) ? 0x1000 : 0x0000);    PPU_LOG_DEBUG("Tamanho dos sprites: %s",                  (ppu->reg_ctrl & NES_PPUCTRL_SPRITE_SIZE) ? "8x16" : "8x8");    // Para cada sprite na OAM (em ordem reversa para prioridade correta)    for (int i = 63; i >= 0; i--)    {        // Dados do sprite da OAM        uint8_t sprite_y = ppu->oam[i * 4];     // Y position        uint8_t tile_idx = ppu->oam[i * 4 + 1]; // Tile index        uint8_t attrs = ppu->oam[i * 4 + 2];    // Attributes        uint8_t sprite_x = ppu->oam[i * 4 + 3]; // X position        // Se o sprite está fora da tela vertical, pula        if (sprite_y >= 0xEF)        {            PPU_LOG_TRACE("Sprite %d ignorado: Y position (0x%02X) >= 0xEF", i, sprite_y);            continue;        }        PPU_LOG_DEBUG("Processando sprite %d: x=%d, y=%d, tile=%02X, attr=%02X",                      i, sprite_x, sprite_y, tile_idx, attrs);        // Extrai atributos        bool flip_horizontal = attrs & 0x40;        bool flip_vertical = attrs & 0x80;        bool priority = attrs & 0x20;        uint8_t palette_idx = attrs & 0x03;        PPU_LOG_DEBUG("Sprite %d atributos: flip_h=%d, flip_v=%d, priority=%d, palette=%d",                      i, flip_horizontal, flip_vertical, priority, palette_idx);        // Altura do sprite (8 ou 16 pixels)        int height = (ppu->reg_ctrl & NES_PPUCTRL_SPRITE_SIZE) ? 16 : 8;        // Endereço base do pattern table para sprites        uint16_t pattern_addr;        if (height == 16)        {            // Em modo 8x16, bit 0 do tile seleciona o pattern table            pattern_addr = (tile_idx & 1) ? 0x1000 : 0x0000;            tile_idx &= 0xFE; // Limpa bit 0            PPU_LOG_DEBUG("Sprite %d usando modo 8x16: pattern_addr=0x%04X, tile_idx=0x%02X",                          i, pattern_addr, tile_idx);        }        else        {            // Em modo 8x8, bit 3 do PPUCTRL seleciona o pattern table            pattern_addr = (ppu->reg_ctrl & NES_PPUCTRL_SPRITE_TABLE) ? 0x1000 : 0x0000;            PPU_LOG_DEBUG("Sprite %d usando modo 8x8: pattern_addr=0x%04X", i, pattern_addr);        }        // Renderiza o sprite        for (int row = 0; row < height; row++)        {            int y = sprite_y + (flip_vertical ? (height - 1 - row) : row);            if (y >= NES_SCREEN_HEIGHT)            {                PPU_LOG_TRACE("Sprite %d linha %d ignorada: y=%d >= altura da tela", i, row, y);                continue;            }            // Para sprites 8x16, segunda tile está 16 bytes depois            uint16_t tile_addr = pattern_addr + tile_idx * 16 + (row >= 8 ? 16 : 0) + (row & 7);            uint8_t pattern_low = nes_ppu_read_vram(ppu, tile_addr);            uint8_t pattern_high = nes_ppu_read_vram(ppu, tile_addr + 8);            PPU_LOG_TRACE("Sprite %d linha %d: addr=0x%04X, pattern_low=0x%02X, pattern_high=0x%02X",                          i, row, tile_addr, pattern_low, pattern_high);            for (int col = 0; col < 8; col++)            {                int x = sprite_x + (flip_horizontal ? (7 - col) : col);                if (x >= NES_SCREEN_WIDTH)                {                    PPU_LOG_TRACE("Sprite %d pixel ignorado: x=%d >= largura da tela", i, x);                    continue;                }                // Combina os bits dos planos para formar o índice de cor (0-3)                int shift = 7 - col;                int color_bit_lo = (pattern_low >> shift) & 1;                int color_bit_hi = (pattern_high >> shift) & 1;                int color_idx = (color_bit_hi << 1) | color_bit_lo;                // Se o pixel é transparente (cor 0), pula                if (color_idx == 0)                {                    PPU_LOG_TRACE("Sprite %d pixel (%d,%d) ignorado: transparente", i, x, y);                    continue;                }                // Calcula o índice final na paleta de sprites                uint8_t palette_offset = 0x10 + (palette_idx * 4); // Paletas de sprite começam em 0x10                uint8_t color = ppu->palette[palette_offset + color_idx];                uint32_t final_color = NES_PALETTE[color & 0x3F];                PPU_LOG_TRACE("Sprite %d pixel (%d,%d): color_idx=%d, palette_offset=0x%02X, color=0x%02X, final_color=0x%08X",                              i, x, y, color_idx, palette_offset, color, final_color);                // Se o sprite tem prioridade ou o background é transparente                if (!priority || (frame_buffer[y * NES_SCREEN_WIDTH + x] == NES_PALETTE[ppu->palette[0]]))                {                    frame_buffer[y * NES_SCREEN_WIDTH + x] = final_color;                }            }        }    }    PPU_LOG_INFO("Renderização de sprites concluída");}/** * @brief Aplica a máscara de cores baseada nos registradores da PPU * * @param ppu Ponteiro para a PPU */void apply_color_mask(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("apply_color_mask: PPU é nula");        return;    }    // Verifica se alguma ênfase de cor está ativa    bool emphasize_red = (ppu->reg_mask & NES_PPUMASK_EMPHASIZE_RED) != 0;    bool emphasize_green = (ppu->reg_mask & NES_PPUMASK_EMPHASIZE_GREEN) != 0;    bool emphasize_blue = (ppu->reg_mask & NES_PPUMASK_EMPHASIZE_BLUE) != 0;    if (!emphasize_red && !emphasize_green && !emphasize_blue)    {        PPU_LOG_DEBUG("Nenhuma ênfase de cor ativa");        return;    }    PPU_LOG_DEBUG("Aplicando máscara de cores: R=%d G=%d B=%d",                  emphasize_red, emphasize_green, emphasize_blue);    // Itera sobre todas as cores da paleta    for (int i = 0; i < 64; i++)    {        uint32_t color = NES_PALETTE[i];        // Extrai componentes ARGB        uint8_t alpha = (color >> 24) & 0xFF;        uint8_t red = (color >> 16) & 0xFF;        uint8_t green = (color >> 8) & 0xFF;        uint8_t blue = color & 0xFF;        // Aplica ênfase de cores        if (emphasize_red)        {            red = (uint8_t)(red * 1.1f);            green = (uint8_t)(green * 0.9f);            blue = (uint8_t)(blue * 0.9f);        }        if (emphasize_green)        {            red = (uint8_t)(red * 0.9f);            green = (uint8_t)(green * 1.1f);            blue = (uint8_t)(blue * 0.9f);        }        if (emphasize_blue)        {            red = (uint8_t)(red * 0.9f);            green = (uint8_t)(green * 0.9f);            blue = (uint8_t)(blue * 1.1f);        }        // Recompõe a cor com os novos valores        uint32_t new_color = (alpha << 24) | (red << 16) | (green << 8) | blue;        // Atualiza a paleta        ppu->palette[i] = new_color & 0x3F;    }    PPU_LOG_DEBUG("Máscara de cores aplicada com sucesso");}/** * @brief Executa um ciclo da PPU */static void nes_ppu_cycle_internal(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_cycle: PPU inválida");        return;    }    // Apenas renderiza se estiver no range visível    if (ppu->scanline >= 0 && ppu->scanline < 240 && ppu->cycle >= 1 && ppu->cycle <= 256)    {        // Coordenadas na tela        int screen_x = ppu->cycle - 1;        int screen_y = ppu->scanline;        // Renderização de background        uint8_t bg_pixel = 0;        uint8_t bg_palette = 0;        if (ppu->reg_mask & NES_PPUMASK_SHOW_BACKGROUND)        {            // Apenas renderiza o background se visível nesta posição            if ((ppu->reg_mask & NES_PPUMASK_SHOW_LEFT_BG) || screen_x >= 8)            {                // Obtém o scroll                uint16_t v = ppu->reg_vram_addr;                // Coordenadas do tile na nametable                uint8_t coarse_x = (v & 0x001F);                uint8_t coarse_y = (v & 0x03E0) >> 5;                uint8_t nametable_select = (v & 0x0C00) >> 10;                // Pixel dentro do tile                uint8_t fine_x = ppu->fine_x;                uint8_t fine_y = (v & 0x7000) >> 12;                // Calcula endereço base da nametable (0x2000-0x2FFF)                uint16_t nametable_addr = 0x2000 | (v & 0x0FFF);                // Remove os bits de fine Y para obter o endereço correto                nametable_addr = 0x2000 | (nametable_addr & 0x0FFF);                // Obtém ID do tile na nametable                uint8_t tile_id = nes_ppu_read(ppu, nametable_addr);                // Endereço da tabela de atributos                uint16_t attr_addr = 0x23C0 | (v & 0x0C00) | ((coarse_y >> 2) << 3) | (coarse_x >> 2);                uint8_t attr_byte = nes_ppu_read(ppu, attr_addr);                // Determina qual quadrante do attributo estamos                uint8_t attr_shift = ((coarse_y & 0x02) << 1) | (coarse_x & 0x02);                uint8_t palette_id = (attr_byte >> attr_shift) & 0x03;                // Calcular endereço na pattern table                uint16_t pattern_table = (ppu->reg_ctrl & NES_PPUCTRL_BACKGROUND_TABLE) ? 0x1000 : 0;                uint16_t pattern_addr = pattern_table + (tile_id * 16) + fine_y;                // Lê os dois planos de bits do tile                uint8_t pattern_low = nes_ppu_read(ppu, pattern_addr);                uint8_t pattern_high = nes_ppu_read(ppu, pattern_addr + 8);                // Seleciona o bit correto baseado no fine_x                uint8_t bit_offset = 7 - fine_x;                uint8_t pixel_low = (pattern_low >> bit_offset) & 1;                uint8_t pixel_high = (pattern_high >> bit_offset) & 1;                // Compõe o valor do pixel (0-3)                bg_pixel = (pixel_high << 1) | pixel_low;                // Define a paleta baseada no attributo                if (bg_pixel != 0)                {                    bg_palette = palette_id;                }                // Verifica sprite zero hit                if (ppu->reg_mask & NES_PPUMASK_SHOW_SPRITES)                {                    // Lógica para detectar sprite zero hit                    // ...                }                // Calcula o índice final na paleta                uint8_t palette_index = (bg_palette << 2) | bg_pixel;                // Apenas usa a paleta se o pixel não for transparente                if (bg_pixel != 0)                {                    // Lê a cor final da paleta                    uint8_t color_index = nes_ppu_read_palette(ppu, palette_index);                    uint32_t rgb_color = NES_PALETTE[color_index & 0x3F];                    // Escreve no framebuffer                    if (screen_y < NES_SCREEN_HEIGHT && screen_x < NES_SCREEN_WIDTH)                    {                        ppu->frame_buffer[screen_y * NES_SCREEN_WIDTH + screen_x] = rgb_color;                    }                }                else                {                    // Pixel de fundo (transparente)                    uint8_t color_index = nes_ppu_read_palette(ppu, 0);                    uint32_t rgb_color = NES_PALETTE[color_index & 0x3F];                    if (screen_y < NES_SCREEN_HEIGHT && screen_x < NES_SCREEN_WIDTH)                    {                        ppu->frame_buffer[screen_y * NES_SCREEN_WIDTH + screen_x] = rgb_color;                    }                }            }        }        // Renderização de sprites        uint8_t sprite_pixel = 0;        uint8_t sprite_palette = 0;        bool sprite_priority = false;        bool is_sprite_zero = false;        if (ppu->reg_mask & NES_PPUMASK_SHOW_SPRITES)        {            // Apenas renderiza sprites se visíveis nesta posição            if ((ppu->reg_mask & NES_PPUMASK_SHOW_LEFT_SPR) || screen_x >= 8)            {                // Procura por sprites nesta posição                for (int i = 0; i < ppu->sprite_count; i++)                {                    // Obtém dados do sprite                    uint8_t sprite_y = ppu->sprite_data[i][0];                    uint8_t sprite_tile = ppu->sprite_data[i][1];                    uint8_t sprite_attr = ppu->sprite_data[i][2];                    uint8_t sprite_x = ppu->sprite_data[i][3];                    // Verifica se o sprite está nesta posição                    if (screen_x >= sprite_x && screen_x < sprite_x + 8 &&                        screen_y >= sprite_y + 1 && screen_y < sprite_y + 9) // +1 pois sprite_y é o topo do sprite                    {                        // Coordenadas relativas dentro do sprite                        int sprite_pixel_x = screen_x - sprite_x;                        int sprite_pixel_y = screen_y - sprite_y - 1;                        // Aplica flip horizontal                        if (sprite_attr & 0x40) // Bit 6: horizontal flip                            sprite_pixel_x = 7 - sprite_pixel_x;                        // Aplica flip vertical                        if (sprite_attr & 0x80) // Bit 7: vertical flip                            sprite_pixel_y = 7 - sprite_pixel_y;                        // Determina qual pattern table usar para sprites                        uint16_t sprite_pattern_addr;                        // Para sprites 8x16                        if (ppu->reg_ctrl & NES_PPUCTRL_SPRITE_SIZE)                        {                            // Verificar se estamos na parte superior ou inferior do sprite                            bool bottom_half = sprite_pixel_y >= 8;                            if (bottom_half)                                sprite_pixel_y -= 8; // Ajusta para 0-7                            // Bit 0 do tile seleciona pattern table para sprites 8x16                            uint16_t base_addr = (sprite_tile & 1) ? 0x1000 : 0x0000;                            uint8_t tile_number = sprite_tile & 0xFE;                            // Adiciona 1 para bottom half                            if (bottom_half)                                tile_number++;                            sprite_pattern_addr = base_addr + (tile_number * 16) + sprite_pixel_y;                        }                        // Para sprites 8x8                        else                        {                            // Bit SPRITE_TABLE do reg_ctrl seleciona pattern table                            uint16_t base_addr = (ppu->reg_ctrl & NES_PPUCTRL_SPRITE_TABLE) ? 0x1000 : 0x0000;                            sprite_pattern_addr = base_addr + (sprite_tile * 16) + sprite_pixel_y;                        }                        // Lê os planos de bits                        uint8_t sprite_pattern_low = nes_ppu_read(ppu, sprite_pattern_addr);                        uint8_t sprite_pattern_high = nes_ppu_read(ppu, sprite_pattern_addr + 8);                        // Extrai o bit para o pixel atual                        uint8_t sprite_bit = 7 - sprite_pixel_x;                        sprite_pixel = ((sprite_pattern_low >> sprite_bit) & 1) | (((sprite_pattern_high >> sprite_bit) & 1) << 1);                        // Se o pixel não é transparente, armazena seus dados                        if (sprite_pixel > 0)                        {                            sprite_palette = (sprite_attr & 0x03) + 4; // Offset para paletas de sprite                            sprite_priority = !(sprite_attr & 0x20);   // Bit 5: 0=prioridade sprite, 1=prioridade background                            is_sprite_zero = (i == 0);                            break; // Para no primeiro sprite não transparente encontrado                        }                    }                }            }        }        // Detecta sprite-zero hit (apenas se ambos os pixels são opacos)        if (is_sprite_zero && bg_pixel > 0 && sprite_pixel > 0 &&            ppu->cycle < 256 && ppu->scanline < 239)        {            ppu->reg_status |= NES_PPUSTATUS_SPRITE_ZERO_HIT;        }        // Determina o pixel final (prioridade entre background e sprite)        uint8_t final_pixel = 0;        uint8_t final_palette_idx = 0;        if (bg_pixel == 0 && sprite_pixel == 0)        {            // Ambos transparentes - cor de background            final_pixel = 0;            final_palette_idx = 0;        }        else if (bg_pixel == 0)        {            // Apenas sprite visível            final_pixel = sprite_pixel;            final_palette_idx = sprite_palette;        }        else if (sprite_pixel == 0)        {            // Apenas background visível            final_pixel = bg_pixel;            final_palette_idx = bg_palette;        }        else        {            // Ambos visíveis - prioridade decide            if (sprite_priority)            {                // Sprite tem prioridade                final_pixel = sprite_pixel;                final_palette_idx = sprite_palette;            }            else            {                // Background tem prioridade                final_pixel = bg_pixel;                final_palette_idx = bg_palette;            }        }        // Calcula o endereço na paleta        uint8_t palette_addr = (final_palette_idx * 4) + final_pixel;        // Obtém a cor da paleta e renderiza        uint8_t color_idx = nes_ppu_read_palette(ppu, palette_addr);        uint32_t color = NES_PALETTE[color_idx & 0x3F];        // Verifica se as coordenadas estão dentro dos limites        if (screen_x >= 0 && screen_x < NES_SCREEN_WIDTH &&            screen_y >= 0 && screen_y < NES_SCREEN_HEIGHT)        {            ppu->frame_buffer[screen_y * NES_SCREEN_WIDTH + screen_x] = color;        }    }    // Aqui seria implementada a lógica restante para VBLANK, etc.}/** * @brief Funções auxiliares para scrolling */static void nes_ppu_increment_scroll_x(nes_ppu_t *ppu){    if ((ppu->reg_vram_addr & 0x001F) == 31)    {        // Se atingiu o final da nametable, reseta coarse X e troca de nametable horizontalmente        ppu->reg_vram_addr &= ~0x001F; // Coarse X = 0        ppu->reg_vram_addr ^= 0x0400;  // Troca bit 10 (troca nametable horizontalmente)    }    else    {        // Caso contrário, simplesmente incrementa coarse X        ppu->reg_vram_addr += 1;    }}/** * @brief Incrementa o scroll vertical * * @param ppu Ponteiro para a PPU */static void nes_ppu_increment_scroll_y(nes_ppu_t *ppu){    // Incrementa o fine Y    if ((ppu->reg_vram_addr & 0x7000) != 0x7000)    {        // Se fine Y < 7, apenas incrementa        ppu->reg_vram_addr += 0x1000;    }    else    {        // Fine Y = 0        ppu->reg_vram_addr &= ~0x7000;        // Pega o Y do coarse        int y = (ppu->reg_vram_addr & 0x03E0) >> 5;        if (y == 29)        {            // Coarse Y = 0 e troca de nametable            y = 0;            ppu->reg_vram_addr ^= 0x0800;        }        else if (y == 31)        {            // Coarse Y = 0, mas não troca de nametable            y = 0;        }        else        {            // Incrementa Y            y++;        }        // Coloca o Y de volta        ppu->reg_vram_addr = (ppu->reg_vram_addr & ~0x03E0) | (y << 5);    }}/** * @brief Copia os bits horizontais do registrador temporário para o registrador de endereço * * @param ppu Ponteiro para a PPU */static void nes_ppu_copy_horizontal_bits(nes_ppu_t *ppu){    // Copia os bits de nametable horizontal e coarse X    ppu->reg_vram_addr = (ppu->reg_vram_addr & ~0x041F) | (ppu->reg_vram_temp & 0x041F);}/** * @brief Copia os bits verticais do registrador temporário para o registrador de endereço * * @param ppu Ponteiro para a PPU */static void nes_ppu_copy_vertical_bits(nes_ppu_t *ppu){    // Copia os bits de nametable vertical, coarse Y e fine Y    ppu->reg_vram_addr = (ppu->reg_vram_addr & ~0x7BE0) | (ppu->reg_vram_temp & 0x7BE0);}/** * @brief Lê um byte da memória da PPU * * @param ppu Ponteiro para a PPU * @param address Endereço para ler * @return uint8_t Valor lido */uint8_t nes_ppu_read(nes_ppu_t *ppu, uint16_t address){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_read: PPU é NULL");        return 0;    }    // Espelha o endereço para o intervalo 0x0000-0x3FFF    address &= 0x3FFF;    // Pattern tables (0x0000-0x1FFF) - CHR ROM/RAM do cartucho    if (address < 0x2000)    {        if (ppu->cartridge)        {            // Acesso direto ao cartucho para pattern tables            return nes_cartridge_chr_read(ppu->cartridge, address);        }        PPU_LOG_WARN("nes_ppu_read: Tentativa de ler CHR-ROM/RAM sem cartucho");        return 0;    }    // Nametables (0x2000-0x3EFF) - VRAM com espelhamento    else if (address < 0x3F00)    {        // Mapeia o endereço de acordo com o modo de espelhamento        uint16_t mapped_addr = nes_ppu_mirror_address(ppu, address);        // Calcula o offset relativo ao início da VRAM (0x2000)        uint16_t vram_offset = mapped_addr & 0x0FFF;        // Verifica se o offset está dentro dos limites da VRAM        if (vram_offset >= 2048) // 2KB de VRAM        {            PPU_LOG_ERROR("nes_ppu_read: offset VRAM inválido: $%04X", vram_offset);            return 0;        }        return ppu->vram[vram_offset];    }    // Paletas (0x3F00-0x3FFF)    else    {        // Espelha as paletas a cada 32 bytes (0x20)        uint8_t palette_addr = address & 0x1F;        // Espelhamento específico das paletas        // Endereços 0x3F10/0x3F14/0x3F18/0x3F1C são espelhados em 0x3F00/0x3F04/0x3F08/0x3F0C        if (palette_addr >= 0x10 && (palette_addr & 0x03) == 0)        {            palette_addr &= 0x0F;        }        return ppu->palette[palette_addr];    }}/** * @brief Executa um ciclo da PPU * * @param ppu Ponteiro para a PPU */void nes_ppu_step(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_step: ppu é NULL");        return;    }    // Essa função é um alias para nes_ppu_cycle para manter compatibilidade com a interface    nes_ppu_cycle_internal(ppu);}/** * @brief Executa a PPU para o frame atual * * @param ppu Ponteiro para a PPU */void nes_ppu_execute(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_execute: ppu é NULL");        return;    }    // Executa a PPU até completar um frame    bool frame_completed = false;    while (!frame_completed)    {        nes_ppu_cycle_internal(ppu);        frame_completed = nes_ppu_frame_complete(ppu);    }}/** * @brief Escreve dados no OAM através de DMA * * @param ppu Ponteiro para a PPU * @param data Ponteiro para os dados a serem escritos */void nes_ppu_write_oam_dma(nes_ppu_t *ppu, uint8_t *data){    if (!ppu || !data)    {        PPU_LOG_ERROR("nes_ppu_write_oam_dma: parâmetros inválidos");        return;    }    // Alias para nes_ppu_oam_dma, para manter compatibilidade com a interface    nes_ppu_oam_dma(ppu, data);}/** * @brief Inicia um novo frame na PPU * * Esta função prepara a PPU para começar um novo frame, resetando * scanline e ciclo para o início do frame, além de incrementar * o contador de frames. * * @param ppu Ponteiro para a PPU */void nes_ppu_start_frame(nes_ppu_t *ppu){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_start_frame: PPU é NULL");        return;    }    // Configura o scanline e ciclo para o início do frame    ppu->scanline = -1; // Pré-render scanline    ppu->cycle = 0;    // Incrementa o contador de frames    ppu->frame_count++;    // Atualiza o flag de frame ímpar/par    ppu->odd_frame = (ppu->frame_count % 2 == 1);    PPU_LOG_DEBUG("Iniciando frame #%u (scanline=%d, cycle=%d)",                  ppu->frame_count, ppu->scanline, ppu->cycle);}static void render_tiles(nes_ppu_t *ppu){    if (!ppu || !ppu->frame_buffer)    {        PPU_LOG_ERROR("render_tiles: parâmetros inválidos");        return;    }    PPU_LOG_DEBUG("Iniciando renderização de tiles");    // Obtém valores necessários dos registradores    uint16_t v = ppu->reg_vram_addr; // Registro V (VRAM addr)    PPU_LOG_DEBUG("Registro V (VRAM addr): 0x%04X", v);    // Variáveis para armazenar o resultado final da renderização    uint8_t final_pixel = 0;    uint8_t final_palette_idx = 0;    // Para cada tile na tela    for (int y = 0; y < 30; y++)    {        for (int x = 0; x < 32; x++)        {            // Calcula o endereço da nametable para este tile            uint16_t nametable_addr = 0x2000 | (v & 0x0FFF);            uint16_t tile_addr = nametable_addr + y * 32 + x;            // Lê o índice do tile            uint8_t tile_id = nes_ppu_read_vram(ppu, tile_addr);            PPU_LOG_DEBUG("Tile (%d,%d): addr=0x%04X, id=0x%02X", x, y, tile_addr, tile_id);            // Lê o atributo para este tile            uint16_t attr_addr = 0x23C0 | (v & 0x0C00) | ((y >> 2) << 3) | (x >> 2);            uint8_t attr = nes_ppu_read_vram(ppu, attr_addr);            // Calcula qual parte do byte de atributo usar            uint8_t attr_shift = ((y & 2) << 1) | (x & 2);            uint8_t palette_idx = (attr >> attr_shift) & 0x03;            PPU_LOG_DEBUG("  Atributo: addr=0x%04X, valor=0x%02X, shift=%d, palette=%d",                          attr_addr, attr, attr_shift, palette_idx);            // Calcula o endereço na pattern table            uint16_t pattern_addr;            if (ppu->reg_ctrl & NES_PPUCTRL_BACKGROUND_TABLE)            {                // Pattern table em 0x1000                pattern_addr = 0x1000 + (tile_id * 16);            }            else            {                // Pattern table em 0x0000                pattern_addr = (tile_id * 16);            }            PPU_LOG_DEBUG("  Pattern table: addr=0x%04X", pattern_addr);            // Para cada linha do tile            for (int tile_y = 0; tile_y < 8; tile_y++)            {                // Lê os dois planos de bits do tile                uint8_t pattern_low = nes_ppu_read_vram(ppu, pattern_addr + tile_y);                uint8_t pattern_high = nes_ppu_read_vram(ppu, pattern_addr + tile_y + 8);                PPU_LOG_DEBUG("    Linha %d: low=0x%02X, high=0x%02X", tile_y, pattern_low, pattern_high);                // Para cada pixel da linha                for (int tile_x = 0; tile_x < 8; tile_x++)                {                    // Extrai os bits para formar o índice de cor (2 bits)                    uint8_t bit_shift = 7 - tile_x;                    uint8_t color_low = (pattern_low >> bit_shift) & 1;                    uint8_t color_high = (pattern_high >> bit_shift) & 1;                    uint8_t color_idx = (color_high << 1) | color_low;                    // Se o pixel não é transparente                    if (color_idx > 0)                    {                        // Calcula o endereço na paleta                        uint8_t palette_addr = (palette_idx << 2) | color_idx;                        uint8_t color = nes_ppu_read_palette(ppu, palette_addr);                        PPU_LOG_TRACE("      Pixel (%d,%d): color_idx=%d, palette_addr=0x%02X, color=0x%02X",                                      tile_x, tile_y, color_idx, palette_addr, color);                        // Calcula a posição no frame buffer                        int screen_x = x * 8 + tile_x;                        int screen_y = y * 8 + tile_y;                        // Verifica limites da tela                        if (screen_x < NES_SCREEN_WIDTH && screen_y < NES_SCREEN_HEIGHT)                        {                            // Converte o índice de cor para ARGB                            uint32_t argb = NES_PALETTE[color & 0x3F];                            ppu->frame_buffer[screen_y * NES_SCREEN_WIDTH + screen_x] = argb;                            PPU_LOG_TRACE("        Screen (%d,%d): ARGB=0x%08X",                                          screen_x, screen_y, argb);                        }                    }                }            }        }    }    PPU_LOG_DEBUG("Renderização de tiles concluída");}/** * Função helper para ler dados da paleta com espelhamento adequado * @param ppu Ponteiro para a PPU * @param address Endereço da paleta (0-31) * @return uint8_t Valor da cor na paleta */uint8_t nes_ppu_read_palette_public(nes_ppu_t *ppu, uint8_t address){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_read_palette: PPU inválida");        return 0;    }    // Garante que o endereço está no range válido (0-31)    address &= 0x1F;    // Espelhamento específico das paletas    // Endereços 0x10/0x14/0x18/0x1C são espelhados em 0x00/0x04/0x08/0x0C    if ((address & 0x13) == 0x10)        address &= ~0x10;    return ppu->palette[address];}// Paletas alternativas em formato ARGB (0xAARRGGBB)// Paleta NTSC (padrão)static const uint32_t NES_PALETTE_NTSC[64] = {    0xFF7C7C7C, 0xFF0000FC, 0xFF0000BC, 0xFF4428BC, 0xFF940084, 0xFFA80020, 0xFFA81000, 0xFF881400,    0xFF503000, 0xFF007800, 0xFF006800, 0xFF005800, 0xFF004058, 0xFF000000, 0xFF000000, 0xFF000000,    0xFFBCBCBC, 0xFF0078F8, 0xFF0058F8, 0xFF6844FC, 0xFFD800CC, 0xFFE40058, 0xFFF83800, 0xFFE45C10,    0xFFAC7C00, 0xFF00B800, 0xFF00A800, 0xFF00A844, 0xFF008888, 0xFF000000, 0xFF000000, 0xFF000000,    0xFFF8F8F8, 0xFF3CBCFC, 0xFF6888FC, 0xFF9878F8, 0xFFF878F8, 0xFFF85898, 0xFFF87858, 0xFFFC9838,    0xFFF8B800, 0xFFB8F818, 0xFF58D854, 0xFF58F898, 0xFF00E8D8, 0xFF787878, 0xFF000000, 0xFF000000,    0xFFFCFCFC, 0xFFA4E4FC, 0xFFB8B8F8, 0xFFD8B8F8, 0xFFF8B8F8, 0xFFF8A4C0, 0xFFF0D0B0, 0xFFFCE0A8,    0xFFF8D878, 0xFFD8F878, 0xFFB8F8B8, 0xFFB8F8D8, 0xFF00FCFC, 0xFFF8F8F8, 0xFF000000, 0xFF000000};// Paleta PAL (Europa)static const uint32_t NES_PALETTE_PAL[64] = {    0xFF7C7C7C, 0xFF0000F8, 0xFF0000A8, 0xFF4428D8, 0xFF8C0094, 0xFFA80048, 0xFFA80020, 0xFF881000,    0xFF503000, 0xFF007800, 0xFF006800, 0xFF005800, 0xFF004058, 0xFF000000, 0xFF000000, 0xFF000000,    0xFFBCBCBC, 0xFF0078F8, 0xFF0058F8, 0xFF6844FC, 0xFFDC00D8, 0xFFE40058, 0xFFF83800, 0xFFE45C10,    0xFFAC7C00, 0xFF00B800, 0xFF00A800, 0xFF00A848, 0xFF008894, 0xFF000000, 0xFF000000, 0xFF000000,    0xFFF8F8F8, 0xFF38C0F8, 0xFF6888FC, 0xFF9878F8, 0xFFF878F8, 0xFFF85898, 0xFFF87858, 0xFFFCA044,    0xFFF8B800, 0xFFB8F818, 0xFF58D858, 0xFF58F89C, 0xFF00E8D8, 0xFF787878, 0xFF000000, 0xFF000000,    0xFFFCFCFC, 0xFFA4E4F8, 0xFFB8B8F8, 0xFFD8B8F8, 0xFFF8B8F8, 0xFFF8A4C0, 0xFFF0D0B0, 0xFFFCE0A8,    0xFFF8D878, 0xFFD8F878, 0xFFB8F8B8, 0xFFB8F8D8, 0xFF00FCFC, 0xFFF8F8F8, 0xFF000000, 0xFF000000};// Paleta Dendy (clone russo do NES)static const uint32_t NES_PALETTE_DENDY[64] = {    0xFF7C7C7C, 0xFF0000F0, 0xFF0000CC, 0xFF404CC0, 0xFF8000B0, 0xFFA000A0, 0xFFA00028, 0xFF880010,    0xFF503000, 0xFF007800, 0xFF006800, 0xFF005800, 0xFF004058, 0xFF000000, 0xFF000000, 0xFF000000,    0xFFBCBCBC, 0xFF0070F0, 0xFF0050F0, 0xFF6844FC, 0xFFD800CC, 0xFFE40058, 0xFFF83800, 0xFFE45C10,    0xFFAC7C00, 0xFF00B800, 0xFF00A800, 0xFF00A844, 0xFF008888, 0xFF000000, 0xFF000000, 0xFF000000,    0xFFF8F8F8, 0xFF3CBCFC, 0xFF6888FC, 0xFF9878F8, 0xFFF878F8, 0xFFF85898, 0xFFF87858, 0xFFFC9838,    0xFFF8B800, 0xFFB8F818, 0xFF58D854, 0xFF58F898, 0xFF00E8D8, 0xFF787878, 0xFF000000, 0xFF000000,    0xFFFCFCFC, 0xFFA4E4FC, 0xFFB8B8F8, 0xFFD8B8F8, 0xFFF8B8F8, 0xFFF8A4C0, 0xFFF0D0B0, 0xFFFCE0A8,    0xFFF8D878, 0xFFD8F878, 0xFFB8F8B8, 0xFFB8F8D8, 0xFF00FCFC, 0xFFF8F8F8, 0xFF000000, 0xFF000000};// Array de ponteiros para as paletasstatic const uint32_t* TV_SYSTEM_PALETTES[3] = {    NES_PALETTE_NTSC,    NES_PALETTE_PAL,    NES_PALETTE_DENDY};/** * @brief Define o sistema de TV (NTSC, PAL, Dendy) para o PPU * * @param ppu Ponteiro para a PPU * @param system Sistema de TV desejado */void nes_ppu_set_tv_system(nes_ppu_t *ppu, nes_tv_system_t system){    if (!ppu)    {        PPU_LOG_ERROR("nes_ppu_set_tv_system: PPU é NULL");        return;    }
ppu->tv_system = system;
// Atualiza paleta de cores    nes_ppu_load_palette_set(ppu, (uint8_t)system);
PPU_LOG_INFO("Sistema de TV alterado para %s",
             system == NES_TV_NTSC ? "NTSC" : system == NES_TV_PAL ? "PAL"
                                                                   : "Dendy");
} /** * @brief Configura as opções de overscan (recorte da imagem nas bordas) * * @param ppu Ponteiro para a PPU * @param overscan Configurações de overscan */
void nes_ppu_set_overscan(nes_ppu_t *ppu, nes_overscan_t overscan)
{
    if (!ppu)
    {
        PPU_LOG_ERROR("nes_ppu_set_overscan: PPU é NULL");
        return;
    }
    ppu->overscan = overscan;
    PPU_LOG_INFO("Overscan configurado: %s (T:%d, B:%d, L:%d, R:%d)",
                 overscan.enabled ? "ativado" : "desativado",
                 overscan.top, overscan.bottom, overscan.left, overscan.right);
} /** * @brief Configuração para scrolling split (mudança de scroll em determinada scanline) * Útil para implementar HUDs em jogos * * @param ppu Ponteiro para a PPU * @param config Configuração do scrolling split */
void nes_ppu_configure_split_scroll(nes_ppu_t *ppu, nes_split_scroll_t config)
{
    if (!ppu)
    {
        PPU_LOG_ERROR("nes_ppu_configure_split_scroll: PPU é NULL");
        return;
    }
    ppu->split_scroll = config;
    PPU_LOG_INFO("Scrolling split configurado: %s (scanline: %d, direction: %d)",
                 config.enabled ? "ativado" : "desativado",
                 config.scanline, config.direction);
} /** * @brief Carrega um conjunto de paleta de cores * * @param ppu Ponteiro para a PPU * @param palette_set Conjunto de paleta (0=NTSC, 1=PAL, 2=Dendy) */
void nes_ppu_load_palette_set(nes_ppu_t *ppu, uint8_t palette_set)
{
    if (!ppu)
    {
        PPU_LOG_ERROR("nes_ppu_load_palette_set: PPU é NULL");
        return;
    }
    if (palette_set > 2)
    {
        PPU_LOG_ERROR("nes_ppu_load_palette_set: conjunto de paleta inválido: %d", palette_set);
        palette_set = 0; // Fallback para NTSC    }
        ppu->current_palette_set = palette_set;
        ppu->palettes_data = (uint32_t *)TV_SYSTEM_PALETTES[palette_set];
        const char *names[] = {"NTSC", "PAL", "Dendy"};
        PPU_LOG_INFO("Conjunto de paleta carregado: %s", names[palette_set]);
    } /** * @brief Configura os efeitos de distorção de CRT * * @param ppu Ponteiro para a PPU * @param enable Habilitar/desabilitar distorção * @param amount Intensidade da distorção (0.0 a 1.0) */
    void nes_ppu_set_distortion(nes_ppu_t * ppu, bool enable, float amount)
    {
        if (!ppu)
        {
            PPU_LOG_ERROR("nes_ppu_set_distortion: PPU é NULL");
            return;
        }
        ppu->enable_distortion = enable;
        ppu->distortion_amount = amount;
        // Gera tabela de distorção    if (enable && !ppu->distortion_table)    {        ppu->distortion_table = (uint8_t*)malloc(NES_SCREEN_HEIGHT);        if (ppu->distortion_table)        {            for (int i = 0; i < NES_SCREEN_HEIGHT; i++)            {                // Calcula distorção por scanline baseado na posição e intensidade                float center = NES_SCREEN_HEIGHT / 2.0f;                float distance = (i - center) / center;                float distortion = amount * (distance * distance) * 4.0f;                ppu->distortion_table[i] = (uint8_t)(distortion * 10);            }        }    }    else if (!enable && ppu->distortion_table)    {        free(ppu->distortion_table);        ppu->distortion_table = NULL;    }
        PPU_LOG_INFO("Efeitos de distorção: %s (intensidade: %.2f)",
                     enable ? "ativados" : "desativados", amount);
    } /** * @brief Atualização da função de renderização para suportar recursos avançados * * @param ppu Ponteiro para a PPU * @param frame_buffer Buffer para receber a imagem renderizada */
    void nes_ppu_render_frame(nes_ppu_t * ppu, uint32_t *frame_buffer)
    {
        if (!ppu || !frame_buffer)
        {
            PPU_LOG_ERROR("Parâmetros inválidos em nes_ppu_render_frame");
            return;
        }
        PPU_LOG_DEBUG("Iniciando renderização do frame");
        // Limpa o buffer antes de renderizar    memset(frame_buffer, 0, NES_SCREEN_WIDTH * NES_SCREEN_HEIGHT * sizeof(uint32_t));
        // Verifica se a renderização está habilitada    if (!(ppu->reg_mask & NES_PPUMASK_SHOW_BACKGROUND) &&        !(ppu->reg_mask & NES_PPUMASK_SHOW_SPRITES))    {        PPU_LOG_WARN("Renderização desabilitada - pulando frame");        return;    }
        // Salva o estado atual dos registradores para restaurar mais tarde    uint16_t original_vram_addr = ppu->reg_vram_addr;    uint8_t original_fine_x = ppu->fine_x;
        // Renderiza background se habilitado    if (ppu->reg_mask & NES_PPUMASK_SHOW_BACKGROUND)    {        render_background(ppu, frame_buffer);    }
        // Se o scrolling split estiver habilitado, precisamos renderizar o background novamente    // para a parte inferior da tela    if (ppu->split_scroll.enabled && ppu->split_scroll.scanline > 0 &&
    ppu->split_scroll.scanline < NES_SCREEN_HEIGHT)
    { // Salva os registradores originais        uint16_t temp_vram_addr = ppu->reg_vram_addr;        uint8_t temp_fine_x = ppu->fine_x;
        // Configura os registradores para o scrolling split        ppu->reg_vram_addr = ppu->split_scroll.reg_vram_addr;        ppu->fine_x = ppu->split_scroll.fine_x;
        // Renderiza o background apenas para as scanlines abaixo do split        for (int y = ppu->split_scroll.scanline; y < NES_SCREEN_HEIGHT; y++)        {            for (int x = 0; x < NES_SCREEN_WIDTH; x++)            {                // Implementação simplificada - na implementação completa seria necessário                // renderizar tile por tile com os registradores alterados                // Aqui apenas indicamos a área de split para visualização                    if (ppu->split_scroll.direction == 0) // Horizontal                    {                        frame_buffer[y * NES_SCREEN_WIDTH + x] = NES_PALETTE_NTSC[0x3F & 0x30]; // Cor branca                    }            }        }
        // Restaura os registradores originais        ppu->reg_vram_addr = temp_vram_addr;        ppu->fine_x = temp_fine_x;    }
        // Renderiza sprites se habilitado    if (ppu->reg_mask & NES_PPUMASK_SHOW_SPRITES)    {        render_sprites(ppu, frame_buffer);    }
        // Aplica efeitos de distorção se habilitados    if (ppu->enable_distortion && ppu->distortion_table)    {        // Temporário para salvar linha        uint32_t *temp_line = (uint32_t*)malloc(NES_SCREEN_WIDTH * sizeof(uint32_t));        if (temp_line)        {            for (int y = 0; y < NES_SCREEN_HEIGHT; y++)            {                // Copia linha original                memcpy(temp_line, &frame_buffer[y * NES_SCREEN_WIDTH], NES_SCREEN_WIDTH * sizeof(uint32_t));
        // Aplica distorção horizontal baseada na tabela                uint8_t distortion = ppu->distortion_table[y];                if (distortion > 0)                {                    for (int x = 0; x < NES_SCREEN_WIDTH; x++)                    {                        // Calcula nova posição distorcida                        float center = NES_SCREEN_WIDTH / 2.0f;                        float distance = (x - center) / center;                        float distort = distance * distortion / 10.0f;                        int new_x = (int)(x + distort);
        // Se a posição é válida, copia o pixel                        if (new_x >= 0 && new_x < NES_SCREEN_WIDTH)                        {                            frame_buffer[y * NES_SCREEN_WIDTH + x] = temp_line[new_x];                        }                    }                }            }            free(temp_line);        }    }
        // Aplica overscan se habilitado    if (ppu->overscan.enabled)    {        // Borda superior        for (int y = 0; y < ppu->overscan.top; y++)        {            for (int x = 0; x < NES_SCREEN_WIDTH; x++)            {                frame_buffer[y * NES_SCREEN_WIDTH + x] = 0xFF000000; // Preto            }        }
        // Borda inferior        for (int y = NES_SCREEN_HEIGHT - ppu->overscan.bottom; y < NES_SCREEN_HEIGHT; y++)        {            for (int x = 0; x < NES_SCREEN_WIDTH; x++)            {                frame_buffer[y * NES_SCREEN_WIDTH + x] = 0xFF000000; // Preto            }        }
        // Borda esquerda        for (int y = 0; y < NES_SCREEN_HEIGHT; y++)        {            for (int x = 0; x < ppu->overscan.left; x++)            {                frame_buffer[y * NES_SCREEN_WIDTH + x] = 0xFF000000; // Preto            }        }
        // Borda direita        for (int y = 0; y < NES_SCREEN_HEIGHT; y++)        {            for (int x = NES_SCREEN_WIDTH - ppu->overscan.right; x < NES_SCREEN_WIDTH; x++)            {                frame_buffer[y * NES_SCREEN_WIDTH + x] = 0xFF000000; // Preto            }        }    }
        // Aplica máscara de cores    apply_color_mask(ppu);
        // Restaura o estado original dos registradores    ppu->reg_vram_addr = original_vram_addr;    ppu->fine_x = original_fine_x;
        PPU_LOG_DEBUG("Frame renderizado com sucesso");
    }
