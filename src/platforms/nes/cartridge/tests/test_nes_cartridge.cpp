/** * @file test_nes_cartridge.cpp * @brief Testes para a classe NESCartridge e seus mappers * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-14 */ #include<unity.h> #include "../nes_cartridge.hpp" #include<iostream> #include<iomanip> #include<vector> #include<string> #include<memory> #include<cassert> #include<cstring> #include<fstream> using namespace MegaEmu::Platforms::NES; // Macros para facilitar testes#define PRINT_TEST(name) std::cout << "\n=== TESTE: " << name << " ===" << std::endl#define PRINT_SUCCESS(msg) std::cout << "✓ SUCESSO: " << msg << std::endl#define PRINT_ERROR(msg) std::cout << "✗ ERRO: " << msg << std::endl#define PRINT_INFO(msg) std::cout << "ℹ INFO: " << msg << std::endl// Dados de ROM fictícia para testes// Cabeçalho iNESconst uint8_t MOCK_INES_HEADER[] = {    'N', 'E', 'S', 0x1A,                           // Magic    0x02,                                          // 2 banks de PRG-ROM (32KB)    0x01,                                          // 1 bank de CHR-ROM (8KB)    0x01,                                          // Vertical mirroring, sem bateria    0x00,                                          // Mapper 0 (NROM)    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // Padding};// Funções de utilidade para testes/** * @brief Cria um arquivo de ROM do NES para testes * @param filename Nome do arquivo * @param mapper Número do mapper * @param prgRomBanks Número de bancos PRG-ROM (16KB cada) * @param chrRomBanks Número de bancos CHR-ROM (8KB cada) * @param verticalMirroring true para espelhamento vertical, false para horizontal * @param battery true se tiver bateria (SRAM persistente) * @return true se o arquivo foi criado com sucesso */bool createMockROM(const std::string &filename, int mapper, int prgRomBanks, int chrRomBanks,                   bool verticalMirroring, bool battery){    try    {        std::ofstream file(filename, std::ios::binary);        if (!file)        {            PRINT_ERROR("Não foi possível criar o arquivo " + filename);            return false;        }        // Criar cabeçalho iNES        uint8_t header[16];        memcpy(header, MOCK_INES_HEADER, 16);        // Configurar flags        header[4] = prgRomBanks; // PRG-ROM banks        header[5] = chrRomBanks; // CHR-ROM banks        uint8_t flags6 = 0;        if (verticalMirroring)            flags6 |= 0x01;        if (battery)            flags6 |= 0x02;        flags6 |= ((mapper & 0x0F) << 4); // Mapper low bits        header[6] = flags6;        uint8_t flags7 = (mapper & 0xF0); // Mapper high bits        header[7] = flags7;        // Escrever cabeçalho        file.write(reinterpret_cast<const char *>(header), 16);        // Criar PRG-ROM com dados de teste        std::vector<uint8_t> prgRom(prgRomBanks * 16384, 0);        // Preencher com padrão reconhecível para testes        for (int bank = 0; bank < prgRomBanks; bank++)        {            for (int i = 0; i < 16384; i++)            {                prgRom[bank * 16384 + i] = static_cast<uint8_t>((bank * 16 + i) & 0xFF);            }        }        // Escrever PRG-ROM        file.write(reinterpret_cast<const char *>(prgRom.data()), prgRom.size());        // Criar CHR-ROM com dados de teste        std::vector<uint8_t> chrRom(chrRomBanks * 8192, 0);        // Preencher com padrão reconhecível para testes        for (int bank = 0; bank < chrRomBanks; bank++)        {            for (int i = 0; i < 8192; i++)            {                chrRom[bank * 8192 + i] = static_cast<uint8_t>((bank * 32 + i) & 0xFF);            }        }        // Escrever CHR-ROM        file.write(reinterpret_cast<const char *>(chrRom.data()), chrRom.size());        file.close();        PRINT_INFO("ROM criada: " + filename);        PRINT_INFO("PRG-ROM: " + std::to_string(prgRomBanks) + " bancos (" +                   std::to_string(prgRomBanks * 16) + "KB)");        PRINT_INFO("CHR-ROM: " + std::to_string(chrRomBanks) + " bancos (" +                   std::to_string(chrRomBanks * 8) + "KB)");        PRINT_INFO("Mapper: " + std::to_string(mapper));        PRINT_INFO("Mirroring: " + std::string(verticalMirroring ? "Vertical" : "Horizontal"));        PRINT_INFO("Battery: " + std::string(battery ? "Sim" : "Não"));        return true;    }    catch (const std::exception &e)    {        PRINT_ERROR(std::string("Exceção ao criar ROM: ") + e.what());        return false;    }}// Variáveis globais para testesNESCartridge* cart = nullptr;void setUp(void) {    cart = new NESCartridge();}void tearDown(void) {    delete cart;    cart = nullptr;}void test_load_nrom(void) {    // Criar ROM de teste    TEST_ASSERT_TRUE(createMockROM("test_nrom.nes", 0, 2, 1, true, false));    // Carregar ROM    TEST_ASSERT_TRUE(cart->loadROM("test_nrom.nes"));    // Verificar informações    ROMInfo info = cart->getInfo();     // Verificar número do mapper    TEST_ASSERT_EQUAL_INT(0, info.mapperNumber);     // Verificar tamanho da PRG-ROM    TEST_ASSERT_EQUAL_INT(2 * 16384, info.prgRomSize);     // Verificar tamanho da CHR-ROM    TEST_ASSERT_EQUAL_INT(1 * 8192, info.chrRomSize);     // Verificar modo de espelhamento    TEST_ASSERT_EQUAL_INT(MirrorMode::VERTICAL, cart->getMirrorMode());    // Verificar leitura de PRG-ROM    for (int i = 0; i < 10; i++)    {        uint16_t address = 0x8000 + i;        uint8_t expected = static_cast<uint8_t>(i & 0xFF);        TEST_ASSERT_EQUAL_UINT8(expected, cart->cpuRead(address));    }    // Verificar leitura de CHR-ROM    for (int i = 0; i < 10; i++)    {        uint16_t address = i;        uint8_t expected = static_cast<uint8_t>(i & 0xFF);        TEST_ASSERT_EQUAL_UINT8(expected, cart->chrRead(address));    }}void test_load_mmc1(void) {    // Criar ROM de teste    TEST_ASSERT_TRUE(createMockROM("test_mmc1.nes", 1, 4, 2, false, true));    // Carregar ROM    TEST_ASSERT_TRUE(cart->loadROM("test_mmc1.nes"));    // Verificar informações    ROMInfo info = cart->getInfo();     // Verificar número do mapper    TEST_ASSERT_EQUAL_INT(1, info.mapperNumber);     // Verificar tamanho da PRG-ROM    TEST_ASSERT_EQUAL_INT(4 * 16384, info.prgRomSize);     // Verificar tamanho da CHR-ROM    TEST_ASSERT_EQUAL_INT(2 * 8192, info.chrRomSize);     // Verificar modo de espelhamento    TEST_ASSERT_EQUAL_INT(MirrorMode::HORIZONTAL, cart->getMirrorMode());    // Verificar leitura de PRG-ROM    for (int i = 0; i < 10; i++)    {        uint16_t address = 0x8000 + i;        uint8_t expected = static_cast<uint8_t>(i & 0xFF);        TEST_ASSERT_EQUAL_UINT8(expected, cart->cpuRead(address));    }    // Verificar leitura de CHR-ROM    for (int i = 0; i < 10; i++)    {        uint16_t address = i;        uint8_t expected = static_cast<uint8_t>(i & 0xFF);        TEST_ASSERT_EQUAL_UINT8(expected, cart->chrRead(address));    }    // Teste de escrita para o registro 0x8000 do MMC1 (Control)    cart->cpuWrite(0x8000, 0x00); // bit 0 = 0    cart->cpuWrite(0x8000, 0x00); // bit 0 = 0    cart->cpuWrite(0x8000, 0x00); // bit 0 = 0    cart->cpuWrite(0x8000, 0x00); // bit 0 = 0    cart->cpuWrite(0x8000, 0x01); // bit 0 = 1 (Modo de espelhamento vertical)    // Verificar se o modo de espelhamento mudou para vertical    TEST_ASSERT_EQUAL_INT(MirrorMode::VERTICAL, cart->getMirrorMode());}int main(void) {    UNITY_BEGIN();    RUN_TEST(test_load_nrom);    RUN_TEST(test_load_mmc1);    return UNITY_END();}
