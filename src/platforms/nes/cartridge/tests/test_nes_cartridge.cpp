/** * @file test_nes_cartridge.cpp * @brief Testes para a classe NESCartridge e seus mappers * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-14 */#include "../nes_cartridge.hpp"#include <iostream>#include <iomanip>#include <vector>#include <string>#include <memory>#include <cassert>#include <cstring>#include <fstream>using namespace MegaEmu::Platforms::NES;// Macros para facilitar testes#define PRINT_TEST(name) std::cout << "\n=== TESTE: " << name << " ===" << std::endl#define PRINT_SUCCESS(msg) std::cout << "✓ SUCESSO: " << msg << std::endl#define PRINT_ERROR(msg) std::cout << "✗ ERRO: " << msg << std::endl#define PRINT_INFO(msg) std::cout << "ℹ INFO: " << msg << std::endl// Dados de ROM fictícia para testes// Cabeçalho iNESconst uint8_t MOCK_INES_HEADER[] = {    'N', 'E', 'S', 0x1A,                           // Magic    0x02,                                          // 2 banks de PRG-ROM (32KB)    0x01,                                          // 1 bank de CHR-ROM (8KB)    0x01,                                          // Vertical mirroring, sem bateria    0x00,                                          // Mapper 0 (NROM)    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // Padding};// Funções de utilidade para testes/** * @brief Cria um arquivo de ROM do NES para testes * @param filename Nome do arquivo * @param mapper Número do mapper * @param prgRomBanks Número de bancos PRG-ROM (16KB cada) * @param chrRomBanks Número de bancos CHR-ROM (8KB cada) * @param verticalMirroring true para espelhamento vertical, false para horizontal * @param battery true se tiver bateria (SRAM persistente) * @return true se o arquivo foi criado com sucesso */bool createMockROM(const std::string &filename, int mapper, int prgRomBanks, int chrRomBanks,                   bool verticalMirroring, bool battery){    try    {        std::ofstream file(filename, std::ios::binary);        if (!file)        {            PRINT_ERROR("Não foi possível criar o arquivo " + filename);            return false;        }        // Criar cabeçalho iNES        uint8_t header[16];        memcpy(header, MOCK_INES_HEADER, 16);        // Configurar flags        header[4] = prgRomBanks; // PRG-ROM banks        header[5] = chrRomBanks; // CHR-ROM banks        uint8_t flags6 = 0;        if (verticalMirroring)            flags6 |= 0x01;        if (battery)            flags6 |= 0x02;        flags6 |= ((mapper & 0x0F) << 4); // Mapper low bits        header[6] = flags6;        uint8_t flags7 = (mapper & 0xF0); // Mapper high bits        header[7] = flags7;        // Escrever cabeçalho        file.write(reinterpret_cast<const char *>(header), 16);        // Criar PRG-ROM com dados de teste        std::vector<uint8_t> prgRom(prgRomBanks * 16384, 0);        // Preencher com padrão reconhecível para testes        for (int bank = 0; bank < prgRomBanks; bank++)        {            for (int i = 0; i < 16384; i++)            {                prgRom[bank * 16384 + i] = static_cast<uint8_t>((bank * 16 + i) & 0xFF);            }        }        // Escrever PRG-ROM        file.write(reinterpret_cast<const char *>(prgRom.data()), prgRom.size());        // Criar CHR-ROM com dados de teste        std::vector<uint8_t> chrRom(chrRomBanks * 8192, 0);        // Preencher com padrão reconhecível para testes        for (int bank = 0; bank < chrRomBanks; bank++)        {            for (int i = 0; i < 8192; i++)            {                chrRom[bank * 8192 + i] = static_cast<uint8_t>((bank * 32 + i) & 0xFF);            }        }        // Escrever CHR-ROM        file.write(reinterpret_cast<const char *>(chrRom.data()), chrRom.size());        file.close();        PRINT_INFO("ROM criada: " + filename);        PRINT_INFO("PRG-ROM: " + std::to_string(prgRomBanks) + " bancos (" +                   std::to_string(prgRomBanks * 16) + "KB)");        PRINT_INFO("CHR-ROM: " + std::to_string(chrRomBanks) + " bancos (" +                   std::to_string(chrRomBanks * 8) + "KB)");        PRINT_INFO("Mapper: " + std::to_string(mapper));        PRINT_INFO("Mirroring: " + std::string(verticalMirroring ? "Vertical" : "Horizontal"));        PRINT_INFO("Battery: " + std::string(battery ? "Sim" : "Não"));        return true;    }    catch (const std::exception &e)    {        PRINT_ERROR(std::string("Exceção ao criar ROM: ") + e.what());        return false;    }}/** * @brief Testa o carregamento de uma ROM NROM * @return true se o teste passou */bool test_load_nrom(){    PRINT_TEST("Carregamento de ROM NROM (Mapper 0)");    // Criar ROM de teste    if (!createMockROM("test_nrom.nes", 0, 2, 1, true, false))    {        return false;    }    try    {        // Criar cartridge        NESCartridge cart;        // Carregar ROM        if (!cart.loadROM("test_nrom.nes"))        {            PRINT_ERROR("Falha ao carregar ROM");            return false;        }        // Verificar informações        ROMInfo info = cart.getInfo();        // Verificar número do mapper        if (info.mapperNumber != 0)        {            PRINT_ERROR("Número do mapper incorreto: esperado 0, obtido " +                        std::to_string(info.mapperNumber));            return false;        }        // Verificar tamanho da PRG-ROM        if (info.prgRomSize != 2 * 16384)        {            PRINT_ERROR("Tamanho da PRG-ROM incorreto: esperado " +                        std::to_string(2 * 16384) + ", obtido " +                        std::to_string(info.prgRomSize));            return false;        }        // Verificar tamanho da CHR-ROM        if (info.chrRomSize != 1 * 8192)        {            PRINT_ERROR("Tamanho da CHR-ROM incorreto: esperado " +                        std::to_string(1 * 8192) + ", obtido " +                        std::to_string(info.chrRomSize));            return false;        }        // Verificar modo de espelhamento        if (cart.getMirrorMode() != MirrorMode::VERTICAL)        {            PRINT_ERROR("Modo de espelhamento incorreto: esperado VERTICAL");            return false;        }        // Verificar leitura de PRG-ROM        for (int i = 0; i < 10; i++)        {            uint16_t address = 0x8000 + i;            uint8_t expected = static_cast<uint8_t>(i & 0xFF);            uint8_t value = cart.cpuRead(address);            if (value != expected)            {                PRINT_ERROR("Leitura de PRG-ROM incorreta no endereço 0x" +                            std::to_string(address) + ": esperado 0x" +                            std::to_string(expected) + ", obtido 0x" +                            std::to_string(value));                return false;            }        }        // Verificar leitura de CHR-ROM        for (int i = 0; i < 10; i++)        {            uint16_t address = i;            uint8_t expected = static_cast<uint8_t>(i & 0xFF);            uint8_t value = cart.chrRead(address);            if (value != expected)            {                PRINT_ERROR("Leitura de CHR-ROM incorreta no endereço 0x" +                            std::to_string(address) + ": esperado 0x" +                            std::to_string(expected) + ", obtido 0x" +                            std::to_string(value));                return false;            }        }        PRINT_SUCCESS("Carregamento e leitura de ROM NROM bem-sucedidos");        return true;    }    catch (const std::exception &e)    {        PRINT_ERROR(std::string("Exceção durante o teste: ") + e.what());        return false;    }}/** * @brief Testa o carregamento de uma ROM MMC1 * @return true se o teste passou */bool test_load_mmc1(){    PRINT_TEST("Carregamento de ROM MMC1 (Mapper 1)");    // Criar ROM de teste    if (!createMockROM("test_mmc1.nes", 1, 4, 2, false, true))    {        return false;    }    try    {        // Criar cartridge        NESCartridge cart;        // Carregar ROM        if (!cart.loadROM("test_mmc1.nes"))        {            PRINT_ERROR("Falha ao carregar ROM");            return false;        }        // Verificar informações        ROMInfo info = cart.getInfo();        // Verificar número do mapper        if (info.mapperNumber != 1)        {            PRINT_ERROR("Número do mapper incorreto: esperado 1, obtido " +                        std::to_string(info.mapperNumber));            return false;        }        // Verificar tamanho da PRG-ROM        if (info.prgRomSize != 4 * 16384)        {            PRINT_ERROR("Tamanho da PRG-ROM incorreto: esperado " +                        std::to_string(4 * 16384) + ", obtido " +                        std::to_string(info.prgRomSize));            return false;        }        // Verificar tamanho da CHR-ROM        if (info.chrRomSize != 2 * 8192)        {            PRINT_ERROR("Tamanho da CHR-ROM incorreto: esperado " +                        std::to_string(2 * 8192) + ", obtido " +                        std::to_string(info.chrRomSize));            return false;        }        // Verificar modo de espelhamento        if (cart.getMirrorMode() != MirrorMode::HORIZONTAL)        {            PRINT_ERROR("Modo de espelhamento incorreto: esperado HORIZONTAL");            return false;        }        // Verificar leitura de PRG-ROM        for (int i = 0; i < 10; i++)        {            uint16_t address = 0x8000 + i;            uint8_t expected = static_cast<uint8_t>(i & 0xFF);            uint8_t value = cart.cpuRead(address);            if (value != expected)            {                PRINT_ERROR("Leitura de PRG-ROM incorreta no endereço 0x" +                            std::to_string(address) + ": esperado 0x" +                            std::to_string(expected) + ", obtido 0x" +                            std::to_string(value));                return false;            }        }        // Verificar leitura de CHR-ROM        for (int i = 0; i < 10; i++)        {            uint16_t address = i;            uint8_t expected = static_cast<uint8_t>(i & 0xFF);            uint8_t value = cart.chrRead(address);            if (value != expected)            {                PRINT_ERROR("Leitura de CHR-ROM incorreta no endereço 0x" +                            std::to_string(address) + ": esperado 0x" +                            std::to_string(expected) + ", obtido 0x" +                            std::to_string(value));                return false;            }        }        // Teste de escrita para o registro 0x8000 do MMC1 (Control)        // 10000 - Primeiro bit (lsb) do valor para ser deslocado no shift register        cart.cpuWrite(0x8000, 0x00); // bit 0 = 0        // 01000 - Segundo bit        cart.cpuWrite(0x8000, 0x00); // bit 0 = 0        // 00100 - Terceiro bit        cart.cpuWrite(0x8000, 0x00); // bit 0 = 0        // 00010 - Quarto bit        cart.cpuWrite(0x8000, 0x00); // bit 0 = 0        // 00001 - Quinto bit e completa o registro        cart.cpuWrite(0x8000, 0x01); // bit 0 = 1 (Modo de espelhamento vertical)        // Agora o modo de espelhamento deve ser vertical (0x01)        if (cart.getMirrorMode() != MirrorMode::VERTICAL)        {            PRINT_ERROR("Falha ao mudar o modo de espelhamento via registro");            return false;        }        PRINT_SUCCESS("Carregamento e leitura de ROM MMC1 bem-sucedidos");        return true;    }    catch (const std::exception &e)    {        PRINT_ERROR(std::string("Exceção durante o teste: ") + e.what());        return false;    }}/** * @brief Função principal para executar todos os testes * @return 0 se todos os testes passaram, 1 caso contrário */int main(){    int tests_passed = 0;    int tests_failed = 0;    std::cout << "=== TESTES DE CARTRIDGE NES ===" << std::endl;    // Testar carregamento NROM    if (test_load_nrom())    {        tests_passed++;    }    else    {        tests_failed++;    }    // Testar carregamento MMC1    if (test_load_mmc1())    {        tests_passed++;    }    else    {        tests_failed++;    }    // Resultados    std::cout << "\n=== RESULTADOS ===" << std::endl;    std::cout << "Testes executados: " << (tests_passed + tests_failed) << std::endl;    std::cout << "Testes bem-sucedidos: " << tests_passed << std::endl;    std::cout << "Testes falhos: " << tests_failed << std::endl;    if (tests_failed == 0)    {        PRINT_SUCCESS("Todos os testes passaram!");        return 0;    }    else    {        PRINT_ERROR("Alguns testes falharam!");        return 1;    }}