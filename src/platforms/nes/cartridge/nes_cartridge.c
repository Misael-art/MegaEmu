/** * @file nes_cartridge.c * @brief Implementação do subsistema de cartuchos do NES */#include "nes_cartridge.h"#include "utils/enhanced_log.h"#include <stdlib.h>#include <string.h>#include <stdio.h>#include "../ppu/nes_ppu.h"#include "../nes.h"// Definição de PATH_MAX para Windows#ifndef PATH_MAX#define PATH_MAX 260#endif// Definição da categoria de log para a plataforma NES (necessário para as macros de log)#define EMU_LOG_CAT_PLATFORM EMU_LOG_CAT_NES// Definição da categoria de log para o cartucho#define EMU_LOG_CAT_CARTRIDGE NES_LOG_CAT_CARTRIDGE// Macros de log específicas para o cartucho#define CART_LOG_ERROR(...) EMU_LOG_ERROR(EMU_LOG_CAT_CARTRIDGE, __VA_ARGS__)#define CART_LOG_WARN(...) EMU_LOG_WARN(EMU_LOG_CAT_CARTRIDGE, __VA_ARGS__)#define CART_LOG_INFO(...) EMU_LOG_INFO(EMU_LOG_CAT_CARTRIDGE, __VA_ARGS__)#define CART_LOG_DEBUG(...) EMU_LOG_DEBUG(EMU_LOG_CAT_CARTRIDGE, __VA_ARGS__)#define CART_LOG_TRACE(...) EMU_LOG_TRACE(EMU_LOG_CAT_CARTRIDGE, __VA_ARGS__)// Tamanho do buffer para nomes de arquivos#define PATH_BUFFER_SIZE 512// Forward declarations para implementações de mappersstatic int nes_mapper_0_init(nes_cartridge_t *cart);static int mapper_mmc1_init(nes_cartridge_t *cartridge);// Estrutura para guardar o cabeçalho iNEStypedef struct{    char magic[4];        // 'N', 'E', 'S', '\x1A'    uint8_t prg_rom_size; // Tamanho da PRG-ROM em unidades de 16KB    uint8_t chr_rom_size; // Tamanho da CHR-ROM em unidades de 8KB    uint8_t flags6;       // Byte de flags 6    uint8_t flags7;       // Byte de flags 7    uint8_t flags8;       // Byte de flags 8 (tamanho da PRG-RAM)    uint8_t flags9;       // Byte de flags 9    uint8_t flags10;      // Byte de flags 10    uint8_t padding[5];   // Padding para completar 16 bytes} nes_ines_header_t;// Estruturas específicas para mapperstypedef struct{    nes_cartridge_t *cart;    // Mapper 0 (NROM) não precisa de estado adicional} mapper0_t;typedef struct{    nes_cartridge_t *cart;    uint8_t shift_register;    uint8_t shift_count;    uint8_t control;    uint8_t chr_bank_0;    uint8_t chr_bank_1;    uint8_t prg_bank;    uint64_t last_write_cycle; // Para ignorar writes muito próximos} mapper1_t;typedef struct{    nes_cartridge_t *cart;    uint8_t prg_bank;} mapper2_t;typedef struct{    nes_cartridge_t *cart;    uint8_t bank_select;} mapper3_t;typedef struct{    nes_cartridge_t *cart;    uint8_t bank_select;    uint8_t bank_data[8];    uint8_t irq_latch;    uint8_t irq_counter;    uint8_t irq_enabled;    uint8_t irq_reload;    int current_scanline; // Armazena o scanline atual para uso na função scanline    void *cpu;            // Para gerar IRQs} mapper4_t;// Protótipos de funções para os mappers// Mapper 0 (NROM)static uint8_t mapper_0_cpu_read(void *ctx, uint16_t addr);static void mapper_0_cpu_write(void *ctx, uint16_t addr, uint8_t val);static uint8_t mapper_0_chr_read(void *ctx, uint16_t addr);static void mapper_0_chr_write(void *ctx, uint16_t addr, uint8_t val);// Mapper 1 (MMC1)static uint8_t mapper_1_cpu_read(void *ctx, uint16_t addr);static void mapper_1_cpu_write(void *ctx, uint16_t addr, uint8_t val);static uint8_t mapper_1_chr_read(void *ctx, uint16_t addr);static void mapper_1_chr_write(void *ctx, uint16_t addr, uint8_t val);// Mapper 2 (UxROM)static uint8_t mapper_2_cpu_read(void *ctx, uint16_t addr);static void mapper_2_cpu_write(void *ctx, uint16_t addr, uint8_t val);static uint8_t mapper_2_chr_read(void *ctx, uint16_t addr);static void mapper_2_chr_write(void *ctx, uint16_t addr, uint8_t val);// Mapper 4 (MMC3)static uint8_t mapper_4_cpu_read(void *ctx, uint16_t addr);static void mapper_4_cpu_write(void *ctx, uint16_t addr, uint8_t val);static uint8_t mapper_4_chr_read(void *ctx, uint16_t addr);static void mapper_4_chr_write(void *ctx, uint16_t addr, uint8_t val);static void mapper_4_scanline(void *ctx);/** * @brief Inicializa o subsistema de cartucho do NES * * @return nes_cartridge_t* Ponteiro para o cartucho inicializado, ou NULL em caso de erro */nes_cartridge_t *nes_cartridge_init(void){    CART_LOG_INFO("Inicializando subsistema de cartucho do NES");    // Aloca a estrutura principal    nes_cartridge_t *cartridge = (nes_cartridge_t *)malloc(sizeof(nes_cartridge_t));    if (!cartridge)    {        CART_LOG_ERROR("nes_cartridge_init: falha na alocação de memória para o cartucho");        return NULL;    }    // Inicializa a estrutura com zeros    memset(cartridge, 0, sizeof(nes_cartridge_t));    // Inicializa os valores padrão    cartridge->mapper_type = NES_MAPPER_NROM;    cartridge->mapper_number = 0;    cartridge->mirror_mode = NES_MIRROR_HORIZONTAL;    cartridge->prg_rom = NULL;    cartridge->chr_rom = NULL;    cartridge->prg_ram = NULL;    cartridge->chr_ram = NULL;    cartridge->prg_rom_size = 0;    cartridge->chr_rom_size = 0;    cartridge->prg_ram_size = 0;    cartridge->chr_ram_size = 0;    cartridge->has_battery = 0;    cartridge->rom_path = NULL;    cartridge->mapper = NULL;    cartridge->mapper_data = NULL;    cartridge->sram_dirty = 0;    CART_LOG_INFO("Subsistema de cartucho do NES inicializado com sucesso");    return cartridge;}/** * @brief Finaliza e libera recursos do cartucho */void nes_cartridge_shutdown(nes_cartridge_t *cartridge){    if (!cartridge)    {        CART_LOG_WARN("nes_cartridge_shutdown: cartridge já está desligado");        return;    }    CART_LOG_INFO("Desligando subsistema de cartucho do NES");    // Libera a memória ROM/RAM    if (cartridge->prg_rom)    {        free(cartridge->prg_rom);    }    if (cartridge->chr_rom)    {        free(cartridge->chr_rom);    }    if (cartridge->prg_ram)    {        free(cartridge->prg_ram);    }    if (cartridge->chr_ram)    {        free(cartridge->chr_ram);    }    // Libera o caminho da ROM    if (cartridge->rom_path)    {        free(cartridge->rom_path);    }    // Libera o mapper, se existir    if (cartridge->mapper && cartridge->mapper->shutdown)    {        cartridge->mapper->shutdown(cartridge);    }    // Libera a estrutura principal    free(cartridge);}/** * @brief Reseta o cartucho para o estado inicial * * @param cartridge Ponteiro para o cartucho */void nes_cartridge_reset(nes_cartridge_t *cartridge){    if (!cartridge)    {        CART_LOG_ERROR("nes_cartridge_reset: cartridge inválido");        return;    }    CART_LOG_INFO("Resetando subsistema de cartucho do NES");    // Reseta o mapper, se existir    if (cartridge->mapper && cartridge->mapper->reset)    {        cartridge->mapper->reset(cartridge);    }    // A PRG-RAM com bateria não é zerada no reset    // PRG-RAM sem bateria e CHR-RAM podem ou não ser zeradas, dependendo da implementação    CART_LOG_DEBUG("Cartucho resetado: mapper=%d", cartridge->mapper_number);}/** * @brief Carrega uma ROM NES * * @param cartridge Ponteiro para o cartucho * @param rom_path Caminho do arquivo da ROM * @return int 0 em caso de sucesso, código de erro em caso de falha */int nes_cartridge_load(nes_cartridge_t *cartridge, const char *rom_path){    if (!cartridge || !rom_path)    {        CART_LOG_ERROR("nes_cartridge_load: parâmetros inválidos - cartridge=%p, rom_path=%s",                       cartridge, rom_path ? rom_path : "NULL");        return -1;    }    CART_LOG_INFO("Carregando ROM NES: %s", rom_path);    // Abre o arquivo    FILE *file = fopen(rom_path, "rb");    if (!file)    {        CART_LOG_ERROR("nes_cartridge_load: falha ao abrir arquivo: %s", rom_path);        return -1;    }    // Verifica o tamanho do arquivo    fseek(file, 0, SEEK_END);    long file_size = ftell(file);    fseek(file, 0, SEEK_SET);    CART_LOG_INFO("Tamanho do arquivo ROM: %ld bytes", file_size);    if (file_size < 16) // Cabeçalho iNES tem pelo menos 16 bytes    {        CART_LOG_ERROR("nes_cartridge_load: arquivo muito pequeno para ser uma ROM NES");        fclose(file);        return -1;    }    // Lê o cabeçalho iNES    uint8_t header[16];    if (fread(header, 1, 16, file) != 16)    {        CART_LOG_ERROR("nes_cartridge_load: falha ao ler o cabeçalho");        fclose(file);        return -1;    }    // Verifica assinatura "NES^Z"    if (header[0] != 'N' || header[1] != 'E' || header[2] != 'S' || header[3] != 0x1A)    {        CART_LOG_ERROR("nes_cartridge_load: assinatura NES inválida: %c%c%c%02X",                       header[0], header[1], header[2], header[3]);        fclose(file);        return -1;    }    // Extrai informações do cabeçalho    uint8_t prg_rom_16k_units = header[4];    uint8_t chr_rom_8k_units = header[5];    uint8_t flags6 = header[6];    uint8_t flags7 = header[7];    uint8_t prg_ram_8k_units = header[8];    uint8_t flags9 = header[9];    uint8_t flags10 = header[10];    CART_LOG_DEBUG("Informações do cabeçalho iNES:");    CART_LOG_DEBUG("  PRG-ROM units: %d (16KB each)", prg_rom_16k_units);    CART_LOG_DEBUG("  CHR-ROM units: %d (8KB each)", chr_rom_8k_units);    CART_LOG_DEBUG("  Flags6: 0x%02X", flags6);    CART_LOG_DEBUG("  Flags7: 0x%02X", flags7);    CART_LOG_DEBUG("  PRG-RAM units: %d (8KB each)", prg_ram_8k_units);    // Validações adicionais    if (prg_rom_16k_units == 0)    {        CART_LOG_ERROR("nes_cartridge_load: ROM sem PRG-ROM");        fclose(file);        return NES_ERROR_INVALID_ROM;    }    // Calcula tamanhos    int prg_rom_size = prg_rom_16k_units * 16 * 1024;    int chr_rom_size = chr_rom_8k_units * 8 * 1024;    int prg_ram_size = (prg_ram_8k_units > 0 ? prg_ram_8k_units : 1) * 8 * 1024;    int chr_ram_size = (chr_rom_size == 0) ? 8 * 1024 : 0; // CHR-RAM se não tiver CHR-ROM    CART_LOG_DEBUG("Tamanhos calculados:");    CART_LOG_DEBUG("  PRG-ROM: %d bytes", prg_rom_size);    CART_LOG_DEBUG("  CHR-ROM: %d bytes", chr_rom_size);    CART_LOG_DEBUG("  PRG-RAM: %d bytes", prg_ram_size);    CART_LOG_DEBUG("  CHR-RAM: %d bytes", chr_ram_size);    // Extrai informações de espelhamento    int mirror_mode = (flags6 & 0x01) ? NES_MIRROR_VERTICAL : NES_MIRROR_HORIZONTAL;    if (flags6 & 0x08) // Four-screen mirroring    {        mirror_mode = NES_MIRROR_FOUR_SCREEN;    }    // Extrai informações de mapper    int mapper_number = ((flags7 & 0xF0) | (flags6 >> 4)) & 0xFF;    int ines_version = (flags7 >> 2) & 0x03;    CART_LOG_DEBUG("Configurações do cartucho:");    CART_LOG_DEBUG("  Mapper: %d", mapper_number);    CART_LOG_DEBUG("  iNES version: %d", ines_version);    CART_LOG_DEBUG("  Mirror mode: %d", mirror_mode);    // Verifica se o mapper é suportado    switch (mapper_number)    {    case 0: // NROM    case 1: // MMC1    case 2: // UNROM    case 3: // CNROM    case 4: // MMC3        // Mappers suportados        CART_LOG_INFO("Mapper %d suportado", mapper_number);        break;    default:        CART_LOG_ERROR("nes_cartridge_load: mapper %d não suportado", mapper_number);        fclose(file);        return NES_ERROR_UNSUPPORTED_MAPPER;    }    // Informações adicionais    int has_battery = (flags6 & 0x02) ? 1 : 0;    int has_trainer = (flags6 & 0x04) ? 1 : 0;    CART_LOG_DEBUG("Características adicionais:");    CART_LOG_DEBUG("  Battery: %s", has_battery ? "Sim" : "Não");    CART_LOG_DEBUG("  Trainer: %s", has_trainer ? "Sim" : "Não");    // Pula o trainer, se presente    if (has_trainer)    {        CART_LOG_DEBUG("Pulando trainer (512 bytes)");        fseek(file, 512, SEEK_CUR);    }    // Libera recursos anteriores    if (cartridge->prg_rom)    {        free(cartridge->prg_rom);    }    if (cartridge->chr_rom)    {        free(cartridge->chr_rom);    }    if (cartridge->prg_ram)    {        free(cartridge->prg_ram);    }    if (cartridge->chr_ram)    {        free(cartridge->chr_ram);    }    if (cartridge->rom_path)    {        free(cartridge->rom_path);    }    // Aloca memória para a PRG-ROM    cartridge->prg_rom = (uint8_t *)malloc(prg_rom_size);    if (!cartridge->prg_rom)    {        CART_LOG_ERROR("nes_cartridge_load: falha ao alocar PRG-ROM");        fclose(file);        return -1;    }    // Lê a PRG-ROM    if (fread(cartridge->prg_rom, 1, prg_rom_size, file) != prg_rom_size)    {        CART_LOG_ERROR("nes_cartridge_load: falha ao ler PRG-ROM");        fclose(file);        return -1;    }    CART_LOG_DEBUG("PRG-ROM carregada: primeiros bytes: %02X %02X %02X %02X",                   cartridge->prg_rom[0], cartridge->prg_rom[1],                   cartridge->prg_rom[2], cartridge->prg_rom[3]);    // Aloca e lê a CHR-ROM, se presente    if (chr_rom_size > 0)    {        cartridge->chr_rom = (uint8_t *)malloc(chr_rom_size);        if (!cartridge->chr_rom)        {            CART_LOG_ERROR("nes_cartridge_load: falha ao alocar CHR-ROM");            fclose(file);            return -1;        }        if (fread(cartridge->chr_rom, 1, chr_rom_size, file) != chr_rom_size)        {            CART_LOG_ERROR("nes_cartridge_load: falha ao ler CHR-ROM");            fclose(file);            return -1;        }        CART_LOG_DEBUG("CHR-ROM carregada: primeiros bytes: %02X %02X %02X %02X",                       cartridge->chr_rom[0], cartridge->chr_rom[1],                       cartridge->chr_rom[2], cartridge->chr_rom[3]);        // Verifica alguns tiles para debug        CART_LOG_DEBUG("Verificando primeiros tiles da CHR-ROM:");        for (int i = 0; i < 2; i++)        {            CART_LOG_DEBUG("Tile %d:", i);            for (int row = 0; row < 8; row++)            {                uint8_t pattern_low = cartridge->chr_rom[i * 16 + row];                uint8_t pattern_high = cartridge->chr_rom[i * 16 + row + 8];                CART_LOG_DEBUG("  Row %d: low=%02X high=%02X", row, pattern_low, pattern_high);            }        }    }    else    {        CART_LOG_INFO("ROM não tem CHR-ROM, usando CHR-RAM");    }    // Aloca a PRG-RAM    cartridge->prg_ram = (uint8_t *)malloc(prg_ram_size);    if (!cartridge->prg_ram)    {        CART_LOG_ERROR("nes_cartridge_load: falha ao alocar PRG-RAM");        fclose(file);        return -1;    }    memset(cartridge->prg_ram, 0, prg_ram_size);    CART_LOG_DEBUG("PRG-RAM alocada e zerada: %d bytes", prg_ram_size);    // Aloca a CHR-RAM, se necessário    if (chr_ram_size > 0)    {        cartridge->chr_ram = (uint8_t *)malloc(chr_ram_size);        if (!cartridge->chr_ram)        {            CART_LOG_ERROR("nes_cartridge_load: falha ao alocar CHR-RAM");            fclose(file);            return -1;        }        memset(cartridge->chr_ram, 0, chr_ram_size);        CART_LOG_DEBUG("CHR-RAM alocada e zerada: %d bytes", chr_ram_size);    }    // Atualiza as informações do cartucho    cartridge->prg_rom_size = prg_rom_size;    cartridge->chr_rom_size = chr_rom_size;    cartridge->prg_ram_size = prg_ram_size;    cartridge->chr_ram_size = chr_ram_size;    cartridge->mapper_number = mapper_number;    cartridge->mirror_mode = mirror_mode;    cartridge->has_battery = has_battery;    cartridge->rom_path = strdup(rom_path);    // Fecha o arquivo    fclose(file);    // Carrega a PRG-RAM com bateria, se existir    if (has_battery)    {        CART_LOG_INFO("Carregando SRAM da bateria");        nes_cartridge_load_sram(cartridge, NULL);    }    // Cria e inicializa o mapper apropriado    int mapper_result = nes_cartridge_create_mapper(cartridge);    if (mapper_result != 0)    {        CART_LOG_ERROR("nes_cartridge_load: falha ao criar mapper");        return mapper_result;    }    CART_LOG_INFO("ROM NES carregada com sucesso: %s", rom_path);    return 0;}/** * @brief Obtém informações sobre a ROM carregada * * @param cartridge Ponteiro para o cartucho * @param info Ponteiro para a estrutura de informações a ser preenchida * @return int 0 em caso de sucesso, código de erro em caso de falha */int nes_cartridge_get_info(nes_cartridge_t *cartridge, nes_rom_info_t *info){    if (!cartridge || !info)    {        CART_LOG_ERROR("nes_cartridge_get_info: parâmetros inválidos");        return -1;    }    // Preenche a estrutura de informações    info->mapper_type = cartridge->mapper_type;    info->mapper_number = cartridge->mapper_number;    info->prg_rom_size = cartridge->prg_rom_size;    info->chr_rom_size = cartridge->chr_rom_size;    info->prg_ram_size = cartridge->prg_ram_size;    info->has_battery = cartridge->has_battery;    info->mirroring = cartridge->mirror_mode;    info->prg_rom = cartridge->prg_rom;    info->chr_rom = cartridge->chr_rom;    return 0;}/** * @brief Lê um byte da ROM ou RAM do cartucho (acesso da CPU) * * @param cartridge Ponteiro para o cartucho * @param address Endereço para leitura * @return uint8_t Valor lido */uint8_t nes_cartridge_cpu_read(nes_cartridge_t *cartridge, uint16_t address){    if (!cartridge)    {        CART_LOG_ERROR("nes_cartridge_cpu_read: cartridge inválido");        return 0;    }    // Verifica se endereço está no range do cartucho    if (address < 0x4020)    {        CART_LOG_WARN("nes_cartridge_cpu_read: endereço fora do range do cartucho: $%04X", address);        return 0;    }    // Se o mapper estiver configurado, delega a leitura para ele    if (cartridge->mapper && cartridge->mapper->cpu_read)    {        return cartridge->mapper->cpu_read(cartridge, address);    }    // Implementação padrão para o mapper NROM (0)    if (address >= 0x8000)    {        // Acesso à PRG-ROM: mapeia para a ROM        uint32_t prg_addr = (address - 0x8000) % cartridge->prg_rom_size;        return cartridge->prg_rom[prg_addr];    }    else if (address >= 0x6000 && address < 0x8000)    {        // Acesso à PRG-RAM (SRAM): mapeia para a RAM        uint32_t ram_addr = (address - 0x6000) % cartridge->prg_ram_size;        return cartridge->prg_ram[ram_addr];    }    // Caso especial para o endereço $5F19 (usado por alguns jogos como Super Mario Bros)    else if (address == 0x5F19)    {        // Retorna um valor fixo ou um comportamento específico para este endereço        // Muitos jogos usam este endereço para detecção de hardware ou características específicas        return 0x00; // Valor padrão que satisfaz a maioria dos jogos    }    CART_LOG_WARN("nes_cartridge_cpu_read: endereço não mapeado: $%04X", address);    return 0;}/** * @brief Escreve um byte na ROM ou RAM do cartucho (acesso da CPU) * * @param cartridge Ponteiro para o cartucho * @param address Endereço para escrita * @param value Valor a ser escrito */void nes_cartridge_cpu_write(nes_cartridge_t *cartridge, uint16_t address, uint8_t value){    if (!cartridge)    {        CART_LOG_ERROR("nes_cartridge_cpu_write: cartridge inválido");        return;    }    // Verifica se endereço está no range do cartucho    if (address < 0x4020)    {        CART_LOG_WARN("nes_cartridge_cpu_write: endereço fora do range do cartucho: $%04X", address);        return;    }    // Se o mapper estiver configurado, delega a escrita para ele    if (cartridge->mapper && cartridge->mapper->cpu_write)    {        cartridge->mapper->cpu_write(cartridge, address, value);        return;    }    // Implementação padrão para o mapper NROM (0)    if (address >= 0x8000)    {        // Acesso à PRG-ROM: não permite escrita (a menos que seja um mapper especial)        // Alguns jogos tentam escrever em PRG-ROM como teste ou para acionar comportamentos especiais        // Caso especial para o endereço $8224 (usado por alguns jogos, incluindo Super Mario Bros)        if (address == 0x8224)        {            // Podemos implementar um comportamento específico aqui se necessário            // Por enquanto, apenas logamos, mas não tratamos como erro crítico            CART_LOG_WARN("nes_cartridge_cpu_write: tentativa de escrita em PRG-ROM: $%04X = $%02X", address, value);            // Opcionalmente, podemos definir uma variável de "flag interna" para rastrear esta escrita            // cartridge->special_flag = value;            return; // Retorna sem erro para não interromper o jogo        }        // Para outros endereços, mantenha o comportamento anterior        CART_LOG_WARN("nes_cartridge_cpu_write: tentativa de escrita em PRG-ROM: $%04X = $%02X", address, value);    }    else if (address >= 0x6000 && address < 0x8000)    {        // Acesso à PRG-RAM (SRAM): permite escrita        uint32_t ram_addr = (address - 0x6000) % cartridge->prg_ram_size;        cartridge->prg_ram[ram_addr] = value;        // Marca PRG-RAM como modificada para salvar depois, se tiver bateria        if (cartridge->has_battery)        {            cartridge->sram_dirty = 1;        }    }    else    {        CART_LOG_WARN("nes_cartridge_cpu_write: endereço não mapeado: $%04X = $%02X", address, value);    }}/** * @brief Lê um byte da CHR-ROM/RAM do cartucho (acesso da PPU) * * @param cartridge Ponteiro para o cartucho * @param address Endereço para leitura * @return uint8_t Valor lido */uint8_t nes_cartridge_chr_read(nes_cartridge_t *cartridge, uint16_t address){    if (!cartridge)    {        CART_LOG_ERROR("nes_cartridge_chr_read: cartridge é NULL");        return 0;    }    CART_LOG_DEBUG("nes_cartridge_chr_read: Iniciando leitura em 0x%04X", address);    if (address >= 0x2000)    {        CART_LOG_WARN("nes_cartridge_chr_read: endereço 0x%04X fora do alcance", address);        return 0;    }    // Verifica se o mapper tem função de leitura CHR    if (cartridge->mapper && cartridge->mapper->chr_read)    {        CART_LOG_DEBUG("nes_cartridge_chr_read: usando mapper %d para ler CHR em 0x%04X",                       cartridge->mapper_number, address);        uint8_t value = cartridge->mapper->chr_read(cartridge->mapper->context, address);        CART_LOG_DEBUG("nes_cartridge_chr_read: mapper retornou 0x%02X para tile %d linha %d",                       value, (address & 0xFF0) >> 4, address & 0x7);        return value;    }    // Fallback para leitura direta    if (cartridge->chr_rom && cartridge->chr_rom_size > 0)    {        // Calcula o endereço real na CHR-ROM        uint16_t bank = address >> 12;     // Seleciona o banco de 4KB (0 ou 1)        uint16_t offset = address & 0xFFF; // Offset dentro do banco        uint16_t chr_addr = (bank * 0x1000 + offset) % cartridge->chr_rom_size;        uint8_t value = cartridge->chr_rom[chr_addr];        CART_LOG_DEBUG("nes_cartridge_chr_read: lendo CHR-ROM[0x%04X] = 0x%02X para tile %d linha %d",                       chr_addr, value, (address & 0xFF0) >> 4, address & 0x7);        return value;    }    else if (cartridge->chr_ram && cartridge->chr_ram_size > 0)    {        // Calcula o endereço real na CHR-RAM        uint16_t bank = address >> 12;     // Seleciona o banco de 4KB (0 ou 1)        uint16_t offset = address & 0xFFF; // Offset dentro do banco        uint16_t chr_addr = (bank * 0x1000 + offset) % cartridge->chr_ram_size;        uint8_t value = cartridge->chr_ram[chr_addr];        CART_LOG_DEBUG("nes_cartridge_chr_read: lendo CHR-RAM[0x%04X] = 0x%02X para tile %d linha %d",                       chr_addr, value, (address & 0xFF0) >> 4, address & 0x7);        return value;    }    CART_LOG_ERROR("nes_cartridge_chr_read: CHR-ROM e CHR-RAM ausentes");    return 0;}/** * @brief Escreve um byte na memória de padrões (VRAM) do cartucho (acesso da PPU) * * @param cartridge Ponteiro para o cartucho * @param address Endereço para escrita * @param value Valor a ser escrito */void nes_cartridge_chr_write(nes_cartridge_t *cartridge, uint16_t address, uint8_t value){    if (!cartridge)    {        CART_LOG_ERROR("nes_cartridge_chr_write: cartridge inválido");        return;    }    // Verifica se o endereço está no range válido    if (address >= 0x2000)    {        CART_LOG_WARN("nes_cartridge_chr_write: endereço fora do range CHR: $%04X", address);        return;    }    // Se o mapper estiver configurado, delega a escrita para ele    if (cartridge->mapper && cartridge->mapper->chr_write)    {        cartridge->mapper->chr_write(cartridge, address, value);        return;    }    // Implementação padrão para o mapper NROM (0)    if (cartridge->chr_rom)    {        // CHR-ROM: não permite escrita        CART_LOG_WARN("nes_cartridge_chr_write: tentativa de escrita em CHR-ROM: $%04X = $%02X", address, value);    }    else if (cartridge->chr_ram)    {        // CHR-RAM: permite escrita        cartridge->chr_ram[address % cartridge->chr_ram_size] = value;    }    else    {        CART_LOG_WARN("nes_cartridge_chr_write: nenhuma ROM/RAM CHR disponível");    }}/** * @brief Cria o mapper apropriado para o cartucho * * @param cartridge Ponteiro para o cartucho * @return int 0 em caso de sucesso, código de erro em caso de falha */int nes_cartridge_create_mapper(nes_cartridge_t *cartridge){    if (!cartridge)    {        CART_LOG_ERROR("nes_cartridge_create_mapper: cartridge inválido");        return -1;    }    // Seleciona o tipo de mapper com base no número    switch (cartridge->mapper_number)    {    case 0:        cartridge->mapper_type = NES_MAPPER_NROM;        break;    case 1:        cartridge->mapper_type = NES_MAPPER_MMC1;        break;    case 2:        cartridge->mapper_type = NES_MAPPER_UNROM;        break;    case 3:        cartridge->mapper_type = NES_MAPPER_CNROM;        break;    case 4:        cartridge->mapper_type = NES_MAPPER_MMC3;        break;    default:        CART_LOG_ERROR("nes_cartridge_create_mapper: mapper não suportado: %d", cartridge->mapper_number);        return -1;    }    // Inicializa a estrutura do mapper (funções de callback)    cartridge->mapper = (nes_mapper_t *)malloc(sizeof(nes_mapper_t));    if (!cartridge->mapper)    {        CART_LOG_ERROR("nes_cartridge_create_mapper: falha ao alocar estrutura do mapper");        return -1;    }    // Inicializa as funções de callback com NULL    memset(cartridge->mapper, 0, sizeof(nes_mapper_t));    // Configura as funções do mapper específico    switch (cartridge->mapper_type)    {    case NES_MAPPER_NROM:        // Mapper 0: NROM - implementado no próprio cartridge.c (não precisa de funções específicas)        CART_LOG_INFO("Mapper 0 (NROM) inicializado");        break;    case NES_MAPPER_MMC1:        // Mapper 1: MMC1 - inicializa com as funções específicas        if (mapper_mmc1_init(cartridge) != 0)        {            CART_LOG_ERROR("Falha ao inicializar o Mapper 1 (MMC1)");            free(cartridge->mapper);            cartridge->mapper = NULL;            return -1;        }        break;    // Implementação para outros mappers...    default:        CART_LOG_ERROR("nes_cartridge_create_mapper: tipo de mapper inválido: %d", cartridge->mapper_type);        free(cartridge->mapper);        cartridge->mapper = NULL;        return -1;    }    CART_LOG_INFO("Mapper %d inicializado com sucesso", cartridge->mapper_number);    return 0;}/** * @brief Salva a SRAM (PRG-RAM com bateria) * * @param cartridge Ponteiro para o cartucho * @return int 0 em caso de sucesso, código de erro em caso de falha */int nes_cartridge_save_sram(nes_cartridge_t *cartridge){    if (!cartridge || !cartridge->rom_path || !cartridge->has_battery || !cartridge->prg_ram)    {        CART_LOG_WARN("nes_cartridge_save_sram: não é necessário salvar SRAM");        return 0;    }    // Se a SRAM não foi modificada, não é necessário salvar    if (!cartridge->sram_dirty)    {        return 0;    }    // Cria o nome do arquivo de SRAM com base no nome da ROM    char sram_path[PATH_MAX];    snprintf(sram_path, PATH_MAX, "%s.sav", cartridge->rom_path);    CART_LOG_INFO("Salvando SRAM: %s", sram_path);    // Abre o arquivo para escrita    FILE *file = fopen(sram_path, "wb");    if (!file)    {        CART_LOG_ERROR("nes_cartridge_save_sram: falha ao abrir arquivo: %s", sram_path);        return -1;    }    // Escreve a PRG-RAM no arquivo    size_t bytes_written = fwrite(cartridge->prg_ram, 1, cartridge->prg_ram_size, file);    fclose(file);    if (bytes_written != cartridge->prg_ram_size)    {        CART_LOG_ERROR("nes_cartridge_save_sram: falha ao escrever todos os bytes");        return -1;    }    cartridge->sram_dirty = 0;    CART_LOG_INFO("SRAM salva com sucesso: %d bytes", bytes_written);    return 0;}/** * @brief Carrega a SRAM (PRG-RAM com bateria) * * @param cartridge Ponteiro para o cartucho * @return int 0 em caso de sucesso, código de erro em caso de falha */int nes_cartridge_load_sram(nes_cartridge_t *cartridge, void *ctx){    if (!cartridge || !cartridge->rom_path || !cartridge->has_battery || !cartridge->prg_ram)    {        CART_LOG_WARN("nes_cartridge_load_sram: não é necessário carregar SRAM");        return 0; // Não é um erro, apenas não há arquivo de SRAM ainda    }    // Cria o nome do arquivo de SRAM com base no nome da ROM    char sram_path[PATH_MAX];    snprintf(sram_path, PATH_MAX, "%s.sav", cartridge->rom_path);    CART_LOG_INFO("Carregando SRAM: %s", sram_path);    // Abre o arquivo para leitura    FILE *file = fopen(sram_path, "rb");    if (!file)    {        CART_LOG_WARN("nes_cartridge_load_sram: arquivo não encontrado: %s", sram_path);        return 0; // Não é um erro, apenas não há arquivo de SRAM ainda    }    // Lê a PRG-RAM do arquivo    size_t bytes_read = fread(cartridge->prg_ram, 1, cartridge->prg_ram_size, file);    fclose(file);    if (bytes_read != cartridge->prg_ram_size)    {        CART_LOG_WARN("nes_cartridge_load_sram: tamanho do arquivo difere da PRG-RAM");        // Não retorna erro, usa o que foi lido    }    cartridge->sram_dirty = 0;    CART_LOG_INFO("SRAM carregada com sucesso: %d bytes", bytes_read);    return 0;}/** * @brief Obtém o modo de espelhamento do cartucho * * @param cartridge Ponteiro para o cartucho * @return nes_mirror_mode_t Modo de espelhamento */nes_mirror_mode_t nes_cartridge_get_mirror_mode(nes_cartridge_t *cartridge){    if (!cartridge)    {        return NES_MIRROR_HORIZONTAL; // Padrão, em caso de erro    }    return cartridge->mirror_mode;}/** * @brief Notifica o mapper sobre um novo scanline * * @param cartridge Ponteiro para o cartucho * @param scanline Número do scanline atual */void nes_cartridge_scanline(nes_cartridge_t *cartridge, int scanline){    if (!cartridge)    {        return;    }    // Alguns mappers precisam ser notificados sobre os scanlines    // (por exemplo, MMC3 para IRQs baseados em scanlines)    if (cartridge->mapper && cartridge->mapper->scanline)    {        // Muitos mappers precisam saber qual é o scanline atual        // Vamos armazenar o scanline no contexto do mapper antes de chamar a função        if (cartridge->mapper_type == NES_MAPPER_MMC3)        {            mapper4_t *mapper4_ctx = (mapper4_t *)cartridge->mapper->context;            if (mapper4_ctx)            {                // Armazenar o scanline no contexto                mapper4_ctx->current_scanline = scanline;                // Chamar a função scanline passando apenas o contexto                cartridge->mapper->scanline(cartridge->mapper->context);            }        }        else        {            // Para outros mappers que possam precisar da função scanline            cartridge->mapper->scanline(cartridge->mapper->context);        }    }}// Vamos implementar a função do mapper 1 para chr_readstatic uint8_t mapper1_chr_read(void *ctx, uint16_t address){    mapper1_t *mapper = (mapper1_t *)ctx;    if (!mapper || !mapper->cart)    {        return 0;    }    nes_cartridge_t *cart = mapper->cart;    // Acesso à CHR-ROM    if (cart->chr_rom && cart->chr_rom_size > 0)    {        uint8_t bank = address >> 12;       // 0 ou 1 para escolher 4KB bank        uint16_t offset = address & 0x0FFF; // Offset dentro do bank        if (bank == 0)        {            // Primeiro bank de 4KB            uint16_t mapped_address = mapper->chr_bank_0 * 0x1000 + offset;            if (mapped_address < cart->chr_rom_size)            {                return cart->chr_rom[mapped_address];            }        }        else        { // bank == 1            // Segundo bank de 4KB            uint16_t mapped_address = mapper->chr_bank_1 * 0x1000 + offset;            if (mapped_address < cart->chr_rom_size)            {                return cart->chr_rom[mapped_address];            }        }    }    // Acesso à CHR-RAM    else if (cart->chr_ram && cart->chr_ram_size > 0)    {        if (address < cart->chr_ram_size)        {            return cart->chr_ram[address];        }    }    return 0;}/** * @brief Inicializa o mapper MMC1 (Mapper 1) * * @param cartridge Ponteiro para o cartucho * @return int 0 em caso de sucesso, código de erro em caso de falha */static int mapper_mmc1_init(nes_cartridge_t *cartridge){    if (!cartridge || !cartridge->mapper)    {        CART_LOG_ERROR("mapper_mmc1_init: parâmetros inválidos");        return -1;    }    // Aloca a estrutura do mapper    mapper1_t *mapper_data = (mapper1_t *)malloc(sizeof(mapper1_t));    if (!mapper_data)    {        CART_LOG_ERROR("mapper_mmc1_init: falha ao alocar dados do mapper");        return -1;    }    // Inicializa o estado do mapper    memset(mapper_data, 0, sizeof(mapper1_t));    mapper_data->cart = cartridge;    mapper_data->control = 0x0C;        // Inicialização padrão: PRG ROM mode 3, 4KB CHR mode    mapper_data->chr_bank_0 = 0;        // 4KB bank 0 no início da CHR ROM    mapper_data->chr_bank_1 = 1;        // 4KB bank 1 na segunda metade do primeiro 8KB bank    mapper_data->prg_bank = 0;          // Primeiro bank de 16KB    mapper_data->shift_register = 0x10; // Bit mais significativo setado    mapper_data->shift_count = 0;    // Configura as funções do mapper    cartridge->mapper->mapper_number = 1;    cartridge->mapper->cpu_read = NULL;  // Implementar se necessário    cartridge->mapper->cpu_write = NULL; // Implementar se necessário    cartridge->mapper->chr_read = mapper1_chr_read;    cartridge->mapper->chr_write = NULL; // Implementar se necessário    cartridge->mapper->scanline = NULL;  // MMC1 não usa scanline IRQs    cartridge->mapper->reset = NULL;     // Implementar se necessário    cartridge->mapper->shutdown = NULL;  // Implementar se necessário    cartridge->mapper->context = mapper_data;    cartridge->mapper_data = mapper_data;    CART_LOG_INFO("Mapper 1 (MMC1) inicializado com sucesso");    return 0;}/** * @brief Leitura do espaço de endereço CPU para o mapper 0 (NROM) * * @param ctx Contexto do mapper * @param addr Endereço a ser lido * @return uint8_t Byte lido */static uint8_t mapper_0_cpu_read(void *ctx, uint16_t addr){    if (!ctx)    {        CART_LOG_ERROR("mapper_0_cpu_read: ctx é NULL");        return 0;    }    mapper0_t *mapper = (mapper0_t *)ctx;    if (!mapper || !mapper->cart)    {        CART_LOG_ERROR("mapper_0_cpu_read: mapper ou cart é NULL");        return 0;    }    nes_cartridge_t *cart = mapper->cart;    // Endereço na faixa 0x6000-0x7FFF: PRG-RAM    if (addr >= 0x6000 && addr < 0x8000)    {        if (cart->prg_ram && cart->prg_ram_size > 0)        {            uint16_t prg_ram_addr = addr - 0x6000;            if (prg_ram_addr < cart->prg_ram_size)            {                return cart->prg_ram[prg_ram_addr];            }            // Espelhamento            return cart->prg_ram[prg_ram_addr % cart->prg_ram_size];        }        CART_LOG_WARN("mapper_0_cpu_read: Tentativa de ler PRG-RAM em 0x%04X, mas a PRG-RAM não está disponível", addr);        return 0;    }    // Endereço na faixa 0x8000-0xFFFF: PRG-ROM    else if (addr >= 0x8000 && addr <= 0xFFFF)    {        if (cart->prg_rom && cart->prg_rom_size > 0)        {            // NROM: Se tiver 32KB de PRG-ROM, usa o mapeamento direto            // Se tiver 16KB, espelha o mesmo banco nos dois espaços            if (cart->prg_rom_size == 0x4000) // 16KB            {                return cart->prg_rom[addr & 0x3FFF];            }            else // 32KB ou mais            {                uint32_t prg_addr = addr - 0x8000;                if (prg_addr < cart->prg_rom_size)                {                    return cart->prg_rom[prg_addr];                }                // Espelhamento para endereços maiores                return cart->prg_rom[prg_addr % cart->prg_rom_size];            }        }        CART_LOG_ERROR("mapper_0_cpu_read: Tentativa de ler PRG-ROM em 0x%04X, mas a PRG-ROM não está disponível", addr);        return 0;    }    CART_LOG_ERROR("mapper_0_cpu_read: Endereço fora do alcance: 0x%04X", addr);    return 0;}/** * @brief Escrita no espaço de endereço CPU para o mapper 0 (NROM) * * @param ctx Contexto do mapper * @param addr Endereço a ser escrito * @param val Valor a ser escrito */static void mapper_0_cpu_write(void *ctx, uint16_t addr, uint8_t val){    if (!ctx)    {        CART_LOG_ERROR("mapper_0_cpu_write: ctx é NULL");        return;    }    mapper0_t *mapper = (mapper0_t *)ctx;    if (!mapper || !mapper->cart)    {        CART_LOG_ERROR("mapper_0_cpu_write: mapper ou cart é NULL");        return;    }    nes_cartridge_t *cart = mapper->cart;    // Endereço na faixa 0x6000-0x7FFF: PRG-RAM    if (addr >= 0x6000 && addr < 0x8000)    {        if (cart->prg_ram && cart->prg_ram_size > 0)        {            uint16_t prg_ram_addr = addr - 0x6000;            if (prg_ram_addr < cart->prg_ram_size)            {                cart->prg_ram[prg_ram_addr] = val;                cart->sram_dirty = 1; // Marca a SRAM como modificada                return;            }            // Espelhamento            cart->prg_ram[prg_ram_addr % cart->prg_ram_size] = val;            cart->sram_dirty = 1;            return;        }        CART_LOG_WARN("mapper_0_cpu_write: Tentativa de escrever PRG-RAM em 0x%04X, mas a PRG-RAM não está disponível", addr);        return;    }    // Endereço na faixa 0x8000-0xFFFF: PRG-ROM (não deve ser escrita)    else if (addr >= 0x8000)    {        CART_LOG_WARN("mapper_0_cpu_write: Tentativa de escrever em PRG-ROM: 0x%04X = 0x%02X", addr, val);        return;    }    CART_LOG_ERROR("mapper_0_cpu_write: Endereço fora do alcance: 0x%04X", addr);}/** * @brief Escrita no espaço de endereço CHR para o mapper 0 (NROM) * * @param ctx Contexto do mapper * @param addr Endereço a ser escrito * @param val Valor a ser escrito */static void mapper_0_chr_write(void *ctx, uint16_t addr, uint8_t val){    if (!ctx)    {        CART_LOG_ERROR("mapper_0_chr_write: ctx é NULL");        return;    }    mapper0_t *mapper = (mapper0_t *)ctx;    if (!mapper || !mapper->cart)    {        CART_LOG_ERROR("mapper_0_chr_write: mapper ou cart é NULL");        return;    }    nes_cartridge_t *cart = mapper->cart;    // Verifica se tem CHR-RAM (não é possível escrever em CHR-ROM)    if (cart->chr_ram && cart->chr_ram_size > 0)    {        // Garante que o endereço está dentro dos limites usando AND        uint16_t masked_addr = addr & (cart->chr_ram_size - 1);        cart->chr_ram[masked_addr] = val;        return;    }    // Se tentou escrever em CHR-ROM, é um aviso    else if (cart->chr_rom && cart->chr_rom_size > 0)    {        CART_LOG_WARN("mapper_0_chr_write: Tentativa de escrever em CHR-ROM: 0x%04X = 0x%02X", addr, val);        return;    }    CART_LOG_ERROR("mapper_0_chr_write: Sem CHR-ROM ou CHR-RAM definida");}/** * @brief Leitura do espaço de endereço CHR para o mapper 0 (NROM) * * @param ctx Contexto do mapper * @param addr Endereço a ser lido * @return uint8_t Byte lido */static uint8_t mapper_0_chr_read(void *ctx, uint16_t addr){    if (!ctx)    {        CART_LOG_ERROR("mapper_0_chr_read: ctx é NULL");        return 0;    }    mapper0_t *mapper = (mapper0_t *)ctx;    if (!mapper || !mapper->cart)    {        CART_LOG_ERROR("mapper_0_chr_read: mapper ou cart é NULL");        return 0;    }    nes_cartridge_t *cart = mapper->cart;    // Leitura da CHR-ROM (se existir)    if (cart->chr_rom && cart->chr_rom_size > 0)    {        // Garante que o endereço está dentro dos limites usando AND        uint16_t masked_addr = addr & (cart->chr_rom_size - 1);        return cart->chr_rom[masked_addr];    }    // Leitura da CHR-RAM (se existir, usado quando não há CHR-ROM)    else if (cart->chr_ram && cart->chr_ram_size > 0)    {        // Garante que o endereço está dentro dos limites usando AND        uint16_t masked_addr = addr & (cart->chr_ram_size - 1);        return cart->chr_ram[masked_addr];    }    CART_LOG_ERROR("mapper_0_chr_read: Sem CHR-ROM ou CHR-RAM definida");    return 0;}/** * @brief Inicializa o mapper 0 (NROM) * * @param cartridge Ponteiro para o cartucho * @return int 0 em caso de sucesso, código de erro em caso de falha */static int nes_mapper_0_init(nes_cartridge_t *cartridge){    if (!cartridge)    {        CART_LOG_ERROR("nes_mapper_0_init: cartridge é NULL");        return -1;    }    CART_LOG_INFO("Inicializando mapper 0 (NROM)");    // Aloca a estrutura do mapper    mapper0_t *mapper = (mapper0_t *)malloc(sizeof(mapper0_t));    if (!mapper)    {        CART_LOG_ERROR("nes_mapper_0_init: falha ao alocar memória para o mapper");        return -1;    }    // Inicializa a estrutura    mapper->cart = cartridge;    // Aloca a estrutura de interface    nes_mapper_t *interface = (nes_mapper_t *)malloc(sizeof(nes_mapper_t));    if (!interface)    {        CART_LOG_ERROR("nes_mapper_0_init: falha ao alocar memória para a interface do mapper");        free(mapper);        return -1;    }    // Configura a interface    interface->context = mapper;    interface->cpu_read = mapper_0_cpu_read;    interface->cpu_write = mapper_0_cpu_write;    interface->chr_read = mapper_0_chr_read;    interface->chr_write = mapper_0_chr_write;    interface->scanline = NULL; // NROM não requer notificação de scanline    // Atribui a interface ao cartucho    cartridge->mapper = interface;    cartridge->mapper_data = mapper;    cartridge->mapper_type = NES_MAPPER_NROM;    // Log detalhado para diagnóstico    CART_LOG_INFO("Mapper 0 (NROM) inicializado:");    CART_LOG_INFO("  PRG-ROM size: %d bytes", cartridge->prg_rom_size);    CART_LOG_INFO("  CHR-ROM size: %d bytes", cartridge->chr_rom_size);    CART_LOG_INFO("  CHR-RAM size: %d bytes", cartridge->chr_ram_size);    CART_LOG_INFO("  Mirroring mode: %d", cartridge->mirror_mode);    // Verificar se a ROM ou RAM está presente    if (!cartridge->prg_rom || cartridge->prg_rom_size == 0)    {        CART_LOG_ERROR("NROM: PRG-ROM ausente ou vazia!");    }    if (cartridge->chr_rom_size > 0)    {        if (!cartridge->chr_rom)        {            CART_LOG_ERROR("NROM: CHR-ROM ausente, mas tamanho > 0!");        }        else        {            CART_LOG_INFO("  Primeiros bytes da CHR-ROM: %02X %02X %02X %02X",                          cartridge->chr_rom[0], cartridge->chr_rom[1],                          cartridge->chr_rom[2], cartridge->chr_rom[3]);        }    }    else if (cartridge->chr_ram_size > 0)    {        if (!cartridge->chr_ram)        {            CART_LOG_ERROR("NROM: CHR-RAM ausente, mas tamanho > 0!");        }        else        {            CART_LOG_INFO("  CHR-RAM alocada e inicializada");        }    }    else    {        CART_LOG_ERROR("NROM: Nem CHR-ROM nem CHR-RAM presentes!");    }    CART_LOG_INFO("Mapper 0 (NROM) inicializado com sucesso");    return 0;}