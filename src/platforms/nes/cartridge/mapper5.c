/** * @file mapper5.c * @brief Implementação do mapper 5 (MMC5) para o NES */#include "nes_cartridge.h"#include "../cpu/nes_cpu.h"#include <stdlib.h>#include <string.h>// Registradores do MMC5#define MMC5_PRG_MODE 0x5100#define MMC5_CHR_MODE 0x5101#define MMC5_PRG_RAM_PROTECT 0x5102#define MMC5_EXRAM_MODE 0x5104#define MMC5_NAMETABLE_MODE 0x5105#define MMC5_FILL_TILE 0x5106#define MMC5_FILL_ATTR 0x5107#define MMC5_PRG_BANK_0 0x5113#define MMC5_PRG_BANK_1 0x5114#define MMC5_PRG_BANK_2 0x5115#define MMC5_PRG_BANK_3 0x5116#define MMC5_PRG_BANK_4 0x5117#define MMC5_CHR_BANK_0 0x5120#define MMC5_CHR_BANK_1 0x5121#define MMC5_CHR_BANK_2 0x5122#define MMC5_CHR_BANK_3 0x5123#define MMC5_CHR_BANK_4 0x5124#define MMC5_CHR_BANK_5 0x5125#define MMC5_CHR_BANK_6 0x5126#define MMC5_CHR_BANK_7 0x5127#define MMC5_CHR_BANK_8 0x5128#define MMC5_CHR_BANK_9 0x5129#define MMC5_CHR_BANK_10 0x512A#define MMC5_CHR_BANK_11 0x512B#define MMC5_IRQ_SCANLINE 0x5203#define MMC5_IRQ_STATUS 0x5204#define MMC5_MULT_A 0x5205#define MMC5_MULT_B 0x5206// Estrutura do mapper MMC5typedef struct{    nes_mapper_base_ctx_t base; // Estrutura base com campos comuns    // Registradores de controle    uint8_t prg_mode;       // Modo de PRG-ROM (0-3)    uint8_t chr_mode;       // Modo de CHR-ROM (0-3)    uint8_t exram_mode;     // Modo de ExRAM (0-3)    uint8_t nametable_mode; // Modo de mapeamento de nametable    // Bank switching    uint8_t prg_banks[5];  // Registradores de PRG bank    uint8_t chr_banks[12]; // Registradores de CHR bank    // ExRAM    uint8_t exram[1024]; // Expansion RAM de 1KB    // IRQ    uint8_t irq_scanline; // Valor de scanline para IRQ    uint8_t irq_enable;   // Flag de habilitação de IRQ    uint8_t irq_status;   // Status de IRQ    // Multiplicador de hardware    uint8_t mult_a;       // Multiplicador A    uint8_t mult_b;       // Multiplicador B    uint16_t mult_result; // Resultado da multiplicação    // Estado do PPU    uint16_t last_ppu_addr; // Último endereço acessado pelo PPU    int in_frame;           // Flag indicando rendering ativo} mapper5_t;// Protótipos de funções estáticasstatic uint8_t mapper_5_cpu_read(void *ctx, uint16_t addr);static void mapper_5_cpu_write(void *ctx, uint16_t addr, uint8_t val);static uint8_t mapper_5_chr_read(void *ctx, uint16_t addr);static void mapper_5_chr_write(void *ctx, uint16_t addr, uint8_t val);static void mapper_5_scanline(void *ctx);/** * @brief Inicializa o mapper 5 (MMC5) */int nes_mapper_5_init(nes_cartridge_t *cart){    if (!cart || !cart->mapper)    {        return -1;    }    // Aloca o contexto do mapper    mapper5_t *ctx = (mapper5_t *)malloc(sizeof(mapper5_t));    if (!ctx)    {        return -1;    }    // Inicializa o contexto    memset(ctx, 0, sizeof(mapper5_t));    ctx->base.cart = cart;    // Configura as funções de callback    cart->mapper->cpu_read = mapper_5_cpu_read;    cart->mapper->cpu_write = mapper_5_cpu_write;    cart->mapper->chr_read = mapper_5_chr_read;    cart->mapper->chr_write = mapper_5_chr_write;    cart->mapper->scanline = mapper_5_scanline;    cart->mapper->context = ctx;    return 0;}/** * @brief Lê um byte da memória (acesso da CPU) */static uint8_t mapper_5_cpu_read(void *ctx, uint16_t addr){    mapper5_t *mapper = (mapper5_t *)ctx;    nes_cartridge_t *cart = mapper->base.cart;    if (addr >= 0x5000 && addr <= 0x5FFF)    {        // Registradores do MMC5        switch (addr)        {        case MMC5_IRQ_STATUS:            return mapper->irq_status;        case MMC5_MULT_A:            return mapper->mult_result & 0xFF;        case MMC5_MULT_B:            return mapper->mult_result >> 8;        default:            return 0;        }    }    else if (addr >= 0x6000 && addr <= 0x7FFF)    {        // PRG RAM        if (cart->prg_ram)        {            return cart->prg_ram[addr - 0x6000];        }    }    else if (addr >= 0x8000 && addr <= 0xFFFF)    {        // PRG ROM        uint32_t bank = 0;        uint32_t offset = 0;        switch (mapper->prg_mode)        {        case 0: // 32KB            bank = mapper->prg_banks[4] >> 2;            offset = (addr - 0x8000) + (bank * 0x8000);            break;        case 1: // 16KB + 16KB            if (addr < 0xC000)            {                bank = mapper->prg_banks[2] >> 1;                offset = (addr - 0x8000) + (bank * 0x4000);            }            else            {                bank = mapper->prg_banks[4] >> 1;                offset = (addr - 0xC000) + (bank * 0x4000);            }            break;        case 2: // 16KB + 8KB + 8KB            if (addr < 0xC000)            {                bank = mapper->prg_banks[2] >> 1;                offset = (addr - 0x8000) + (bank * 0x4000);            }            else if (addr < 0xE000)            {                bank = mapper->prg_banks[3];                offset = (addr - 0xC000) + (bank * 0x2000);            }            else            {                bank = mapper->prg_banks[4];                offset = (addr - 0xE000) + (bank * 0x2000);            }            break;        case 3: // 8KB + 8KB + 8KB + 8KB            if (addr < 0xA000)            {                bank = mapper->prg_banks[0];                offset = (addr - 0x8000) + (bank * 0x2000);            }            else if (addr < 0xC000)            {                bank = mapper->prg_banks[1];                offset = (addr - 0xA000) + (bank * 0x2000);            }            else if (addr < 0xE000)            {                bank = mapper->prg_banks[2];                offset = (addr - 0xC000) + (bank * 0x2000);            }            else            {                bank = mapper->prg_banks[3];                offset = (addr - 0xE000) + (bank * 0x2000);            }            break;        }        if (offset < (uint32_t)cart->prg_rom_size)        {            return cart->prg_rom[offset];        }    }    return 0;}/** * @brief Escreve um byte na memória (acesso da CPU) */static void mapper_5_cpu_write(void *ctx, uint16_t addr, uint8_t val){    mapper5_t *mapper = (mapper5_t *)ctx;    nes_cartridge_t *cart = mapper->base.cart;    if (addr >= 0x5000 && addr <= 0x5FFF)    {        // Registradores do MMC5        switch (addr)        {        case MMC5_PRG_MODE:            mapper->prg_mode = val & 0x03;            break;        case MMC5_CHR_MODE:            mapper->chr_mode = val & 0x03;            break;        case MMC5_EXRAM_MODE:            mapper->exram_mode = val & 0x03;            break;        case MMC5_NAMETABLE_MODE:            mapper->nametable_mode = val;            break;        case MMC5_IRQ_SCANLINE:            mapper->irq_scanline = val;            break;        case MMC5_IRQ_STATUS:            mapper->irq_enable = val & 0x80;            mapper->irq_status &= ~0x80;            break;        case MMC5_MULT_A:            mapper->mult_a = val;            mapper->mult_result = mapper->mult_a * mapper->mult_b;            break;        case MMC5_MULT_B:            mapper->mult_b = val;            mapper->mult_result = mapper->mult_a * mapper->mult_b;            break;        // PRG banking        case MMC5_PRG_BANK_0:        case MMC5_PRG_BANK_1:        case MMC5_PRG_BANK_2:        case MMC5_PRG_BANK_3:        case MMC5_PRG_BANK_4:            mapper->prg_banks[addr - MMC5_PRG_BANK_0] = val;            break;        // CHR banking        case MMC5_CHR_BANK_0:        case MMC5_CHR_BANK_1:        case MMC5_CHR_BANK_2:        case MMC5_CHR_BANK_3:        case MMC5_CHR_BANK_4:        case MMC5_CHR_BANK_5:        case MMC5_CHR_BANK_6:        case MMC5_CHR_BANK_7:        case MMC5_CHR_BANK_8:        case MMC5_CHR_BANK_9:        case MMC5_CHR_BANK_10:        case MMC5_CHR_BANK_11:            mapper->chr_banks[addr - MMC5_CHR_BANK_0] = val;            break;        }    }    else if (addr >= 0x6000 && addr <= 0x7FFF)    {        // PRG RAM        if (cart->prg_ram)        {            cart->prg_ram[addr - 0x6000] = val;        }    }}/** * @brief Lê um byte da CHR ROM/RAM */static uint8_t mapper_5_chr_read(void *ctx, uint16_t addr){    mapper5_t *mapper = (mapper5_t *)ctx;    nes_cartridge_t *cart = mapper->base.cart;    uint32_t bank = 0;    uint32_t offset = 0;    switch (mapper->chr_mode)    {    case 0: // 8KB        bank = mapper->chr_banks[7];        offset = addr + (bank * 0x2000);        break;    case 1: // 4KB + 4KB        if (addr < 0x1000)        {            bank = mapper->chr_banks[3];            offset = addr + (bank * 0x1000);        }        else        {            bank = mapper->chr_banks[7];            offset = (addr - 0x1000) + (bank * 0x1000);        }        break;    case 2: // 2KB + 2KB + 2KB + 2KB        bank = mapper->chr_banks[addr >> 11];        offset = (addr & 0x7FF) + (bank * 0x800);        break;    case 3: // 1KB x 8        bank = mapper->chr_banks[addr >> 10];        offset = (addr & 0x3FF) + (bank * 0x400);        break;    }    if (cart->chr_rom && offset < cart->chr_rom_size)    {        return cart->chr_rom[offset];    }    else if (cart->chr_ram && offset < cart->chr_ram_size)    {        return cart->chr_ram[offset];    }    return 0;}/** * @brief Escreve um byte na CHR RAM */static void mapper_5_chr_write(void *ctx, uint16_t addr, uint8_t val){    mapper5_t *mapper = (mapper5_t *)ctx;    nes_cartridge_t *cart = mapper->base.cart;    if (cart->chr_ram)    {        uint32_t bank = 0;        uint32_t offset = 0;        switch (mapper->chr_mode)        {        case 0: // 8KB            bank = mapper->chr_banks[7];            offset = addr + (bank * 0x2000);            break;        case 1: // 4KB + 4KB            if (addr < 0x1000)            {                bank = mapper->chr_banks[3];                offset = addr + (bank * 0x1000);            }            else            {                bank = mapper->chr_banks[7];                offset = (addr - 0x1000) + (bank * 0x1000);            }            break;        case 2: // 2KB + 2KB + 2KB + 2KB            bank = mapper->chr_banks[addr >> 11];            offset = (addr & 0x7FF) + (bank * 0x800);            break;        case 3: // 1KB x 8            bank = mapper->chr_banks[addr >> 10];            offset = (addr & 0x3FF) + (bank * 0x400);            break;        }        if (offset < cart->chr_ram_size)        {            cart->chr_ram[offset] = val;        }    }}/** * @brief Processa um scanline */static void mapper_5_scanline(void *ctx){    mapper5_t *mapper = (mapper5_t *)ctx;    if (mapper->in_frame)    {        if (mapper->base.current_scanline == mapper->irq_scanline)        {            mapper->irq_status |= 0x80;            if (mapper->irq_enable)            {                // Gerar IRQ                nes_cpu_t *cpu = (nes_cpu_t *)mapper->base.cpu;                if (cpu)                {                    nes_cpu_trigger_irq(cpu);                }            }        }    }    // Atualiza o estado in_frame    if (mapper->base.current_scanline == 0)    {        mapper->in_frame = 1;    }    else if (mapper->base.current_scanline == 241)    {        mapper->in_frame = 0;    }}