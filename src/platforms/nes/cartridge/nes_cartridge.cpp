/** * @file nes_cartridge.cpp * @brief Implementação da classe NESCartridge para o Cartridge do NES em C++ * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-13 */#include "nes_cartridge.hpp"#include <stdexcept>#include <iostream>#include <cstring>#include "mappers/mapper0.hpp"#include "mappers/mapper1.hpp"namespace MegaEmu{    namespace Platforms    {        namespace NES        {            NESCartridge::NESCartridge()                : m_cartridge(nullptr), m_initialized(false), m_cpu(nullptr), m_mapper(nullptr)            {                // Alocar a estrutura de cartridge                m_cartridge = new nes_cartridge_t();                if (!m_cartridge)                {                    throw std::runtime_error("Falha ao alocar memória para NESCartridge");                }                // Inicializar a estrutura com zeros                std::memset(m_cartridge, 0, sizeof(nes_cartridge_t));                m_initialized = true;                std::cout << "NESCartridge criado" << std::endl;            }            NESCartridge::~NESCartridge()            {                if (m_cartridge)                {                    // Desligar o cartridge se estiver inicializado                    nes_cartridge_shutdown(m_cartridge);                    // Liberar a memória                    delete m_cartridge;                    m_cartridge = nullptr;                }                m_initialized = false;                std::cout << "NESCartridge destruído" << std::endl;            }            bool NESCartridge::loadROM(const std::string &romPath)            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("NESCartridge não está inicializado corretamente");                }                // Carregar a ROM usando a função C                int result = nes_cartridge_load(m_cartridge, romPath.c_str());                if (result != 0)                {                    std::cerr << "Erro ao carregar ROM: " << romPath << std::endl;                    return false;                }                // Obter informações da ROM                ROMInfo info = getInfo();                // Criar mapper apropriado com base no número do mapper                m_mapper = createMapper(info.mapperNumber, m_cartridge);                if (!m_mapper)                {                    std::cerr << "Erro ao criar mapper " << info.mapperNumber << std::endl;                    return false;                }                std::cout << "ROM carregada com sucesso: " << romPath << std::endl;                std::cout << "Tipo de mapper: " << info.mapperNumber << std::endl;                return true;            }            ROMInfo NESCartridge::getInfo() const            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de obter informações de NESCartridge não inicializado");                }                // Criar estrutura C para receber as informações                nes_rom_info_t cInfo;                std::memset(&cInfo, 0, sizeof(nes_rom_info_t));                // Obter informações usando a função C                int result = nes_cartridge_get_info(m_cartridge, &cInfo);                if (result != 0)                {                    throw std::runtime_error("Erro ao obter informações da ROM");                }                // Converter para a estrutura C++                return ROMInfo::fromNESRomInfo(cInfo);            }            void NESCartridge::reset()            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de resetar NESCartridge não inicializado");                }                nes_cartridge_reset(m_cartridge);                // Resetar também o mapper                if (m_mapper)                {                    m_mapper->reset();                }            }            uint8_t NESCartridge::cpuRead(uint16_t address) const            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de ler memória de NESCartridge não inicializado");                }                // Se o mapper estiver disponível, usar ele                if (m_mapper)                {                    return m_mapper->cpuRead(address);                }                // Fallback para a implementação C                return nes_cartridge_cpu_read(m_cartridge, address);            }            void NESCartridge::cpuWrite(uint16_t address, uint8_t value)            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de escrever memória em NESCartridge não inicializado");                }                // Se o mapper estiver disponível, usar ele                if (m_mapper)                {                    m_mapper->cpuWrite(address, value);                    return;                }                // Fallback para a implementação C                nes_cartridge_cpu_write(m_cartridge, address, value);            }            uint8_t NESCartridge::chrRead(uint16_t address) const            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de ler CHR de NESCartridge não inicializado");                }                // Se o mapper estiver disponível, usar ele                if (m_mapper)                {                    return m_mapper->chrRead(address);                }                // Fallback para a implementação C                return nes_cartridge_chr_read(m_cartridge, address);            }            void NESCartridge::chrWrite(uint16_t address, uint8_t value)            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de escrever CHR em NESCartridge não inicializado");                }                // Se o mapper estiver disponível, usar ele                if (m_mapper)                {                    m_mapper->chrWrite(address, value);                    return;                }                // Fallback para a implementação C                nes_cartridge_chr_write(m_cartridge, address, value);            }            void NESCartridge::scanline()            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de notificar scanline em NESCartridge não inicializado");                }                // Se o mapper estiver disponível, notificar scanline                if (m_mapper)                {                    m_mapper->scanline();                    return;                }                // Fallback para a implementação C                nes_cartridge_scanline(m_cartridge);            }            bool NESCartridge::saveSRAM(const std::string &savePath)            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de salvar SRAM de NESCartridge não inicializado");                }                return nes_cartridge_save_sram(m_cartridge, savePath.c_str()) == 0;            }            bool NESCartridge::loadSRAM(const std::string &savePath)            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de carregar SRAM para NESCartridge não inicializado");                }                return nes_cartridge_load_sram(m_cartridge, savePath.c_str()) == 0;            }            MirrorMode NESCartridge::getMirrorMode() const            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de obter modo de espelhamento de NESCartridge não inicializado");                }                // Se o mapper estiver disponível, usar ele                if (m_mapper)                {                    return m_mapper->getMirrorMode();                }                // Fallback para a implementação C                int mode = m_cartridge->mirror_mode;                switch (mode)                {                case NES_MIRROR_HORIZONTAL_FLAG:                    return MirrorMode::HORIZONTAL;                case NES_MIRROR_VERTICAL_FLAG:                    return MirrorMode::VERTICAL;                case NES_MIRROR_FOUR_SCREEN:                    return MirrorMode::FOUR_SCREEN;                default:                    return MirrorMode::HORIZONTAL;                }            }            void NESCartridge::setCPU(void *cpu)            {                m_cpu = cpu;            }            int NESCartridge::getMapperNumber() const            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de obter número do mapper de NESCartridge não inicializado");                }                return m_cartridge->mapper_number;            }            bool NESCartridge::hasBattery() const            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de verificar bateria de NESCartridge não inicializado");                }                return m_cartridge->has_battery != 0;            }            std::string NESCartridge::getROMPath() const            {                if (!m_initialized || !m_cartridge)                {                    throw std::runtime_error("Tentativa de obter caminho de ROM de NESCartridge não inicializado");                }                if (m_cartridge->rom_path)                {                    return std::string(m_cartridge->rom_path);                }                return "";            }            std::unique_ptr<IMapper> NESCartridge::createMapper(int mapperNumber, void *cartridge)            {                std::unique_ptr<IMapper> mapper = nullptr;                switch (mapperNumber)                {                case 0: // NROM                    mapper = std::make_unique<Mapper0>();                    break;                case 1: // MMC1                    mapper = std::make_unique<Mapper1>();                    break;                default:                    std::cerr << "Mapper " << mapperNumber << " não suportado" << std::endl;                    return nullptr;                }                // Inicializar o mapper                if (mapper && !mapper->initialize(cartridge))                {                    std::cerr << "Falha ao inicializar mapper " << mapperNumber << std::endl;                    return nullptr;                }                return mapper;            }        } // namespace NES    } // namespace Platforms} // namespace MegaEmu