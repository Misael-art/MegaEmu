/** * @file nes.cpp * @brief Implementação da classe NES para emulação do Nintendo Entertainment System * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-13 */#include "nes.hpp"#include <algorithm>#include <fstream>#include <iostream>#include <stdexcept>#include <memory>// Inclusão dos headers Cextern "C"{#include "nes_core.h"#include "../../core/core.h" // Para constantes e definições}// Inclusão dos componentes C++#include "cpu/nes_cpu.hpp"#include "ppu/nes_ppu.hpp"#include "apu/nes_apu.hpp"#include "cartridge/nes_cartridge.hpp"namespace MegaEmu{    namespace Platforms    {        NES::NES()            : m_nesState(nullptr), m_cpu(nullptr), m_ppu(nullptr), m_apu(nullptr), m_cartridge(nullptr), m_screenWidth(256), m_screenHeight(240), m_isInitialized(false), m_isRomLoaded(false)        {            // Inicializar buffer de vídeo            m_videoBuffer.resize(m_screenWidth * m_screenHeight, 0);            // Inicializar estados de controle            for (auto &state : m_controllerStates)            {                std::memset(&state, 0, sizeof(Core::ControllerState));            }            std::cout << "Instância de NES criada" << std::endl;        }        NES::~NES()        {            // Limpar componentes C++            m_cartridge.reset();            m_apu.reset();            m_ppu.reset();            m_cpu.reset();            // Limpar recursos C se ainda não foram liberados            if (m_nesState)            {                nes_destroy(m_nesState);                m_nesState = nullptr;            }            m_isInitialized = false;            m_isRomLoaded = false;            std::cout << "Instância de NES destruída" << std::endl;        }        bool NES::initialize()        {            if (m_isInitialized)            {                // Já inicializado                return true;            }            try            {                // Inicializar componentes C++                if (!initializeComponents())                {                    std::cerr << "Falha ao inicializar componentes C++ do NES" << std::endl;                    return false;                }                // Conectar componentes entre si                if (!connectComponents())                {                    std::cerr << "Falha ao conectar componentes do NES" << std::endl;                    return false;                }                m_isInitialized = true;                std::cout << "NES inicializado com sucesso" << std::endl;                return true;            }            catch (const std::exception &e)            {                std::cerr << "Exceção durante inicialização do NES: " << e.what() << std::endl;                return false;            }        }        bool NES::initializeComponents()        {            // Criar e inicializar componentes em ordem apropriada            try            {                // Criar PPU                m_ppu = std::make_unique<NES::NESPPU>();                if (!m_ppu)                {                    std::cerr << "Falha ao criar PPU" << std::endl;                    return false;                }                // Criar CPU                m_cpu = std::make_unique<NES::NESCPU>(nullptr); // Inicializar sem memória ainda                if (!m_cpu)                {                    std::cerr << "Falha ao criar CPU" << std::endl;                    return false;                }                // Criar APU                m_apu = std::make_unique<NES::NESAPU>();                if (!m_apu)                {                    std::cerr << "Falha ao criar APU" << std::endl;                    return false;                }                // Criar Cartridge                m_cartridge = std::make_unique<NES::NESCartridge>();                if (!m_cartridge)                {                    std::cerr << "Falha ao criar Cartridge" << std::endl;                    return false;                }                return true;            }            catch (const std::exception &e)            {                std::cerr << "Exceção ao inicializar componentes: " << e.what() << std::endl;                return false;            }        }        bool NES::connectComponents()        {            // Conectar componentes entre si            try            {                // Conectar CPU ao Cartridge                m_cartridge->setCPU(m_cpu.get());                // Inicializar cada componente                m_cpu->initialize();                m_ppu->initialize();                m_apu->initialize();                return true;            }            catch (const std::exception &e)            {                std::cerr << "Exceção ao conectar componentes: " << e.what() << std::endl;                return false;            }        }        std::string NES::getPlatformName() const        {            return "NES";        }        bool NES::loadROM(const std::string &filename)        {            if (!m_isInitialized)            {                std::cerr << "Tentativa de carregar ROM sem inicializar NES" << std::endl;                return false;            }            try            {                // Abrir arquivo                std::ifstream file(filename, std::ios::binary | std::ios::ate);                if (!file)                {                    std::cerr << "Falha ao abrir arquivo: " << filename << std::endl;                    return false;                }                // Determinar tamanho e ler conteúdo                std::streamsize size = file.tellg();                file.seekg(0, std::ios::beg);                m_romData.resize(size);                if (!file.read(reinterpret_cast<char *>(m_romData.data()), size))                {                    std::cerr << "Falha ao ler arquivo ROM" << std::endl;                    return false;                }                // Carregar ROM no cartridge                if (!m_cartridge->loadROM(filename))                {                    std::cerr << "Falha ao carregar ROM no cartridge" << std::endl;                    return false;                }                // Resetar todos os componentes após carregar ROM                m_cpu->reset();                m_ppu->reset();                m_apu->reset();                m_isRomLoaded = true;                std::cout << "ROM carregada com sucesso: " << filename << std::endl;                return true;            }            catch (const std::exception &e)            {                std::cerr << "Exceção ao carregar ROM: " << e.what() << std::endl;                m_isRomLoaded = false;                return false;            }        }        bool NES::runFrame()        {            if (!m_isInitialized || !m_isRomLoaded)            {                return false;            }            // Atualizar estados de controle            for (int i = 0; i < 2; ++i)            {                nes_update_controller(m_nesState, &m_controllerStates[i], i);            }            try            {                // Executar ciclos para um quadro completo                int targetCycles = NES_NTSC_CYCLES_PER_FRAME; // Para NTSC                int cycles = 0;                while (cycles < targetCycles)                {                    // Ciclo da CPU                    m_cpu->cycle();                    // 3 ciclos de PPU para cada ciclo de CPU                    for (int i = 0; i < 3; i++)                    {                        m_ppu->cycle();                    }                    // Ciclo da APU a cada 2 ciclos de CPU                    if (cycles % 2 == 0)                    {                        m_apu->cycle();                    }                    cycles++;                }                // Copiar buffer de vídeo da PPU                const uint32_t *frameBuffer = m_ppu->getFrameBuffer();                if (frameBuffer)                {                    std::memcpy(m_videoBuffer.data(), frameBuffer, m_videoBuffer.size() * sizeof(uint32_t));                }                return true;            }            catch (const std::exception &e)            {                std::cerr << "Exceção durante execução de quadro: " << e.what() << std::endl;                return false;            }        }        const uint32_t *NES::getVideoBuffer() const        {            return m_videoBuffer.data();        }        int NES::getScreenWidth() const        {            return m_screenWidth;        }        int NES::getScreenHeight() const        {            return m_screenHeight;        }        void NES::updateControllerState(int index, const Core::ControllerState &state)        {            if (index >= 0 && index < 2)            {                m_controllerStates[index] = state;            }        }        bool NES::saveState(const std::string &filename)        {            if (!m_isInitialized || !m_isRomLoaded)            {                std::cerr << "Tentativa de salvar estado sem ROM carregada" << std::endl;                return false;            }            try            {                // Implementação para salvar o estado                // TODO: Implementar usando as classes C++                return false;            }            catch (const std::exception &e)            {                std::cerr << "Exceção ao salvar estado: " << e.what() << std::endl;                return false;            }        }        bool NES::loadState(const std::string &filename)        {            if (!m_isInitialized || !m_isRomLoaded)            {                std::cerr << "Tentativa de carregar estado sem ROM carregada" << std::endl;                return false;            }            try            {                // Implementação para carregar o estado                // TODO: Implementar usando as classes C++                return false;            }            catch (const std::exception &e)            {                std::cerr << "Exceção ao carregar estado: " << e.what() << std::endl;                return false;            }        }    } // namespace Platforms} // namespace MegaEmu