/** * @file nes_apu.c * @brief Implementação da Audio Processing Unit (APU) do NES */#include <stdlib.h>#include <string.h>#include <stdio.h>#include <math.h>#include "nes_apu.h"#include "../nes.h"#include "utils/enhanced_log.h"// Definição da categoria de log para o APU#define EMU_LOG_CAT_APU NES_LOG_CAT_APU// Macros de log específicas para o APU#define APU_LOG_ERROR(...) EMU_LOG_ERROR(EMU_LOG_CAT_APU, __VA_ARGS__)#define APU_LOG_WARN(...) EMU_LOG_WARN(EMU_LOG_CAT_APU, __VA_ARGS__)#define APU_LOG_WARNING(...) EMU_LOG_WARN(EMU_LOG_CAT_APU, __VA_ARGS__) // Alias para WARN#define APU_LOG_INFO(...) EMU_LOG_INFO(EMU_LOG_CAT_APU, __VA_ARGS__)#define APU_LOG_DEBUG(...) EMU_LOG_DEBUG(EMU_LOG_CAT_APU, __VA_ARGS__)#define APU_LOG_TRACE(...) EMU_LOG_TRACE(EMU_LOG_CAT_APU, __VA_ARGS__)// Macro genérica para compatibilidade#define APU_LOG(level, ...) EMU_LOG_##level(EMU_LOG_CAT_APU, __VA_ARGS__)// Protótipos de funções estáticasstatic void nes_apu_internal_init(void);static void nes_apu_internal_shutdown(void);static void nes_apu_internal_reset(void);static void nes_apu_step(nes_apu_t *apu);static void nes_apu_clock_envelope_and_linear(nes_apu_t *apu);static void nes_apu_clock_length_and_sweep(nes_apu_t *apu);static void nes_apu_clock_timers(nes_apu_t *apu);static int16_t nes_apu_mix(nes_apu_t *apu);// Estrutura interna da APUstatic struct{    // Canais de áudio    struct    {        // Pulse 1        struct        {            uint8_t duty_mode;            uint8_t length_counter;            uint16_t timer;            uint8_t volume;            uint8_t envelope;            uint8_t sweep;            uint8_t enabled;        } pulse1;        // Pulse 2        struct        {            uint8_t duty_mode;            uint8_t length_counter;            uint16_t timer;            uint8_t volume;            uint8_t envelope;            uint8_t sweep;            uint8_t enabled;        } pulse2;        // Triangle        struct        {            uint8_t length_counter;            uint16_t timer;            uint8_t linear_counter;            uint8_t enabled;        } triangle;        // Noise        struct        {            uint8_t length_counter;            uint16_t timer;            uint8_t volume;            uint8_t envelope;            uint16_t shift_register;            uint8_t enabled;        } noise;        // DMC        struct        {            uint16_t sample_address;            uint16_t sample_length;            uint8_t output_level;            uint8_t sample_buffer;            uint8_t bits_remaining;            uint8_t enabled;        } dmc;    } channels;    // Estado global    uint8_t frame_counter;    uint8_t frame_sequence;    uint8_t irq_inhibit;    uint8_t dmc_irq;    uint8_t status_register;} apu;// Tabelas de lookup para frequências e períodosstatic const uint16_t pulse_period_table[32] = {    0x004, 0x008, 0x00C, 0x010, 0x014, 0x018, 0x01C, 0x020,    0x028, 0x030, 0x038, 0x040, 0x050, 0x060, 0x070, 0x080,    0x0A0, 0x0C0, 0x0E0, 0x100, 0x140, 0x180, 0x1C0, 0x200,    0x280, 0x300, 0x380, 0x400, 0x500, 0x600, 0x700, 0x800};static const uint16_t noise_period_table[16] = {    0x004, 0x008, 0x010, 0x020, 0x040, 0x060, 0x080, 0x0A0,    0x0CA, 0x0FE, 0x17C, 0x1FC, 0x2FA, 0x3F8, 0x7F2, 0xFE4};static const uint16_t dmc_rate_table[16] = {    0x1AC, 0x17C, 0x154, 0x140, 0x11E, 0x0FE, 0x0E2, 0x0D6,    0x0BE, 0x0A0, 0x08E, 0x080, 0x06A, 0x054, 0x048, 0x036};// Padrões de duty cycle para canais pulsestatic const uint8_t duty_table[4][8] = {    {0, 0, 0, 0, 0, 0, 0, 1}, // 12.5%    {0, 0, 0, 0, 0, 0, 1, 1}, // 25%    {0, 0, 0, 0, 1, 1, 1, 1}, // 50%    {1, 1, 1, 1, 1, 1, 0, 0}  // 75% (negativo de 25%)};// Sequência do canal trianglestatic const uint8_t triangle_sequence[32] = {    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};// Funções auxiliaresstatic void update_length_counter(uint8_t channel, uint8_t value){    switch (channel)    {    case 0: // Pulse 1        apu.channels.pulse1.length_counter = value;        break;    case 1: // Pulse 2        apu.channels.pulse2.length_counter = value;        break;    case 2: // Triangle        apu.channels.triangle.length_counter = value;        break;    case 3: // Noise        apu.channels.noise.length_counter = value;        break;    }}static void update_volume_envelope(uint8_t channel, uint8_t value){    switch (channel)    {    case 0: // Pulse 1        apu.channels.pulse1.volume = value & 0x0F;        apu.channels.pulse1.envelope = value;        break;    case 1: // Pulse 2        apu.channels.pulse2.volume = value & 0x0F;        apu.channels.pulse2.envelope = value;        break;    case 3: // Noise        apu.channels.noise.volume = value & 0x0F;        apu.channels.noise.envelope = value;        break;    }}static void update_sweep(uint8_t channel, uint8_t value){    switch (channel)    {    case 0: // Pulse 1        apu.channels.pulse1.sweep = value;        break;    case 1: // Pulse 2        apu.channels.pulse2.sweep = value;        break;    }}static void update_timer(uint8_t channel, uint16_t value){    switch (channel)    {    case 0: // Pulse 1        apu.channels.pulse1.timer = value;        break;    case 1: // Pulse 2        apu.channels.pulse2.timer = value;        break;    case 2: // Triangle        apu.channels.triangle.timer = value;        break;    case 3: // Noise        apu.channels.noise.timer = value;        break;    }}// Funções públicasvoid nes_apu_internal_init_static(void){    // Inicializa a estrutura da APU com zeros    memset(&apu, 0, sizeof(apu));    // Inicializa os canais de áudio    apu.channels.pulse1.enabled = 0;    apu.channels.pulse2.enabled = 0;    apu.channels.triangle.enabled = 0;    apu.channels.noise.enabled = 0;    apu.channels.dmc.enabled = 0;}/** * @brief Inicializa o estado interno da APU */static void nes_apu_internal_init(void){    memset(&apu, 0, sizeof(apu));    apu.channels.noise.shift_register = 1;}/** * @brief Desliga o sistema de áudio do NES */static void nes_apu_internal_shutdown(void){    // Desligamos todos os canais    apu.status_register = 0;}static void nes_apu_internal_reset(void){    memset(&apu, 0, sizeof(apu));}void nes_apu_cycle(void){    // Atualização do frame counter    apu.frame_counter++;    if (apu.frame_counter >= 7457)    { // 60Hz        apu.frame_counter = 0;        apu.frame_sequence = (apu.frame_sequence + 1) & 0x03;        // Atualização dos canais baseada no frame sequence        switch (apu.frame_sequence)        {        case 0: // Quarter frame            // Atualização de envelopes            break;        case 1: // Half frame            // Atualização de length counters e sweep            break;        case 2: // Quarter frame            // Atualização de envelopes            break;        case 3: // Half frame            // Atualização de length counters e sweep            break;        }    }}uint8_t nes_apu_read(uint16_t addr){    switch (addr)    {    case NES_APU_STATUS_REG:        return apu.status_register;    default:        return 0;    }}void nes_apu_write(uint16_t addr, uint8_t value){    switch (addr)    {    case NES_APU_PULSE1_DUTY:        apu.channels.pulse1.duty_mode = value >> 6;        update_length_counter(0, value & 0x1F);        break;    case NES_APU_PULSE1_SWEEP:        update_sweep(0, value);        break;    case NES_APU_PULSE1_TIMER_LOW:        update_timer(0, (apu.channels.pulse1.timer & 0xFF00) | value);        break;    case NES_APU_PULSE1_TIMER_HIGH:        update_timer(0, (apu.channels.pulse1.timer & 0x00FF) | (value << 8));        update_length_counter(0, value >> 3);        update_volume_envelope(0, value);        break;    case NES_APU_PULSE2_DUTY:        apu.channels.pulse2.duty_mode = value >> 6;        update_length_counter(1, value & 0x1F);        break;    case NES_APU_PULSE2_SWEEP:        update_sweep(1, value);        break;    case NES_APU_PULSE2_TIMER_LOW:        update_timer(1, (apu.channels.pulse2.timer & 0xFF00) | value);        break;    case NES_APU_PULSE2_TIMER_HIGH:        update_timer(1, (apu.channels.pulse2.timer & 0x00FF) | (value << 8));        update_length_counter(1, value >> 3);        update_volume_envelope(1, value);        break;    case NES_APU_TRIANGLE_LINEAR:        apu.channels.triangle.linear_counter = value;        break;    case NES_APU_TRIANGLE_TIMER_LOW:        update_timer(2, (apu.channels.triangle.timer & 0xFF00) | value);        break;    case NES_APU_TRIANGLE_TIMER_HIGH:        update_timer(2, (apu.channels.triangle.timer & 0x00FF) | (value << 8));        update_length_counter(2, value >> 3);        break;    case NES_APU_NOISE_VOLUME:        update_volume_envelope(3, value);        break;    case NES_APU_NOISE_PERIOD:        update_timer(3, value & 0x0F);        break;    case NES_APU_NOISE_LENGTH:        update_length_counter(3, value >> 3);        break;    case NES_APU_DMC_FREQ:        // Implementação do DMC        break;    case NES_APU_DMC_RAW:        apu.channels.dmc.output_level = value & 0x7F;        break;    case NES_APU_DMC_START:        apu.channels.dmc.sample_address = 0xC000 | (value << 6);        break;    case NES_APU_DMC_LENGTH:        apu.channels.dmc.sample_length = (value << 4) | 1;        break;    case NES_APU_FRAME_COUNTER:        apu.frame_counter = value;        apu.irq_inhibit = value & 0x40;        break;    }}void nes_apu_get_sample(int16_t *left, int16_t *right){    // Implementação da geração de amostras de áudio    // Por enquanto, retorna silêncio    *left = 0;    *right = 0;}/** * @brief Inicializa o subsistema de APU do NES * * @param cpu Ponteiro para a CPU * @param memory Ponteiro para o subsistema de memória * @param sample_rate Taxa de amostragem desejada para o áudio * @return nes_apu_t* Ponteiro para a APU inicializada, ou NULL em caso de erro */nes_apu_t *nes_apu_init(void *cpu, void *memory, int sample_rate){    APU_LOG_INFO("Inicializando subsistema de APU do NES");    // Aloca a estrutura principal    nes_apu_t *apu = (nes_apu_t *)malloc(sizeof(nes_apu_t));    if (!apu)    {        APU_LOG_ERROR("nes_apu_init: falha na alocação de memória para a APU");        return NULL;    }    // Inicializa a estrutura com zeros    memset(apu, 0, sizeof(nes_apu_t));    // Atribui os ponteiros externos    apu->cpu = cpu;    apu->memory = memory;    // Configura a taxa de amostragem    apu->sample_rate = sample_rate;    apu->cycles_per_sample = NES_CPU_CLOCK_RATE / sample_rate;    // Calcula o tamanho do buffer de áudio para aproximadamente 1 frame em 60Hz    apu->buffer_size = sample_rate / 60;    // Aloca o buffer de áudio    apu->buffer = (int16_t *)malloc(apu->buffer_size * sizeof(int16_t));    if (!apu->buffer)    {        APU_LOG_ERROR("nes_apu_init: falha na alocação do buffer de áudio");        free(apu);        return NULL;    }    memset(apu->buffer, 0, apu->buffer_size * sizeof(int16_t));    // Inicializa as variáveis de canais    apu->frame_counter = 0;    apu->frame_counter_mode = 0;    apu->frame_irq_enabled = 1;    apu->dmc_irq_enabled = 0;    apu->frame_irq_flag = 0;    apu->dmc_irq_flag = 0;    apu->buffer_index = 0;    apu->cycle_counter = 0;    APU_LOG_INFO("Subsistema de APU do NES inicializado com sucesso (sample_rate: %d Hz)", sample_rate);    return apu;}/** * @brief Finaliza e libera recursos do subsistema de APU * * @param apu Ponteiro para a APU */void nes_apu_shutdown(nes_apu_t *apu){    if (!apu)    {        APU_LOG_WARNING("nes_apu_shutdown: APU já está desligada");        return;    }    APU_LOG_INFO("Desligando subsistema de APU do NES");    // Libera o buffer de áudio    if (apu->buffer)    {        free(apu->buffer);    }    // Libera a estrutura principal    free(apu);}/** * @brief Reseta o estado da APU * * @param apu Ponteiro para a APU */void nes_apu_reset(nes_apu_t *apu){    if (!apu)    {        APU_LOG_ERROR("nes_apu_reset: APU inválida");        return;    }    APU_LOG_INFO("Resetando subsistema de APU do NES");    // Reset do estado geral    apu->cycle_counter = 0;    apu->frame_counter = 0;    apu->frame_counter_mode = 0;    apu->frame_irq_enabled = 1;    apu->dmc_irq_enabled = 0;    apu->frame_irq_flag = 0;    apu->dmc_irq_flag = 0;    apu->buffer_index = 0;    APU_LOG_DEBUG("APU resetada");}/** * @brief Atualiza o estado da APU por um número de ciclos * * @param apu Ponteiro para a APU * @param cycles Número de ciclos a executar */void nes_apu_update(nes_apu_t *apu, int cycles){    if (!apu)    {        APU_LOG_ERROR("nes_apu_update: APU inválida");        return;    }    // Gera amostras quando necessário    apu->cycle_counter += cycles;    while (apu->cycle_counter >= apu->cycles_per_sample)    {        apu->cycle_counter -= apu->cycles_per_sample;        // Gera uma amostra e a adiciona ao buffer        if (apu->buffer_index < apu->buffer_size)        {            apu->buffer[apu->buffer_index++] = 0; // Silêncio por enquanto        }    }}/** * @brief Executa um único ciclo da APU * * @param apu Ponteiro para a APU */static void nes_apu_step(nes_apu_t *apu){    if (!apu)    {        return;    }    // Atualiza o contador de frame    apu->frame_counter++;    // Modo 0: 4-Step Sequence (padrão)    if (apu->frame_counter_mode == 0)    {        switch (apu->frame_counter % 14915)        {        case 3728: // Passo 1: Envelope e Linear Counter            nes_apu_clock_envelope_and_linear(apu);            break;        case 7456: // Passo 2: Envelope, Linear Counter e Length Counter e Sweep            nes_apu_clock_envelope_and_linear(apu);            nes_apu_clock_length_and_sweep(apu);            break;        case 11185: // Passo 3: Envelope e Linear Counter            nes_apu_clock_envelope_and_linear(apu);            break;        case 14914: // Passo 4: Envelope, Linear Counter, Length Counter e Sweep + IRQ            nes_apu_clock_envelope_and_linear(apu);            nes_apu_clock_length_and_sweep(apu);            // Gera IRQ se habilitado            if (!apu->frame_irq_enabled)            {                apu->frame_irq_flag = 1;                // Trigger IRQ na CPU se disponível                // if (apu->cpu && apu->cpu->trigger_irq)                // {                //     apu->cpu->trigger_irq(apu->cpu);                // }            }            break;        }    }    // Modo 1: 5-Step Sequence    else    {        switch (apu->frame_counter % 18640)        {        case 3728: // Passo 1: Envelope e Linear Counter            nes_apu_clock_envelope_and_linear(apu);            break;        case 7456: // Passo 2: Envelope, Linear Counter e Length Counter e Sweep            nes_apu_clock_envelope_and_linear(apu);            nes_apu_clock_length_and_sweep(apu);            break;        case 11185: // Passo 3: Envelope e Linear Counter            nes_apu_clock_envelope_and_linear(apu);            break;        case 14914: // Passo 4: Envelope, Linear Counter, Length Counter e Sweep            nes_apu_clock_envelope_and_linear(apu);            nes_apu_clock_length_and_sweep(apu);            break;            // No modo 5-step, não ocorre IRQ e há um passo extra        }    }    // Atualiza os timers dos canais    nes_apu_clock_timers(apu);}/** * @brief Gera amostras de áudio para um buffer externo * * @param apu Ponteiro para a APU * @param buffer Buffer para receber as amostras * @param buffer_size Tamanho do buffer em número de amostras * @return int Número de amostras geradas */int nes_apu_generate_samples(nes_apu_t *apu, int16_t *buffer, int buffer_size){    if (!apu || !buffer || buffer_size <= 0)    {        APU_LOG_ERROR("nes_apu_generate_samples: parâmetros inválidos");        return -1;    }    // Proteção contra buffer overflow    int samples_to_copy = (buffer_size < apu->buffer_index) ? buffer_size : apu->buffer_index;    // Copia as amostras geradas para o buffer de saída    memcpy(buffer, apu->buffer, samples_to_copy * sizeof(int16_t));    // Limpa o buffer interno após copiar    memset(apu->buffer, 0, apu->buffer_size * sizeof(int16_t));    apu->buffer_index = 0;    return samples_to_copy;}/** * @brief Mistura os canais de áudio para gerar uma amostra * * @param apu Ponteiro para a APU * @return int16_t Amostra de áudio misturada */static int16_t nes_apu_mix(nes_apu_t *apu){    if (!apu)    {        return 0;    }    // Saída de cada canal    float pulse_out = 0;    float tnd_out = 0;    // Calcula saída dos canais de pulso    float pulse1 = apu->pulse[0].enabled ? apu->pulse[0].volume : 0;    float pulse2 = apu->pulse[1].enabled ? apu->pulse[1].volume : 0;    if (pulse1 + pulse2 > 0)    {        pulse_out = 95.88 / ((8128.0 / (pulse1 + pulse2)) + 100.0);    }    // Calcula saída dos canais de triângulo, ruído e DMC    float triangle = apu->triangle.enabled ? 8.0 : 0;    float noise = apu->noise.enabled ? apu->noise.volume : 0;    float dmc = apu->dmc.enabled ? apu->dmc.output_level : 0;    if (triangle + noise + dmc > 0)    {        tnd_out = 159.79 / ((1.0 / ((triangle / 8227.0) + (noise / 12241.0) + (dmc / 22638.0))) + 100.0);    }    // Mistura e converte para int16_t    float output = pulse_out + tnd_out;    return (int16_t)(output * 32767);}/** * @brief Atualiza os envelopes e o contador linear * * @param apu Ponteiro para a APU */static void nes_apu_clock_envelope_and_linear(nes_apu_t *apu){    if (!apu)    {        return;    }    // Envelope para os canais de pulso    for (int i = 0; i < 2; i++)    {        if (apu->pulse[i].envelope_start)        {            apu->pulse[i].envelope_start = 0;            apu->pulse[i].envelope_counter = 15;            apu->pulse[i].envelope_value = apu->pulse[i].envelope_period;        }        else if (apu->pulse[i].envelope_value > 0)        {            apu->pulse[i].envelope_value--;        }        else        {            apu->pulse[i].envelope_value = apu->pulse[i].envelope_period;            if (apu->pulse[i].envelope_counter > 0)            {                apu->pulse[i].envelope_counter--;            }            else if (apu->pulse[i].length_counter > 0) // Loop do envelope            {                apu->pulse[i].envelope_counter = 15;            }        }    }    // Envelope para o canal de ruído    if (apu->noise.envelope_start)    {        apu->noise.envelope_start = 0;        apu->noise.envelope_counter = 15;        apu->noise.envelope_value = apu->noise.envelope_period;    }    else if (apu->noise.envelope_value > 0)    {        apu->noise.envelope_value--;    }    else    {        apu->noise.envelope_value = apu->noise.envelope_period;        if (apu->noise.envelope_counter > 0)        {            apu->noise.envelope_counter--;        }        else if (apu->noise.length_counter > 0) // Loop do envelope        {            apu->noise.envelope_counter = 15;        }    }    // Linear counter para o triângulo    if (apu->triangle.linear_counter_reload_flag)    {        apu->triangle.linear_counter = apu->triangle.linear_counter_reload;    }    else if (apu->triangle.linear_counter > 0)    {        apu->triangle.linear_counter--;    }    // Limpa a flag de reload se o bit de controle estiver desativado    if (!apu->triangle.control)    {        apu->triangle.linear_counter_reload_flag = 0;    }}/** * @brief Atualiza os contadores de comprimento e sweep * * @param apu Ponteiro para a APU */static void nes_apu_clock_length_and_sweep(nes_apu_t *apu){    if (!apu)    {        return;    }    // Length counters para todos os canais    for (int i = 0; i < 2; i++)    {        if (apu->pulse[i].length_counter > 0 && !apu->pulse[i].length_counter_halt)        {            apu->pulse[i].length_counter--;        }    }    if (apu->triangle.length_counter > 0 && !apu->triangle.length_counter_halt)    {        apu->triangle.length_counter--;    }    if (apu->noise.length_counter > 0 && !apu->noise.length_counter_halt)    {        apu->noise.length_counter--;    }    // Sweep para os canais de pulso    for (int i = 0; i < 2; i++)    {        if (apu->pulse[i].sweep_reload)        {            apu->pulse[i].sweep_counter = apu->pulse[i].sweep_period;            apu->pulse[i].sweep_reload = 0;        }        else if (apu->pulse[i].sweep_counter > 0)        {            apu->pulse[i].sweep_counter--;        }        else        {            apu->pulse[i].sweep_counter = apu->pulse[i].sweep_period;            if (apu->pulse[i].sweep_enabled && apu->pulse[i].timer_period >= 8)            {                // Calcula o período de destino                uint16_t target_period = apu->pulse[i].timer_period >> apu->pulse[i].sweep_shift;                if (apu->pulse[i].sweep_negate)                {                    if (i == 0)                    {                        target_period = apu->pulse[i].timer_period - target_period - 1;                    }                    else                    {                        target_period = apu->pulse[i].timer_period - target_period;                    }                }                else                {                    target_period = apu->pulse[i].timer_period + target_period;                }                // Verifica se o período de destino está no intervalo válido                if (target_period < 0x800 && apu->pulse[i].timer_period >= 8)                {                    apu->pulse[i].timer_period = target_period;                }            }        }    }}/** * @brief Atualiza os timers dos canais * * @param apu Ponteiro para a APU */static void nes_apu_clock_timers(nes_apu_t *apu){    if (!apu)    {        return;    }    // Timers dos canais de pulso    for (int i = 0; i < 2; i++)    {        if (apu->pulse[i].timer_value > 0)        {            apu->pulse[i].timer_value--;        }        else        {            apu->pulse[i].timer_value = apu->pulse[i].timer_period;            apu->pulse[i].duty_step = (apu->pulse[i].duty_step + 1) % 8;        }    }    // Timer do canal de triângulo    if (apu->triangle.timer_value > 0)    {        apu->triangle.timer_value--;    }    else    {        apu->triangle.timer_value = apu->triangle.timer_period;        if (apu->triangle.linear_counter > 0 && apu->triangle.length_counter > 0)        {            apu->triangle.duty_step = (apu->triangle.duty_step + 1) % 32;        }    }    // Timer do canal de ruído    if (apu->noise.timer_value > 0)    {        apu->noise.timer_value--;    }    else    {        apu->noise.timer_value = apu->noise.period;        // Atualiza o shift register do gerador de ruído        uint16_t feedback = (apu->noise.shift_register & 1) ^ ((apu->noise.shift_register >> (apu->noise.mode ? 6 : 1)) & 1);        apu->noise.shift_register = (apu->noise.shift_register >> 1) | (feedback << 14);    }    // Timer do canal DMC (simplificado)    if (apu->dmc.enabled && apu->dmc.bytes_remaining > 0)    {        if (apu->dmc.bits_remaining == 0)        {            // Carrega um novo byte            if (apu->memory)            {                // apu->dmc.shift_register = nes_memory_read(apu->memory, apu->dmc.current_address);                apu->dmc.current_address = (apu->dmc.current_address + 1) & 0xFFFF;                if (apu->dmc.current_address == 0)                {                    apu->dmc.current_address = 0x8000;                }                apu->dmc.bits_remaining = 8;                apu->dmc.bytes_remaining--;                // Se acabaram os bytes e loop está ativado, reinicia                if (apu->dmc.bytes_remaining == 0)                {                    if (apu->dmc.loop)                    {                        apu->dmc.current_address = apu->dmc.sample_address;                        apu->dmc.bytes_remaining = apu->dmc.sample_length;                    }                    else if (apu->dmc.irq_enabled)                    {                        apu->dmc.irq_flag = 1;                        // Trigger IRQ na CPU se disponível                        // if (apu->cpu && apu->cpu->trigger_irq)                        // {                        //     apu->cpu->trigger_irq(apu->cpu);                        // }                    }                }            }        }        // Processa um bit do sample DMC        if (apu->dmc.bits_remaining > 0 && apu->dmc.timer_value == 0)        {            apu->dmc.timer_value = apu->dmc.frequency;            if (!apu->dmc.silence)            {                if (apu->dmc.shift_register & 1)                {                    if (apu->dmc.output_level <= 125)                    {                        apu->dmc.output_level += 2;                    }                }                else                {                    if (apu->dmc.output_level >= 2)                    {                        apu->dmc.output_level -= 2;                    }                }            }            apu->dmc.shift_register >>= 1;            apu->dmc.bits_remaining--;        }    }}/** * @brief Verifica se uma interrupção de APU ocorreu * * @param apu Ponteiro para a APU * @return int 1 se uma interrupção ocorreu, 0 caso contrário */int nes_apu_irq_occurred(nes_apu_t *apu){    if (!apu)    {        APU_LOG_ERROR("nes_apu_irq_occurred: apu é NULL");        return 0;    }    return (apu->frame_irq_flag || apu->dmc_irq_flag) ? 1 : 0;}/** * @brief Executa um frame inteiro da APU * * @param apu Ponteiro para a APU */void nes_apu_run_frame(nes_apu_t *apu){    if (!apu)    {        APU_LOG_ERROR("nes_apu_run_frame: apu é NULL");        return;    }    // Executa um passo de frame counter (60Hz)    apu->frame_step = (apu->frame_step + 1) % 4;    // Atualiza contadores de comprimento a cada passo 1 ou 3    if (apu->frame_step == 1 || apu->frame_step == 3)    {        nes_apu_clock_length_and_sweep(apu);    }    // Atualiza envelopes e contador linear a cada passo    nes_apu_clock_envelope_and_linear(apu);    // Gera IRQ no passo 3 se não inibido    if (apu->frame_step == 3 && !apu->frame_counter_irq_inhibit)    {        apu->frame_irq_flag = true;    }}/** * @brief Limpa o buffer de saída da APU * * @param apu Ponteiro para a APU */void nes_apu_clear_buffer(nes_apu_t *apu){    if (!apu || !apu->output_buffer)    {        APU_LOG_ERROR("nes_apu_clear_buffer: apu ou buffer é NULL");        return;    }    memset(apu->output_buffer, 0, apu->buffer_size * sizeof(float));    apu->buffer_position = 0;    apu->buffer_full = false;}/** * @brief Verifica se há um IRQ pendente da APU * * @param apu Ponteiro para a APU * @return bool Verdadeiro se há IRQ pendente, falso caso contrário */bool nes_apu_irq_pending(const nes_apu_t *apu){    if (!apu)    {        APU_LOG_ERROR("nes_apu_irq_pending: apu é NULL");        return false;    }    return (apu->frame_irq_flag && apu->frame_irq_enabled) ||           (apu->dmc_irq_flag && apu->dmc_irq_enabled);}/** * @brief Reconhece e limpa flags de IRQ pendentes * * @param apu Ponteiro para a APU */void nes_apu_acknowledge_irq(nes_apu_t *apu){    if (!apu)    {        APU_LOG_ERROR("nes_apu_acknowledge_irq: apu é NULL");        return;    }    apu->frame_irq_flag = false;    // DMC IRQ só é limpo quando o canal é desligado ou amostra é concluída}/** * @brief Lê um registrador da APU * * @param apu Ponteiro para a APU * @param address Endereço do registrador (0x4000-0x4017) * @return uint8_t Valor lido */uint8_t nes_apu_read_register(nes_apu_t *apu, uint16_t address){    if (!apu)    {        APU_LOG_ERROR("nes_apu_read_register: apu é NULL");        return 0;    }    // Apenas o registrador de status é legível    if (address == NES_APU_STATUS_REG)    {        uint8_t status = 0;        // Bits 0-4: Status dos canais        status |= (apu->pulse[0].enabled ? NES_APU_STATUS_PULSE1 : 0);        status |= (apu->pulse[1].enabled ? NES_APU_STATUS_PULSE2 : 0);        status |= (apu->triangle.enabled ? NES_APU_STATUS_TRIANGLE : 0);        status |= (apu->noise.enabled ? NES_APU_STATUS_NOISE : 0);        status |= (apu->dmc.enabled ? NES_APU_STATUS_DMC : 0);        // Bits 6-7: Status de IRQ        status |= (apu->frame_irq_flag ? NES_APU_STATUS_FRAME_IRQ : 0);        status |= (apu->dmc_irq_flag ? NES_APU_STATUS_DMC_IRQ : 0);        // Leitura do status limpa o flag de IRQ de frame        apu->frame_irq_flag = false;        return status;    }    return 0;}/** * @brief Escreve em um registrador da APU * * @param apu Ponteiro para a APU * @param address Endereço do registrador (0x4000-0x4017) * @param value Valor a escrever */void nes_apu_write_register(nes_apu_t *apu, uint16_t address, uint8_t value){    if (!apu)    {        APU_LOG_ERROR("nes_apu_write_register: apu é NULL");        return;    }    switch (address)    {    // Pulse 1    case NES_APU_PULSE1_DUTY:        apu->pulse[0].duty_cycle = (value >> 6) & 0x03;        apu->pulse[0].envelope_period = value & 0x0F;        apu->pulse[0].constant_volume = (value >> 4) & 0x01;        apu->pulse[0].length_counter_halt = (value >> 5) & 0x01;        break;    case NES_APU_PULSE1_SWEEP:        apu->pulse[0].sweep_enabled = (value >> 7) & 0x01;        apu->pulse[0].sweep_period = ((value >> 4) & 0x07) + 1;        apu->pulse[0].sweep_negate = (value >> 3) & 0x01;        apu->pulse[0].sweep_shift = value & 0x07;        apu->pulse[0].sweep_reload = 1; // Flag de reload        break;    case NES_APU_PULSE1_TIMER_LOW:        apu->pulse[0].timer_period = (apu->pulse[0].timer_period & 0xFF00) | value;        break;    case NES_APU_PULSE1_TIMER_HIGH:        apu->pulse[0].timer_period = (apu->pulse[0].timer_period & 0x00FF) | ((value & 0x07) << 8);        apu->pulse[0].length_counter = (value >> 3) & 0x1F;        apu->pulse[0].envelope_start = 1; // Flag de restart        break;    // Pulse 2    case NES_APU_PULSE2_DUTY:        apu->pulse[1].duty_cycle = (value >> 6) & 0x03;        apu->pulse[1].envelope_period = value & 0x0F;        apu->pulse[1].constant_volume = (value >> 4) & 0x01;        apu->pulse[1].length_counter_halt = (value >> 5) & 0x01;        break;    case NES_APU_PULSE2_SWEEP:        apu->pulse[1].sweep_enabled = (value >> 7) & 0x01;        apu->pulse[1].sweep_period = ((value >> 4) & 0x07) + 1;        apu->pulse[1].sweep_negate = (value >> 3) & 0x01;        apu->pulse[1].sweep_shift = value & 0x07;        apu->pulse[1].sweep_reload = 1; // Flag de reload        break;    case NES_APU_PULSE2_TIMER_LOW:        apu->pulse[1].timer_period = (apu->pulse[1].timer_period & 0xFF00) | value;        break;    case NES_APU_PULSE2_TIMER_HIGH:        apu->pulse[1].timer_period = (apu->pulse[1].timer_period & 0x00FF) | ((value & 0x07) << 8);        apu->pulse[1].length_counter = (value >> 3) & 0x1F;        apu->pulse[1].envelope_start = 1; // Flag de restart        break;    // Status (habilitar/desabilitar canais)    case NES_APU_STATUS_REG:        apu->pulse[0].enabled = value & NES_APU_STATUS_PULSE1;        apu->pulse[1].enabled = value & NES_APU_STATUS_PULSE2;        apu->triangle.enabled = value & NES_APU_STATUS_TRIANGLE;        apu->noise.enabled = value & NES_APU_STATUS_NOISE;        apu->dmc.enabled = value & NES_APU_STATUS_DMC;        // Limpa a flag de IRQ do DMC        if (!(value & NES_APU_STATUS_DMC))        {            apu->dmc_irq_flag = false;        }        break;    // Frame Counter    case NES_APU_FRAME_COUNTER:        apu->frame_counter_mode = (value >> 7) & 0x01;        apu->frame_counter_irq_inhibit = (value >> 6) & 0x01;        // Limpa a flag de IRQ de frame se estiver inibido        if (apu->frame_counter_irq_inhibit)        {            apu->frame_irq_flag = false;        }        // Reset do contador de frames        apu->frame_step = 0;        break;    default:        // Outros registradores não implementados ainda        break;    }}/** * @brief Obtém amostras de áudio da APU * * @param apu Ponteiro para a APU * @param buffer Buffer para receber as amostras * @param num_samples Número de amostras a gerar * @return int Número de amostras geradas */int nes_apu_get_samples(nes_apu_t *apu, int16_t *buffer, int num_samples){    if (!apu || !buffer || num_samples <= 0)    {        APU_LOG_ERROR("nes_apu_get_samples: parâmetros inválidos");        return 0;    }    // Alias para nes_apu_generate_samples para manter compatibilidade    return nes_apu_generate_samples(apu, buffer, num_samples);}