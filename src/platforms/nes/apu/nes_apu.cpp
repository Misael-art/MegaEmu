/** * @file nes_apu.cpp * @brief Implementação da classe NESAPU para a Audio Processing Unit do NES em C++ * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-13 */#include "nes_apu.hpp"#include <stdexcept>#include <iostream>namespace MegaEmu{    namespace Platforms    {        namespace NES        {            NESAPU::NESAPU(void *cpu, void *memory, int sampleRate)                : m_apu(nullptr), m_initialized(false)            {                // Inicializar APU usando a interface C                m_apu = nes_apu_init(cpu, memory, sampleRate);                if (!m_apu)                {                    throw std::runtime_error("Falha ao inicializar NESAPU");                }                m_initialized = true;                std::cout << "NESAPU inicializado com sucesso" << std::endl;            }            NESAPU::~NESAPU()            {                if (m_apu)                {                    nes_apu_shutdown(m_apu);                    m_apu = nullptr;                }                m_initialized = false;                std::cout << "NESAPU destruído" << std::endl;            }            void NESAPU::initialize()            {                // A inicialização já é feita no construtor                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("NESAPU não está inicializado corretamente");                }            }            void NESAPU::reset()            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de resetar NESAPU não inicializado");                }                nes_apu_reset(m_apu);            }            void NESAPU::cycle(int cycles)            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de executar ciclo em NESAPU não inicializado");                }                nes_apu_cycle(m_apu, cycles);            }            void NESAPU::update(int cycles)            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de atualizar NESAPU não inicializado");                }                nes_apu_update(m_apu, cycles);            }            void NESAPU::step()            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de executar passo em NESAPU não inicializado");                }                nes_apu_step(m_apu);            }            void NESAPU::runFrame()            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de executar frame em NESAPU não inicializado");                }                nes_apu_run_frame(m_apu);            }            int NESAPU::generateSamples(int16_t *buffer, int numSamples)            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de gerar amostras em NESAPU não inicializado");                }                if (!buffer)                {                    throw std::invalid_argument("Buffer nulo fornecido para generateSamples");                }                return nes_apu_generate_samples(m_apu, buffer, numSamples);            }            int NESAPU::getSamples(int16_t *buffer, int numSamples)            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de obter amostras de NESAPU não inicializado");                }                if (!buffer)                {                    throw std::invalid_argument("Buffer nulo fornecido para getSamples");                }                return nes_apu_get_samples(m_apu, buffer, numSamples);            }            uint8_t NESAPU::readRegister(uint16_t address) const            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de ler registro de NESAPU não inicializado");                }                return nes_apu_read_register(m_apu, address);            }            void NESAPU::writeRegister(uint16_t address, uint8_t value)            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de escrever registro em NESAPU não inicializado");                }                nes_apu_write_register(m_apu, address, value);            }            int NESAPU::irqOccurred() const            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de verificar IRQ em NESAPU não inicializado");                }                return nes_apu_irq_occurred(m_apu);            }            bool NESAPU::irqPending() const            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de verificar IRQ pendente em NESAPU não inicializado");                }                return nes_apu_irq_pending(m_apu);            }            void NESAPU::acknowledgeIRQ()            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de reconhecer IRQ em NESAPU não inicializado");                }                nes_apu_acknowledge_irq(m_apu);            }            void NESAPU::clearBuffer()            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de limpar buffer em NESAPU não inicializado");                }                nes_apu_clear_buffer(m_apu);            }            int NESAPU::getSampleRate() const            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de obter taxa de amostragem de NESAPU não inicializado");                }                return m_apu->sample_rate;            }            void NESAPU::setSampleRate(int sampleRate)            {                if (!m_initialized || !m_apu)                {                    throw std::runtime_error("Tentativa de definir taxa de amostragem em NESAPU não inicializado");                }                if (sampleRate <= 0)                {                    throw std::invalid_argument("Taxa de amostragem inválida");                }                m_apu->sample_rate = sampleRate;                m_apu->cycles_per_sample = NES_CPU_CLOCK_RATE / sampleRate;            }        } // namespace NES    } // namespace Platforms} // namespace MegaEmu