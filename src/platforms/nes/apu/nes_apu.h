/** * @file nes_apu.h * @brief Definições para a Audio Processing Unit (APU) do NES */#ifndef NES_APU_H#define NES_APU_H#include <stdint.h>#include <stdbool.h>#include "../../../core/core_types.h"#include "../../../utils/error_handling.h"#include "../../../utils/enhanced_log.h"#ifdef __cplusplusextern "C"{#endif/** * @brief Constantes da APU */#define NES_APU_SAMPLE_RATE 44100      /**< Taxa de amostragem padrão */#define NES_APU_BUFFER_SIZE 4096       /**< Tamanho do buffer de áudio */#define NES_APU_FRAME_COUNTER_RATE 240 /**< Taxa do frame counter (240 Hz) */#define NES_APU_CPU_FREQUENCY 1789773  /**< Frequência da CPU do NES (NTSC) */#define NES_CPU_CLOCK_RATE 1789773     /**< Frequência da CPU do NES (NTSC) */    /**     * @brief Registradores da APU     */    enum nes_apu_registers    {        NES_APU_STATUS_REG = 0x4015,        NES_APU_PULSE1_DUTY = 0x4000,        NES_APU_PULSE1_SWEEP = 0x4001,        NES_APU_PULSE1_TIMER_LOW = 0x4002,        NES_APU_PULSE1_TIMER_HIGH = 0x4003,        NES_APU_PULSE2_DUTY = 0x4004,        NES_APU_PULSE2_SWEEP = 0x4005,        NES_APU_PULSE2_TIMER_LOW = 0x4006,        NES_APU_PULSE2_TIMER_HIGH = 0x4007,        NES_APU_TRIANGLE_LINEAR = 0x4008,        NES_APU_TRIANGLE_TIMER_LOW = 0x400A,        NES_APU_TRIANGLE_TIMER_HIGH = 0x400B,        NES_APU_NOISE_VOLUME = 0x400C,        NES_APU_NOISE_PERIOD = 0x400E,        NES_APU_NOISE_LENGTH = 0x400F,        NES_APU_DMC_FREQ = 0x4010,        NES_APU_DMC_RAW = 0x4011,        NES_APU_DMC_START = 0x4012,        NES_APU_DMC_LENGTH = 0x4013,        NES_APU_FRAME_COUNTER = 0x4017    };/** * @brief Bits do registrador de status */#define NES_APU_STATUS_PULSE1 0x01    /**< Canal Pulse 1 ativo */#define NES_APU_STATUS_PULSE2 0x02    /**< Canal Pulse 2 ativo */#define NES_APU_STATUS_TRIANGLE 0x04  /**< Canal Triangle ativo */#define NES_APU_STATUS_NOISE 0x08     /**< Canal Noise ativo */#define NES_APU_STATUS_DMC 0x10       /**< Canal DMC ativo */#define NES_APU_STATUS_FRAME_IRQ 0x40 /**< IRQ do frame counter ativo */#define NES_APU_STATUS_DMC_IRQ 0x80   /**< IRQ do DMC ativo */    /**     * @brief Estrutura do canal de pulso     */    struct nes_apu_pulse    {        uint8_t duty;        uint8_t volume;        uint8_t envelope;        uint8_t sweep;        uint16_t timer;        uint8_t length_counter;        uint8_t sweep_counter;        uint8_t timer_value;        uint8_t sequencer_step;        bool enabled;        uint8_t envelope_start;        uint8_t envelope_divider;        uint8_t envelope_counter;        uint8_t envelope_volume;        bool constant_volume;        bool length_halt;        uint8_t sweep_reload;        uint8_t sweep_period;        bool sweep_enabled;        bool sweep_negate;        uint8_t sweep_shift;        // Campos adicionais necessários        uint8_t channel;        uint8_t duty_cycle;        uint16_t timer_period;        uint8_t duty_step;        uint8_t envelope_period;        uint8_t envelope_value;        bool length_counter_halt;    };    typedef struct nes_apu_pulse nes_apu_pulse_t;    /**     * @brief Estrutura do canal de triângulo     */    struct nes_apu_triangle    {        uint8_t linear_counter;        uint8_t length_counter;        uint16_t timer;        uint8_t timer_value;        uint8_t sequencer_step;        uint8_t linear_counter_reload;        uint8_t linear_counter_load;        uint8_t control_flag;        uint8_t volume;        bool enabled;        // Campos adicionais necessários        bool linear_counter_reload_flag;        uint16_t timer_period;        uint8_t duty_step;        bool length_counter_halt;        uint8_t control;    };    typedef struct nes_apu_triangle nes_apu_triangle_t;    /**     * @brief Estrutura do canal de ruído     */    struct nes_apu_noise    {        uint8_t volume;        uint8_t envelope;        uint8_t mode;        uint8_t period_idx;        uint8_t length_counter;        uint8_t timer_value;        bool enabled;        uint8_t envelope_start;        uint8_t envelope_divider;        uint8_t envelope_counter;        uint8_t envelope_volume;        bool constant_volume;        bool length_halt;        // Campos adicionais necessários        uint8_t envelope_period;        uint16_t period;        uint16_t shift_register;        uint8_t envelope_value;        bool length_counter_halt;    };    typedef struct nes_apu_noise nes_apu_noise_t;    /**     * @brief Estrutura do canal DMC     */    struct nes_apu_dmc    {        uint8_t rate_index;        uint8_t direct_load;        uint16_t sample_address;        uint16_t sample_length;        uint8_t output;        uint8_t bits_remaining;        uint8_t sample_buffer;        bool sample_buffer_empty;        bool irq_enable;        uint8_t timer_value;        bool enabled;        // Campos adicionais necessários        uint16_t bytes_remaining;        uint8_t output_level;        uint8_t shift_register;        bool silence;        bool irq_enabled;        bool loop;        uint8_t frequency;        uint16_t current_address;        bool irq_flag;    };    typedef struct nes_apu_dmc nes_apu_dmc_t;    /**     * @brief Estrutura principal da APU     */    struct nes_apu    {        nes_apu_pulse_t pulse[2]; // Array com dois canais de pulso        nes_apu_triangle_t triangle;        nes_apu_noise_t noise;        nes_apu_dmc_t dmc;        uint8_t status;        uint8_t frame_counter;        uint8_t frame_sequence;        uint32_t cycles;        uint32_t buffer_size;        int16_t *buffer;        bool buffer_full;        bool irq_enabled;        bool frame_irq;        bool dmc_irq;        void *cpu;        void *memory;        uint32_t cpu_cycles;        uint32_t frame_cycles;        uint8_t frame_counter_mode;        bool frame_counter_irq_inhibit;        uint8_t frame_step;        uint32_t cycles_remaining;        uint32_t cycles_per_sample;        uint32_t buffer_position;        int16_t *output_buffer;        uint32_t sample_rate;        // Campos adicionais necessários        uint32_t cycle_counter;        bool frame_irq_enabled;        bool dmc_irq_enabled;        bool frame_irq_flag;        bool dmc_irq_flag;        uint32_t buffer_index;    };    typedef struct nes_apu nes_apu_t;    /**     * @brief Inicializa o subsistema de APU     *     * @param cpu Ponteiro para a CPU     * @param memory Ponteiro para o subsistema de memória     * @param sample_rate Taxa de amostragem para geração de áudio     * @return nes_apu_t* Ponteiro para o estado da APU, ou NULL em caso de erro     */    nes_apu_t *nes_apu_init(void *cpu, void *memory, int32_t sample_rate);    /**     * @brief Finaliza e libera recursos da APU     *     * @param apu Ponteiro para a APU     */    void nes_apu_shutdown(nes_apu_t *apu);    /**     * @brief Reseta a APU     *     * @param apu Ponteiro para a APU     */    void nes_apu_reset(nes_apu_t *apu);    /**     * @brief Executa ciclos da APU     *     * @param apu Ponteiro para a APU     * @param cycles Número de ciclos a executar     */    void nes_apu_cycle(nes_apu_t *apu, int32_t cycles);    /**     * @brief Atualiza a APU por um número específico de ciclos     *     * @param apu Ponteiro para a APU     * @param cycles Número de ciclos a executar     */    void nes_apu_update(nes_apu_t *apu, int32_t cycles);    /**     * @brief Gera amostras de áudio para o buffer fornecido     *     * @param apu Ponteiro para a APU     * @param buffer Buffer para receber as amostras de áudio     * @param num_samples Número de amostras a gerar     * @return int32_t Número de amostras geradas     */    int32_t nes_apu_generate_samples(nes_apu_t *apu, int16_t *buffer, int32_t num_samples);    /**     * @brief Lê um registrador da APU     *     * @param apu Ponteiro para a APU     * @param address Endereço do registrador ($4000-$4017, exceto $4014 e $4016)     * @return uint8_t Valor lido     */    uint8_t nes_apu_read_register(nes_apu_t *apu, uint16_t address);    /**     * @brief Escreve um registrador da APU     *     * @param apu Ponteiro para a APU     * @param address Endereço do registrador ($4000-$4017, exceto $4014 e $4016)     * @param value Valor a escrever     */    void nes_apu_write_register(nes_apu_t *apu, uint16_t address, uint8_t value);    /**     * @brief Obtém amostras de áudio     *     * @param apu Ponteiro para a APU     * @param buffer Buffer para receber as amostras     * @param num_samples Número de amostras a recuperar     * @return int32_t Número de amostras efetivamente recuperadas     */    int32_t nes_apu_get_samples(nes_apu_t *apu, int16_t *buffer, int32_t num_samples);    /**     * @brief Verifica se ocorreu um IRQ da APU     *     * @param apu Ponteiro para a APU     * @return int32_t 1 se ocorreu IRQ, 0 caso contrário     */    int32_t nes_apu_irq_occurred(nes_apu_t *apu);    /**     * @brief Funções de execução     */    void nes_apu_step(nes_apu_t *apu);    void nes_apu_run_frame(nes_apu_t *apu);    /**     * @brief Funções de áudio     */    const float *nes_apu_get_output_buffer(const nes_apu_t *apu, size_t *size);    void nes_apu_clear_buffer(nes_apu_t *apu);    /**     * @brief Funções de controle     */    bool nes_apu_irq_pending(const nes_apu_t *apu);    void nes_apu_acknowledge_irq(nes_apu_t *apu);#ifdef __cplusplus}#endif#endif /* NES_APU_H */