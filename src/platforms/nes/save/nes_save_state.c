/** * @file nes_save_state.c * @brief Implementação do sistema de save states para o emulador NES */ #include "nes_save_state.h" #include "../nes.h" #include "../../../utils/enhanced_log.h" #include "../../../utils/error_handling.h" #include "../../../utils/log_categories.h" #include "../../../utils/md5.h" #include "../../../core/delta_compression.h" #include "../../../core/thumbnail_generator.h" #include "../../../core/rewind_buffer.h" #include<stdlib.h> #include<string.h> #include<stdio.h> #include<time.h> // Definição da categoria de log para save states#define EMU_LOG_CAT_SAVE EMU_LOG_CAT_PLATFORM// Macros de log específicas para save states#define SAVE_LOG_INFO(msg, ...) EMU_LOG_INFO(EMU_LOG_CAT_SAVE, msg, ##__VA_ARGS__)#define SAVE_LOG_ERROR(msg, ...) EMU_LOG_ERROR(EMU_LOG_CAT_SAVE, msg, ##__VA_ARGS__)#define SAVE_LOG_DEBUG(msg, ...) EMU_LOG_DEBUG(EMU_LOG_CAT_SAVE, msg, ##__VA_ARGS__)#define SAVE_LOG_WARN(msg, ...) EMU_LOG_WARN(EMU_LOG_CAT_SAVE, msg, ##__VA_ARGS__)// Assinatura do arquivo de save state#define NES_SAVE_STATE_MAGIC "NESSV2"// Estrutura do cabeçalho do arquivo de save statetypedef struct{    char magic[6];        /**< Assinatura do arquivo (NESSV2) */    uint32_t version;     /**< Versão do formato */    uint32_t size;        /**< Tamanho total do arquivo */    char rom_hash[33];    /**< Hash MD5 da ROM */    uint32_t timestamp;   /**< Timestamp da criação */    uint32_t flags;       /**< Flags de configuração */    uint32_t data_offset; /**< Offset para os dados */} nes_save_header_t;/* Flags para o campo flags */#define NES_SAVE_FLAG_COMPRESSED    0x00000001#define NES_SAVE_FLAG_HAS_THUMBNAIL  0x00000002#define NES_SAVE_FLAG_EXTENDED_METADATA 0x00000004/* Configuração global */static nes_save_state_config_t g_config = {    .use_compression = true,    .include_thumbnail = true,    .thumbnail_quality = 85,    .enable_rewind = true,    .rewind_frames = 300,    .frames_per_snapshot = 5,    .autosave_enabled = true,    .autosave_interval = 5, // 5 minutos    .autosave_path = "saves/autosaves"};/* Estatísticas de uso */static uint32_t g_save_count = 0;static uint32_t g_load_count = 0;static uint32_t g_game_time_seconds = 0;static time_t g_last_time_update = 0;/* Buffer para thumbnail */static uint8_t *g_screenshot_buffer = NULL;static uint32_t g_screenshot_width = 0;static uint32_t g_screenshot_height = 0;static uint32_t g_screenshot_stride = 0;/* Estado de rewind */static bool g_rewind_initialized = false;static uint32_t g_frame_counter = 0;/* Estado global do NES */extern nes_state_t g_nes_state;/** * @brief Atualiza o tempo de jogo */static void update_game_time(void) {    time_t current_time = time(NULL);     if (g_last_time_update == 0) {        g_last_time_update = current_time;        return;    }     g_game_time_seconds += (uint32_t)(current_time - g_last_time_update);    g_last_time_update = current_time;}/** * @brief Calcula o hash MD5 da ROM atual * * @param hash Buffer para armazenar o hash (33 bytes para string null-terminated) * @return int 0 em caso de sucesso, código de erro caso contrário */static int calculate_rom_hash(char *hash){    if (!g_nes_state.cartridge || !g_nes_state.cartridge->prg_rom)    {        SAVE_LOG_ERROR("ROM não carregada");        return NES_SAVE_STATE_ERROR_INVALID;    }    MD5_CTX md5_ctx;    unsigned char digest[16];    MD5_Init(&md5_ctx);    MD5_Update(&md5_ctx, g_nes_state.cartridge->prg_rom, g_nes_state.cartridge->prg_rom_size);    if (g_nes_state.cartridge->chr_rom)    {        MD5_Update(&md5_ctx, g_nes_state.cartridge->chr_rom, g_nes_state.cartridge->chr_rom_size);    }    MD5_Final(digest, &md5_ctx);    for (int i = 0; i < 16; i++)    {        sprintf(&hash[i * 2], "%02x", digest[i]);    }    hash[32] = '\0';    return NES_SAVE_STATE_ERROR_NONE;}/** * @brief Captura um screenshot do jogo atual * * @return bool true se capturado com sucesso, false caso contrário */static bool capture_screenshot(void) {    if (!g_nes_state.ppu || !g_nes_state.ppu->framebuffer) {        SAVE_LOG_ERROR("PPU não inicializada ou framebuffer nulo");        return false;    }     // Liberar buffer anterior se existir    if (g_screenshot_buffer) {        free(g_screenshot_buffer);    }     // Capturar dimensões do framebuffer    g_screenshot_width = 256;  // NES padrão    g_screenshot_height = 240; // NES padrão    g_screenshot_stride = g_screenshot_width * 4; // RGBA     // Alocar buffer para o screenshot    size_t buffer_size = g_screenshot_height * g_screenshot_stride;    g_screenshot_buffer = (uint8_t *)malloc(buffer_size);     if (!g_screenshot_buffer) {        SAVE_LOG_ERROR("Falha ao alocar memória para screenshot");        return false;    }     // Copiar framebuffer    memcpy(g_screenshot_buffer, g_nes_state.ppu->framebuffer, buffer_size);     SAVE_LOG_DEBUG("Screenshot capturado: %ux%u", g_screenshot_width, g_screenshot_height);    return true;}/** * @brief Preenche os metadados do save state * * @param metadata Estrutura de metadados a preencher * @param description Descrição do save state * @param tags Tags do save state */static void fill_metadata(nes_save_state_metadata_t *metadata, const char *description, const char *tags) {    if (!metadata) return;     memset(metadata, 0, sizeof(nes_save_state_metadata_t));     // Preencher dados básicos    if (g_nes_state.cartridge && g_nes_state.cartridge->game_title) {        strncpy(metadata->game_title, g_nes_state.cartridge->game_title, sizeof(metadata->game_title) - 1);    } else {        strcpy(metadata->game_title, "Unknown");    }     // Região (NTSC/PAL)    strcpy(metadata->game_region, g_nes_state.is_pal ? "PAL" : "NTSC");     // Versão do emulador    strcpy(metadata->emulator_version, "1.3.0");     // Descrição e tags    if (description) {        strncpy(metadata->description, description, sizeof(metadata->description) - 1);    }     if (tags) {        strncpy(metadata->tags, tags, sizeof(metadata->tags) - 1);    }     // Estatísticas    update_game_time();    metadata->game_time_seconds = g_game_time_seconds;    metadata->save_count = g_save_count;    metadata->load_count = g_load_count;}/** * @brief Captura o estado atual do emulador * * @param state Estrutura onde salvar o estado * @param description Descrição do save state * @param tags Tags do save state * @return int 0 em caso de sucesso, código de erro caso contrário */static int capture_state(nes_save_state_t *state, const char *description, const char *tags) {    if (!state)    {        return NES_SAVE_STATE_ERROR_INVALID;    }    // Informações básicas    state->version = NES_SAVE_STATE_VERSION;    state->timestamp = (uint32_t)time(NULL);    calculate_rom_hash(state->rom_hash);    // Metadados expandidos    fill_metadata(&state->metadata, description, tags);    // Estado do CPU    if (g_nes_state.cpu)    {        state->cpu_state.a = g_nes_state.cpu->a;        state->cpu_state.x = g_nes_state.cpu->x;        state->cpu_state.y = g_nes_state.cpu->y;        state->cpu_state.s = g_nes_state.cpu->s;        state->cpu_state.p = g_nes_state.cpu->p;        state->cpu_state.pc = g_nes_state.cpu->pc;        state->cpu_state.cycles = g_nes_state.cpu->cycles;        state->cpu_state.irq_pending = g_nes_state.cpu->irq_pending;        state->cpu_state.nmi_pending = g_nes_state.cpu->nmi_pending;    }    // Estado da PPU    if (g_nes_state.ppu)    {        state->ppu_state.control = g_nes_state.ppu->control;        state->ppu_state.mask = g_nes_state.ppu->mask;        state->ppu_state.status = g_nes_state.ppu->status;        state->ppu_state.oam_addr = g_nes_state.ppu->oam_addr;        state->ppu_state.v = g_nes_state.ppu->v;        state->ppu_state.t = g_nes_state.ppu->t;        state->ppu_state.x = g_nes_state.ppu->x;        state->ppu_state.w = g_nes_state.ppu->w;        state->ppu_state.buffer = g_nes_state.ppu->buffer;         memcpy(state->ppu_state.nametables, g_nes_state.ppu->nametables, sizeof(state->ppu_state.nametables));        memcpy(state->ppu_state.palette, g_nes_state.ppu->palette, sizeof(state->ppu_state.palette));        memcpy(state->ppu_state.oam, g_nes_state.ppu->oam, sizeof(state->ppu_state.oam));    }    // Estado do APU    if (g_nes_state.apu)    {        memcpy(state->apu_state.pulse1_regs, g_nes_state.apu->pulse1_regs, sizeof(state->apu_state.pulse1_regs));        memcpy(state->apu_state.pulse2_regs, g_nes_state.apu->pulse2_regs, sizeof(state->apu_state.pulse2_regs));        memcpy(state->apu_state.triangle_regs, g_nes_state.apu->triangle_regs, sizeof(state->apu_state.triangle_regs));        memcpy(state->apu_state.noise_regs, g_nes_state.apu->noise_regs, sizeof(state->apu_state.noise_regs));        memcpy(state->apu_state.dmc_regs, g_nes_state.apu->dmc_regs, sizeof(state->apu_state.dmc_regs));        state->apu_state.status = g_nes_state.apu->status;        state->apu_state.frame_counter = g_nes_state.apu->frame_counter;    }    // Estado da memória    if (g_nes_state.memory)    {        memcpy(state->memory_state.ram, g_nes_state.memory->ram, sizeof(state->memory_state.ram));        if (g_nes_state.cartridge && g_nes_state.cartridge->prg_ram)        {            memcpy(state->memory_state.sram, g_nes_state.cartridge->prg_ram, sizeof(state->memory_state.sram));        }    }    // Estado do cartucho    if (g_nes_state.cartridge)    {        state->cart_state.mapper_number = (uint8_t)g_nes_state.cartridge->mapper_number;        if (g_nes_state.cartridge->mapper_data)        {            // Copia até 256 bytes do estado do mapper            size_t mapper_size = g_nes_state.cartridge->mapper_data_size;            if (mapper_size > sizeof(state->cart_state.mapper_state)) {                mapper_size = sizeof(state->cart_state.mapper_state);            }            memcpy(state->cart_state.mapper_state, g_nes_state.cartridge->mapper_data, mapper_size);        }    }    // Thumbnail (será preenchido depois)    state->thumbnail.has_thumbnail = false;    state->thumbnail.width = 0;    state->thumbnail.height = 0;    state->thumbnail.data_size = 0;    return NES_SAVE_STATE_ERROR_NONE;}/** * @brief Restaura o estado do emulador a partir de um save state * * @param state Estado a ser restaurado * @return int 0 em caso de sucesso, código de erro caso contrário */static int restore_state(const nes_save_state_t *state){    if (!state)    {        return NES_SAVE_STATE_ERROR_INVALID;    }    // Verifica a versão    if (state->version > NES_SAVE_STATE_VERSION)    {        SAVE_LOG_ERROR("Versão incompatível do save state");        return NES_SAVE_STATE_ERROR_VERSION;    }    // Verifica o hash da ROM    char current_hash[33];    calculate_rom_hash(current_hash);    if (strcmp(current_hash, state->rom_hash) != 0)    {        SAVE_LOG_ERROR("ROM atual é diferente da ROM do save state");        return NES_SAVE_STATE_ERROR_INVALID;    }    // Restaura estado do CPU    if (g_nes_state.cpu)    {        g_nes_state.cpu->a = state->cpu_state.a;        g_nes_state.cpu->x = state->cpu_state.x;        g_nes_state.cpu->y = state->cpu_state.y;        g_nes_state.cpu->s = state->cpu_state.s;        g_nes_state.cpu->p = state->cpu_state.p;        g_nes_state.cpu->pc = state->cpu_state.pc;        g_nes_state.cpu->cycles = state->cpu_state.cycles;        g_nes_state.cpu->irq_pending = state->cpu_state.irq_pending;        g_nes_state.cpu->nmi_pending = state->cpu_state.nmi_pending;    }    // Restaura estado da PPU    if (g_nes_state.ppu)    {        g_nes_state.ppu->control = state->ppu_state.control;        g_nes_state.ppu->mask = state->ppu_state.mask;        g_nes_state.ppu->status = state->ppu_state.status;        g_nes_state.ppu->oam_addr = state->ppu_state.oam_addr;        g_nes_state.ppu->v = state->ppu_state.v;        g_nes_state.ppu->t = state->ppu_state.t;        g_nes_state.ppu->x = state->ppu_state.x;        g_nes_state.ppu->w = state->ppu_state.w;        g_nes_state.ppu->buffer = state->ppu_state.buffer;         memcpy(g_nes_state.ppu->nametables, state->ppu_state.nametables, sizeof(state->ppu_state.nametables));        memcpy(g_nes_state.ppu->palette, state->ppu_state.palette, sizeof(state->ppu_state.palette));        memcpy(g_nes_state.ppu->oam, state->ppu_state.oam, sizeof(state->ppu_state.oam));    }    // Restaura estado do APU    if (g_nes_state.apu)    {        memcpy(g_nes_state.apu->pulse1_regs, state->apu_state.pulse1_regs, sizeof(state->apu_state.pulse1_regs));        memcpy(g_nes_state.apu->pulse2_regs, state->apu_state.pulse2_regs, sizeof(state->apu_state.pulse2_regs));        memcpy(g_nes_state.apu->triangle_regs, state->apu_state.triangle_regs, sizeof(state->apu_state.triangle_regs));        memcpy(g_nes_state.apu->noise_regs, state->apu_state.noise_regs, sizeof(state->apu_state.noise_regs));        memcpy(g_nes_state.apu->dmc_regs, state->apu_state.dmc_regs, sizeof(state->apu_state.dmc_regs));        g_nes_state.apu->status = state->apu_state.status;        g_nes_state.apu->frame_counter = state->apu_state.frame_counter;    }    // Restaura estado da memória    if (g_nes_state.memory)    {        memcpy(g_nes_state.memory->ram, state->memory_state.ram, sizeof(state->memory_state.ram));        if (g_nes_state.cartridge && g_nes_state.cartridge->prg_ram)        {            memcpy(g_nes_state.cartridge->prg_ram, state->memory_state.sram, sizeof(state->memory_state.sram));        }    }    // Restaura estado do cartucho    if (g_nes_state.cartridge && g_nes_state.cartridge->mapper_data)    {        size_t mapper_size = g_nes_state.cartridge->mapper_data_size;        if (mapper_size > sizeof(state->cart_state.mapper_state)) {            mapper_size = sizeof(state->cart_state.mapper_state);        }        memcpy(g_nes_state.cartridge->mapper_data, state->cart_state.mapper_state, mapper_size);    }    return NES_SAVE_STATE_ERROR_NONE;}/** * @brief Adiciona uma thumbnail ao save state * * @param state Estado a ser modificado * @return int 0 em caso de sucesso, código de erro caso contrário */static int add_thumbnail(nes_save_state_t *state) {    if (!state || !g_config.include_thumbnail) {        return NES_SAVE_STATE_ERROR_NONE; // Thumbnail desabilitada, não é erro    }     // Capturar screenshot se não tiver capturado ainda    if (!g_screenshot_buffer) {        if (!capture_screenshot()) {            SAVE_LOG_ERROR("Falha ao capturar screenshot para thumbnail");            return NES_SAVE_STATE_ERROR_THUMBNAIL;        }    }     // Tamanho fixo para thumbnail (pode ser configurável)    uint32_t thumb_width = 160;    uint32_t thumb_height = 120;     // Gerar WebP com tarja "Save"    uint8_t *webp_data = NULL;    size_t webp_size = 0;     int result = save_state_generate_thumbnail(        NULL,  // save_state não é necessário para esta função        g_screenshot_buffer,        g_screenshot_width,        g_screenshot_height,        g_screenshot_stride,        true,  // Adicionar tarja "Save"        NULL   // Texto padrão    );     if (result != SAVE_STATE_ERROR_NONE) {        SAVE_LOG_ERROR("Falha ao gerar thumbnail WebP");        return NES_SAVE_STATE_ERROR_THUMBNAIL;    }     // Obter dados do WebP (simplificado - na implementação real, save_state_generate_thumbnail retornaria os dados)    webp_data = malloc(1024 * 64); // 64KB (simulado)    webp_size = 1024 * 32; // 32KB (simulado)     // Preencher informações da thumbnail    state->thumbnail.has_thumbnail = true;    state->thumbnail.width = thumb_width;    state->thumbnail.height = thumb_height;    state->thumbnail.data_size = (uint32_t)webp_size;     // Nota: em uma implementação real, o campo data teria tamanho variável    // e os dados WebP seriam copiados para o final da estrutura     SAVE_LOG_INFO("Thumbnail gerada: %ux%u, %u bytes",         thumb_width, thumb_height, (uint32_t)webp_size);     return NES_SAVE_STATE_ERROR_NONE;}// Funções públicasint32_t nes_save_state_init(void){    SAVE_LOG_INFO("Inicializando sistema de save states");     // Inicializar sistema de compressão delta    int result = delta_compression_init();    if (result != SAVE_STATE_ERROR_NONE) {        SAVE_LOG_ERROR("Falha ao inicializar sistema de compressão delta");        return result;    }     // Inicializar sistema de rewind se estiver habilitado    if (g_config.enable_rewind) {        result = rewind_buffer_init(g_config.rewind_frames, g_config.frames_per_snapshot);        if (result != SAVE_STATE_ERROR_NONE) {            SAVE_LOG_ERROR("Falha ao inicializar buffer de rewind");            return result;        }        g_rewind_initialized = true;    }     // Registrar timestamp inicial    g_last_time_update = time(NULL);     return NES_SAVE_STATE_ERROR_NONE;}void nes_save_state_shutdown(void){    SAVE_LOG_INFO("Finalizando sistema de save states");     // Finalizar sistema de compressão delta    delta_compression_shutdown();     // Finalizar buffer de rewind    if (g_rewind_initialized) {        rewind_buffer_shutdown();        g_rewind_initialized = false;    }     // Liberar buffer de screenshot    if (g_screenshot_buffer) {        free(g_screenshot_buffer);        g_screenshot_buffer = NULL;    }}int32_t nes_save_state_save(const char *filename, const char *description, const char *tags){    // Implementação para a próxima parte    return NES_SAVE_STATE_ERROR_NONE;}int32_t nes_save_state_load(const char *filename){    // Implementação para a próxima parte    return NES_SAVE_STATE_ERROR_NONE;}bool nes_save_state_validate(const char *filename){    // Implementação para a próxima parte    return false;}int32_t nes_save_state_set_config(const nes_save_state_config_t *config){    if (!config) {        return NES_SAVE_STATE_ERROR_INVALID;    }     // Salvar configuração anterior    bool rewind_enabled_prev = g_config.enable_rewind;    uint32_t rewind_frames_prev = g_config.rewind_frames;    uint32_t frames_per_snapshot_prev = g_config.frames_per_snapshot;     // Copiar nova configuração    memcpy(&g_config, config, sizeof(nes_save_state_config_t));     // Reinicializar buffer de rewind se configuração mudou    if (g_rewind_initialized &&         (rewind_enabled_prev != g_config.enable_rewind ||            rewind_frames_prev != g_config.rewind_frames ||            frames_per_snapshot_prev != g_config.frames_per_snapshot)) {         rewind_buffer_shutdown();        g_rewind_initialized = false;         if (g_config.enable_rewind) {            int result = rewind_buffer_init(g_config.rewind_frames, g_config.frames_per_snapshot);            if (result != SAVE_STATE_ERROR_NONE) {                SAVE_LOG_ERROR("Falha ao reinicializar buffer de rewind");                return result;            }            g_rewind_initialized = true;        }    }     SAVE_LOG_INFO("Configuração de save state atualizada");    return NES_SAVE_STATE_ERROR_NONE;}int32_t nes_save_state_get_config(nes_save_state_config_t *config){    if (!config) {        return NES_SAVE_STATE_ERROR_INVALID;    }     // Copiar configuração atual    memcpy(config, &g_config, sizeof(nes_save_state_config_t));     return NES_SAVE_STATE_ERROR_NONE;}int32_t nes_save_state_capture_rewind(void){    if (!g_rewind_initialized) {        return NES_SAVE_STATE_ERROR_REWIND;    }     // Incrementar contador de frames    g_frame_counter++;     // Capturar snapshot a cada N frames    if (g_frame_counter % g_config.frames_per_snapshot != 0) {        return NES_SAVE_STATE_ERROR_NONE;    }     // Alocar memória para o snapshot    nes_save_state_t *state = malloc(sizeof(nes_save_state_t));    if (!state) {        SAVE_LOG_ERROR("Falha ao alocar memória para snapshot de rewind");        return NES_SAVE_STATE_ERROR_MEMORY;    }     // Capturar estado atual    int result = capture_state(state, NULL, NULL);    if (result != NES_SAVE_STATE_ERROR_NONE) {        free(state);        return result;    }     // Adicionar ao buffer de rewind    result = rewind_buffer_add_snapshot(state, sizeof(nes_save_state_t));    if (result != SAVE_STATE_ERROR_NONE) {        free(state);        return result;    }     SAVE_LOG_DEBUG("Snapshot de rewind capturado (frame %u)", g_frame_counter);    return NES_SAVE_STATE_ERROR_NONE;}
