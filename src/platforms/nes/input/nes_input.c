/** * @file nes_input.c * @brief Implementação do subsistema de entrada (controles) do NES */#include <stdlib.h>#include <string.h>#include <stdio.h>#ifdef _WIN32#include <windows.h>#else// Definições das teclas para outros sistemas operacionais#define VK_SPACE 0x20#define VK_RETURN 0x0D#define VK_UP 0x26#define VK_DOWN 0x28#define VK_LEFT 0x25#define VK_RIGHT 0x27#endif#include "nes_input.h"#include "../nes.h"#include "utils/enhanced_log.h"#include "utils/error_handling.h"#include "utils/log_categories.h"// Macros de log específicas para o input#define INPUT_LOG_INFO(msg, ...) EMU_LOG_INFO(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)#define INPUT_LOG_ERROR(msg, ...) EMU_LOG_ERROR(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)#define INPUT_LOG_TRACE(msg, ...) EMU_LOG_TRACE(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)#define INPUT_LOG_WARN(msg, ...) EMU_LOG_WARN(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)#define INPUT_LOG_DEBUG(msg, ...) EMU_LOG_DEBUG(EMU_LOG_CAT_INPUT, msg, ##__VA_ARGS__)bool nes_input_init(nes_input_t *input){    if (!input)    {        return false;    }    INPUT_LOG_INFO("Inicializando subsistema de input do NES");    memset(input, 0, sizeof(nes_input_t));    // Configura os tipos de controladores padrão    input->device_type[0] = NES_INPUT_DEVICE_JOYPAD;    input->device_type[1] = NES_INPUT_DEVICE_JOYPAD;    // Inicializa o estado dos controladores    input->button_states[0] = 0;    input->button_states[1] = 0;    input->shift_registers[0] = 0;    input->shift_registers[1] = 0;    input->strobe = 0;    // Inicializa o estado do zapper    input->zapper.x = 0;    input->zapper.y = 0;    input->zapper.trigger = 0;    input->zapper.light_detected = 0;    // Inicializa o mapeamento de teclas    nes_input_init_key_mapping(input);    INPUT_LOG_INFO("Subsistema de input do NES inicializado com sucesso");    return true;}void nes_input_shutdown(nes_input_t *input){    if (input)    {        INPUT_LOG_INFO("Desligando subsistema de input do NES");        memset(input, 0, sizeof(nes_input_t));    }}void nes_input_reset(nes_input_t *input){    if (input)    {        INPUT_LOG_INFO("Resetando subsistema de input do NES");        input->strobe = 0;        input->shift_registers[0] = input->button_states[0];        input->shift_registers[1] = input->button_states[1];    }}void nes_input_set_device(nes_input_t *input, int32_t port, nes_input_device_type_t device_type){    if (!input || port < 0 || port > 1)    {        INPUT_LOG_WARN("Tentativa de definir tipo de dispositivo com parâmetros inválidos");        return;    }    input->device_type[port] = device_type;    // Resetar o estado do controlador    input->button_states[port] = 0;    input->shift_registers[port] = 0;    INPUT_LOG_INFO("Dispositivo na porta %d definido como tipo %d",                   port, device_type);}void nes_input_set_buttons(nes_input_t *input, int32_t port, uint8_t buttons){    if (!input || port < 0 || port > 1)    {        INPUT_LOG_ERROR("nes_input_set_buttons: parâmetros inválidos");        return;    }    input->button_states[port] = buttons;    if (!input->strobe)    {        input->shift_registers[port] = buttons;    }    INPUT_LOG_TRACE("Botões do controlador %d definidos: %02X", port, buttons);}void nes_input_set_zapper_state(nes_input_t *input, int32_t x, int32_t y, int32_t trigger){    if (!input)    {        INPUT_LOG_ERROR("nes_input_set_zapper_state: input inválido");        return;    }    input->zapper.x = x;    input->zapper.y = y;    input->zapper.trigger = trigger ? 1 : 0;    INPUT_LOG_TRACE("Zapper definido: x=%d, y=%d, trigger=%d", x, y, trigger);}uint8_t nes_input_read(nes_input_t *input, int port){    if (!input || port < 0 || port > 1)    {        return 0;    }    uint8_t ret = (input->shift_registers[port] & 1);    // Se não estiver em modo strobe, desloca o registrador    if (!input->strobe)    {        input->shift_registers[port] >>= 1;        input->shift_registers[port] |= 0x80; // Bits mais significativos são 1    }    return ret;}void nes_input_write(nes_input_t *input, uint8_t value){    if (!input)    {        INPUT_LOG_ERROR("nes_input_write: input inválido");        return;    }    // Se o strobe mudou de 1 para 0, recarrega os registradores    if ((input->strobe & 1) && !(value & 1))    {        input->shift_registers[0] = input->button_states[0];        input->shift_registers[1] = input->button_states[1];    }    input->strobe = value & 1;}void nes_input_update_zapper(nes_input_t *input, const uint32_t *frame_buffer, int32_t width, int32_t height){    if (!input || !frame_buffer || width <= 0 || height <= 0)    {        INPUT_LOG_ERROR("nes_input_update_zapper: parâmetros inválidos");        return;    }    // Atualiza a detecção de luz com base na posição atual do zapper e no frame_buffer    input->zapper.light_detected = nes_input_update_zapper_light_detection(input, frame_buffer, width, height);    INPUT_LOG_TRACE("Zapper atualizado: light_detected=%d", input->zapper.light_detected);}int32_t nes_input_update_zapper_light_detection(nes_input_t *input, const uint32_t *frame_buffer, int32_t width, int32_t height){    if (!input || !frame_buffer || width <= 0 || height <= 0)    {        return 0;    }    // Verifica se a posição do zapper está dentro dos limites da tela    if (input->zapper.x < 0 || input->zapper.x >= width ||        input->zapper.y < 0 || input->zapper.y >= height)    {        return 0;    }    // Obtém o pixel na posição do zapper    uint32_t pixel = frame_buffer[input->zapper.y * width + input->zapper.x];    // Extrai os componentes RGB    uint8_t r = (pixel >> 16) & 0xFF;    uint8_t g = (pixel >> 8) & 0xFF;    uint8_t b = pixel & 0xFF;    // Calcula a luminosidade (média simples dos componentes RGB)    uint32_t luminosity = (r + g + b) / 3;    // Retorna 1 se a luminosidade estiver acima do limiar (128)    return luminosity > 128 ? 1 : 0;}void nes_input_init_key_mapping(nes_input_t *input){    if (!input)    {        return;    }    // Mapeamento padrão para o jogador 1    input->key_mapping[0][NES_BUTTON_IDX_A] = 'Z';    input->key_mapping[0][NES_BUTTON_IDX_B] = 'X';    input->key_mapping[0][NES_BUTTON_IDX_SELECT] = VK_SPACE;    input->key_mapping[0][NES_BUTTON_IDX_START] = VK_RETURN;    input->key_mapping[0][NES_BUTTON_IDX_UP] = VK_UP;    input->key_mapping[0][NES_BUTTON_IDX_DOWN] = VK_DOWN;    input->key_mapping[0][NES_BUTTON_IDX_LEFT] = VK_LEFT;    input->key_mapping[0][NES_BUTTON_IDX_RIGHT] = VK_RIGHT;    // Mapeamento padrão para o jogador 2    input->key_mapping[1][NES_BUTTON_IDX_A] = 'N';    input->key_mapping[1][NES_BUTTON_IDX_B] = 'M';    input->key_mapping[1][NES_BUTTON_IDX_SELECT] = 'V';    input->key_mapping[1][NES_BUTTON_IDX_START] = 'B';    input->key_mapping[1][NES_BUTTON_IDX_UP] = 'W';    input->key_mapping[1][NES_BUTTON_IDX_DOWN] = 'S';    input->key_mapping[1][NES_BUTTON_IDX_LEFT] = 'A';    input->key_mapping[1][NES_BUTTON_IDX_RIGHT] = 'D';}void nes_input_process_key(nes_input_t *input, int32_t key_code, int32_t is_pressed){    if (!input)    {        return;    }    // Processa o mapeamento para ambos os jogadores    for (int player = 0; player < 2; player++)    {        for (int button = 0; button < NES_BUTTON_COUNT; button++)        {            if (input->key_mapping[player][button] == key_code)            {                uint8_t mask = 1 << button;                if (is_pressed)                {                    input->button_states[player] |= mask;                }                else                {                    input->button_states[player] &= ~mask;                }                if (input->strobe)                {                    input->shift_registers[player] = input->button_states[player];                }            }        }    }}int32_t nes_input_set_key_mapping(nes_input_t *input, int32_t player, uint8_t nes_button, int32_t key_code){    if (!input || player < 0 || player > 1 || nes_button >= NES_BUTTON_COUNT)    {        return -1;    }    input->key_mapping[player][nes_button] = key_code;    return 0;}void nes_input_reset_key_mapping(nes_input_t *input, int32_t player){    if (!input || player < 0 || player > 1)    {        return;    }    // Restaura o mapeamento padrão para o jogador especificado    nes_input_init_key_mapping(input);}