/** * @file nes_memory.c * @brief Implementação do subsistema de memória do NES */#include "nes_memory.h"#include <stdlib.h>#include <string.h>#include <time.h>#include "utils/enhanced_log.h"#include "../nes.h" // Para as constantes NES_ERROR_*#include "utils/error_handling.h"#include "utils/log_categories.h"// Definição da categoria de log para a memória#define EMU_LOG_CAT_MEMORY NES_LOG_CAT_MEMORY// Macros de log específicas para a memória#define MEM_LOG_INFO(msg, ...) EMU_LOG_INFO(EMU_LOG_CAT_MEMORY, msg, ##__VA_ARGS__)#define MEM_LOG_ERROR(msg, ...) EMU_LOG_ERROR(EMU_LOG_CAT_MEMORY, msg, ##__VA_ARGS__)#define MEM_LOG_TRACE(msg, ...) EMU_LOG_TRACE(EMU_LOG_CAT_MEMORY, msg, ##__VA_ARGS__)#define MEM_LOG_WARN(msg, ...) EMU_LOG_WARN(EMU_LOG_CAT_MEMORY, msg, ##__VA_ARGS__)#define MEM_LOG_DEBUG(msg, ...) EMU_LOG_DEBUG(EMU_LOG_CAT_MEMORY, msg, ##__VA_ARGS__)// Tamanho inicial do array de mapeamentos#define NES_MEMORY_DEFAULT_MAPPINGS 16// Funções internas para acesso à RAMstatic uint8_t read_ram(void *context, uint16_t address);static void write_ram(void *context, uint16_t address, uint8_t value);/** * @brief Inicializa o subsistema de memória do NES * * @return nes_memory_t* Ponteiro para o subsistema de memória, ou NULL em caso de erro */nes_memory_t *nes_memory_init(void){    MEM_LOG_INFO("Inicializando subsistema de memória do NES");    // Aloca a estrutura    nes_memory_t *memory = (nes_memory_t *)malloc(sizeof(nes_memory_t));    if (!memory)    {        MEM_LOG_ERROR("nes_memory_init: falha na alocação de memória para a estrutura");        return NULL;    }    // Inicializa a estrutura com zeros    memset(memory, 0, sizeof(nes_memory_t));    // Inicializa a RAM interna com valores aleatórios (como no hardware real)    // No NES real, a RAM é inicializada com valores aleatórios no power-on    srand(time(NULL));    for (int i = 0; i < NES_MEM_SIZE_RAM; i++)    {        memory->ram[i] = (uint8_t)(rand() & 0xFF);    }    // Aloca espaço para mapeamentos    memory->max_mappings = 16; // Valor inicial razoável    memory->mappings = (nes_memory_map_t *)malloc(memory->max_mappings * sizeof(nes_memory_map_t));    if (!memory->mappings)    {        MEM_LOG_ERROR("nes_memory_init: falha na alocação de mapeamentos");        free(memory);        return NULL;    }    memory->num_mappings = 0;    // Inicializa o estado do DMA    memory->dma_in_progress = 0;    memory->dma_cycles_left = 0;    memory->dma_src_addr = 0;    memory->dma_dest_addr = 0;    MEM_LOG_INFO("Subsistema de memória do NES inicializado com sucesso");    return memory;}/** * @brief Configura os componentes do sistema de memória * * @param memory Ponteiro para o subsistema de memória * @param ppu Ponteiro para a PPU * @param apu Ponteiro para a APU * @param input Ponteiro para o subsistema de input * @param cartridge Ponteiro para o cartucho * @return int 0 em caso de sucesso, código de erro caso contrário */int nes_memory_set_components(nes_memory_t *memory, void *ppu, void *apu, void *input, void *cartridge){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_set_components: memória não inicializada");        return NES_ERROR_INVALID_PARAMETER;    }    // Atribui os ponteiros para componentes    memory->ppu = ppu;    memory->apu = apu;    memory->input = input;    memory->cartridge = cartridge;    MEM_LOG_INFO("Componentes do subsistema de memória configurados");    return NES_ERROR_NONE;}/** * @brief Finaliza e libera recursos do subsistema de memória * * @param memory Ponteiro para o subsistema de memória */void nes_memory_shutdown(nes_memory_t *memory){    if (!memory)    {        MEM_LOG_WARN("nes_memory_shutdown: memória já está desligada");        return;    }    MEM_LOG_INFO("Desligando subsistema de memória do NES");    // Libera o array de mapeamentos    if (memory->mappings)    {        free(memory->mappings);    }    // Libera a estrutura principal    free(memory);}/** * @brief Reseta o subsistema de memória * * @param memory Ponteiro para o subsistema de memória */void nes_memory_reset(nes_memory_t *memory){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_reset: memória inválida");        return;    }    MEM_LOG_INFO("Resetando subsistema de memória do NES");    // No NES real, a RAM não é limpa no reset do sistema    // Apenas o estado do DMA é resetado    memory->dma_in_progress = 0;    memory->dma_cycles_left = 0;    memory->dma_src_addr = 0;    memory->dma_dest_addr = 0;    // Limpa os mapeamentos existentes    memory->num_mappings = 0;    MEM_LOG_DEBUG("Subsistema de memória resetado");}/** * @brief Adiciona um mapeamento de memória * * @param memory Ponteiro para o subsistema de memória * @param start_addr Endereço inicial do mapeamento * @param end_addr Endereço final do mapeamento * @param read_func Função de leitura * @param write_func Função de escrita * @param context Contexto para os callbacks * @return int 0 em caso de sucesso, código de erro em caso de falha */int nes_memory_add_mapping(nes_memory_t *memory, uint16_t start_addr, uint16_t end_addr,                           nes_mem_read_func_t read_func, nes_mem_write_func_t write_func,                           void *context){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_add_mapping: memória inválida");        return -1;    }    if (start_addr > end_addr)    {        MEM_LOG_ERROR("nes_memory_add_mapping: endereço inicial > endereço final");        return -1;    }    if (!read_func && !write_func)    {        MEM_LOG_ERROR("nes_memory_add_mapping: ambas as funções de leitura e escrita são NULL");        return -1;    }    // Verifica se há espaço para mais um mapeamento    if (memory->num_mappings >= memory->max_mappings)    {        // Realoca o array de mapeamentos com o dobro do tamanho        int new_max = memory->max_mappings * 2;        nes_memory_map_t *new_mappings = (nes_memory_map_t *)realloc(memory->mappings,                                                                     new_max * sizeof(nes_memory_map_t));        if (!new_mappings)        {            MEM_LOG_ERROR("nes_memory_add_mapping: falha ao realocar array de mapeamentos");            return -1;        }        memory->mappings = new_mappings;        memory->max_mappings = new_max;    }    // Adiciona o novo mapeamento    int idx = memory->num_mappings;    memory->mappings[idx].start_addr = start_addr;    memory->mappings[idx].end_addr = end_addr;    memory->mappings[idx].read_func = read_func;    memory->mappings[idx].write_func = write_func;    memory->mappings[idx].context = context;    memory->num_mappings++;    MEM_LOG_DEBUG("Adicionado mapeamento %d: $%04X-$%04X",                  idx, start_addr, end_addr);    return 0;}/** * @brief Encontra o mapeamento para um determinado endereço * * @param memory Ponteiro para o subsistema de memória * @param address Endereço a ser verificado * @return nes_memory_map_t* Ponteiro para o mapeamento, ou NULL se não encontrado */static nes_memory_map_t *find_mapping(nes_memory_t *memory, uint16_t address){    for (int i = 0; i < memory->num_mappings; i++)    {        if (address >= memory->mappings[i].start_addr &&            address <= memory->mappings[i].end_addr)        {            return &memory->mappings[i];        }    }    return NULL;}/** * @brief Lê um byte da memória * * @param memory Ponteiro para o subsistema de memória * @param address Endereço para ler * @return uint8_t Valor lido */uint8_t nes_memory_read(nes_memory_t *memory, uint16_t address){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_read: memória inválida");        return 0;    }    // Verifica o range do endereço para determinar o comportamento    if (address < 0x2000)    {        // RAM interna (0x0000-0x07FF) e seus espelhos (0x0800-0x1FFF)        return memory->ram[address & 0x07FF];    }    else if (address < 0x4000)    {        // Registradores da PPU (0x2000-0x2007) e seus espelhos (0x2008-0x3FFF)        if (memory->ppu)        {            return nes_ppu_read_register(memory->ppu, 0x2000 + (address & 0x7));        }        else        {            MEM_LOG_WARN("Leitura de registrador PPU com PPU não inicializada: $%04X", address);            return 0;        }    }    else if (address < 0x4018)    {        // Registradores de I/O (0x4000-0x4017)        if (address == 0x4016)        {            // Controlador 1            if (memory->input)            {                return nes_input_read_controller1(memory->input);            }        }        else if (address == 0x4017)        {            // Controlador 2            if (memory->input)            {                return nes_input_read_controller2(memory->input);            }        }        else if (memory->apu && address >= 0x4000 && address <= 0x4015)        {            // Registradores do APU            return nes_apu_read_register(memory->apu, address);        }        return 0;    }    else if (address < 0x4020)    {        // Area de teste do CPU (0x4018-0x401F) - normalmente não utilizada        MEM_LOG_DEBUG("Leitura da área de teste do CPU: $%04X", address);        return 0;    }    else    {        // Espaço do cartucho (0x4020-0xFFFF)        if (memory->cartridge)        {            // Chamada para a função de leitura do cartucho            return nes_cartridge_cpu_read(memory->cartridge, address);        }        else        {            MEM_LOG_WARN("Leitura do cartucho com cartucho não inicializado: $%04X", address);            return 0;        }    }    // Retorna 0 para endereços não mapeados    MEM_LOG_DEBUG("Leitura de endereço não mapeado: $%04X", address);    return 0;}/** * @brief Escreve um byte na memória * * @param memory Ponteiro para o subsistema de memória * @param address Endereço para escrever * @param value Valor a escrever */void nes_memory_write(nes_memory_t *memory, uint16_t address, uint8_t value){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_write: memória inválida");        return;    }    // Verifica o range do endereço para determinar o comportamento    if (address < 0x2000)    {        // RAM interna (0x0000-0x07FF) e seus espelhos (0x0800-0x1FFF)        memory->ram[address & 0x07FF] = value;    }    else if (address < 0x4000)    {        // Registradores da PPU (0x2000-0x2007) e seus espelhos (0x2008-0x3FFF)        if (memory->ppu)        {            nes_ppu_write_register(memory->ppu, 0x2000 + (address & 0x7), value);        }        else        {            MEM_LOG_WARN("Escrita em registrador PPU com PPU não inicializada: $%04X = $%02X", address, value);        }    }    else if (address < 0x4018)    {        // Registradores de I/O (0x4000-0x4017)        if (address == 0x4014)        {            // DMA da OAM            if (memory->ppu)            {                // Lê 256 bytes da memória e transfere para a OAM da PPU                uint8_t oam_data[256];                uint16_t dma_addr = value << 8;                for (int i = 0; i < 256; i++)                {                    oam_data[i] = nes_memory_read(memory, dma_addr + i);                }                nes_ppu_write_oam_dma(memory->ppu, oam_data);            }        }        else if (address == 0x4016)        {            // Controlador 1            if (memory->input)            {                nes_input_write_controller1(memory->input, value);            }        }        else if (address == 0x4017)        {            // Controlador 2            if (memory->input)            {                nes_input_write_controller2(memory->input, value);            }        }        else if (memory->apu && address >= 0x4000 && address <= 0x4015)        {            // Registradores do APU            nes_apu_write_register(memory->apu, address, value);        }    }    else if (address < 0x4020)    {        // Area de teste do CPU (0x4018-0x401F) - normalmente não utilizada        MEM_LOG_DEBUG("Escrita na área de teste do CPU: $%04X = $%02X", address, value);    }    else    {        // Espaço do cartucho (0x4020-0xFFFF)        if (memory->cartridge)        {            // Chamada para a função de escrita do cartucho            nes_cartridge_cpu_write(memory->cartridge, address, value);        }        else        {            MEM_LOG_WARN("Escrita no cartucho com cartucho não inicializado: $%04X = $%02X", address, value);        }    }    // Verifica mapeamentos personalizados    for (int i = 0; i < memory->num_mappings; i++)    {        if (address >= memory->mappings[i].start_addr && address <= memory->mappings[i].end_addr)        {            if (memory->mappings[i].write_func)            {                memory->mappings[i].write_func(memory->mappings[i].context, address, value);                return;            }        }    }}/** * @brief Lê uma palavra (16 bits) da memória (little endian) * * @param memory Ponteiro para o subsistema de memória * @param address Endereço para ler * @return uint16_t Valor lido */uint16_t nes_memory_read_word(nes_memory_t *memory, uint16_t address){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_read_word: memória inválida");        return 0;    }    // O NES é little endian, então o byte de menor significância vem primeiro    uint8_t lo = nes_memory_read(memory, address);    uint8_t hi = nes_memory_read(memory, address + 1);    return (uint16_t)((hi << 8) | lo);}/** * @brief Escreve uma palavra (16 bits) na memória (little endian) * * @param memory Ponteiro para o subsistema de memória * @param address Endereço para escrever * @param value Valor a escrever */void nes_memory_write_word(nes_memory_t *memory, uint16_t address, uint16_t value){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_write_word: memória inválida");        return;    }    // O NES é little endian, então o byte de menor significância vem primeiro    nes_memory_write(memory, address, value & 0xFF);    nes_memory_write(memory, address + 1, (value >> 8) & 0xFF);}/** * @brief Inicia uma operação de DMA * * @param memory Ponteiro para o subsistema de memória * @param page O número da página (byte alto do endereço) para a fonte do DMA * @return int Número de ciclos que a operação levará */int nes_memory_start_dma(nes_memory_t *memory, uint8_t page){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_start_dma: memória inválida");        return 0;    }    if (!memory->ppu)    {        MEM_LOG_WARN("nes_memory_start_dma: tentando iniciar DMA sem PPU");        return 0;    }    // Configura o DMA    memory->dma_in_progress = 1;    memory->dma_cycles_left = 513; // 513 ou 514 ciclos de CPU, dependendo se estamos em ciclo par ou ímpar    memory->dma_src_addr = (uint16_t)(page << 8);    memory->dma_dest_addr = 0; // Endereço de destino começa em 0 (OAM)    MEM_LOG_DEBUG("Iniciando DMA OAM da página $%02X (endereço $%04X)",                  page, memory->dma_src_addr);    // Retorna o número de ciclos que a operação levará    return memory->dma_cycles_left;}/** * @brief Executa um ciclo de DMA * * @param memory Ponteiro para o subsistema de memória * @return int 1 se o DMA foi concluído, 0 se ainda há ciclos restantes, -1 em caso de erro */int nes_memory_run_dma(nes_memory_t *memory){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_run_dma: memória inválida");        return -1;    }    if (!memory->dma_in_progress)    {        MEM_LOG_WARN("nes_memory_run_dma: nenhum DMA em progresso");        return -1;    }    // Decrementa o contador de ciclos    memory->dma_cycles_left--;    // Verifica se é um ciclo de transferência (a cada 2 ciclos após o ciclo inicial de sincronização)    // Os primeiros ciclos são para sincronização    if (memory->dma_cycles_left < 512 && (memory->dma_cycles_left & 1) == 0)    {        // Lê o dado da RAM        uint8_t data = nes_memory_read(memory, memory->dma_src_addr);        // Escreve no OAM da PPU        // nes_ppu_write_oam(memory->ppu, memory->dma_dest_addr & 0xFF, data);        // Incrementa os endereços        memory->dma_src_addr++;        memory->dma_dest_addr++;    }    // Verifica se o DMA foi concluído    if (memory->dma_cycles_left == 0)    {        memory->dma_in_progress = 0;        MEM_LOG_DEBUG("DMA concluído");        return 1; // DMA concluído    }    return 0; // Ainda há ciclos restantes}/** * @brief Verifica se um DMA está em progresso * * @param memory Ponteiro para o subsistema de memória * @return int 1 se um DMA está em progresso, 0 caso contrário */int nes_memory_is_dma_active(nes_memory_t *memory){    if (!memory)    {        MEM_LOG_ERROR("nes_memory_is_dma_active: memória inválida");        return 0;    }    return memory->dma_in_progress;}// Função interna para leitura da RAMstatic uint8_t read_ram(void *context, uint16_t address){    nes_memory_t *memory = (nes_memory_t *)context;    if (!memory || address >= NES_MEM_SIZE_RAM)    {        return 0;    }    return memory->ram[address];}// Função interna para escrita na RAMstatic void write_ram(void *context, uint16_t address, uint8_t value){    nes_memory_t *memory = (nes_memory_t *)context;    if (!memory || address >= NES_MEM_SIZE_RAM)    {        return;    }    memory->ram[address] = value;}/** * @brief Lê um byte da memória (função específica para o CPU) * * @param memory Ponteiro para o subsistema de memória * @param address Endereço para ler * @return uint8_t Valor lido */uint8_t nes_memory_cpu_read(nes_memory_t *memory, uint16_t address){    // Esta função é um wrapper para nes_memory_read, específico para o CPU    return nes_memory_read(memory, address);}/** * @brief Escreve um byte na memória (função específica para o CPU) * * @param memory Ponteiro para o subsistema de memória * @param address Endereço para escrever * @param value Valor a escrever */void nes_memory_cpu_write(nes_memory_t *memory, uint16_t address, uint8_t value){    // Esta função é um wrapper para nes_memory_write, específico para o CPU    nes_memory_write(memory, address, value);}