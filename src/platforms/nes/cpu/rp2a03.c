/** * @file rp2a03.c * @brief Implementação da CPU RP2A03 (variante da CPU 6502) usada no NES */ #include "platforms/nes/cpu/rp2a03.h" #include "utils/error_handling.h" #include "utils/enhanced_log.h" #include "utils/log_categories.h" #include<stdlib.h> #include<string.h> #include<stdio.h> // Macros de log específicas para o CPU#define CPU_LOG_INFO(msg, ...) EMU_LOG_INFO(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)#define CPU_LOG_ERROR(msg, ...) EMU_LOG_ERROR(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)#define CPU_LOG_TRACE(msg, ...) EMU_LOG_TRACE(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)#define CPU_LOG_WARN(msg, ...) EMU_LOG_WARN(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)#define CPU_LOG_DEBUG(msg, ...) EMU_LOG_DEBUG(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)// Definições de categorias de log específicas para a CPU#define NES_LOG_CAT_CPU EMU_LOG_CAT_CPU// Definições de endereços de memória importantes#define RP2A03_STACK_BASE 0x0100#define RP2A03_NMI_VECTOR 0xFFFA#define RP2A03_RESET_VECTOR 0xFFFC#define RP2A03_IRQ_VECTOR 0xFFFE// Protótipos de funções estáticasstatic uint16_t read_word(rp2a03_t *cpu, uint16_t addr);// Modos de endereçamentotypedef enum{    RP2A03_ADDR_MODE_IMPLICIT,    RP2A03_ADDR_MODE_ACCUMULATOR,    RP2A03_ADDR_MODE_IMMEDIATE,    RP2A03_ADDR_MODE_ZERO_PAGE,    RP2A03_ADDR_MODE_ZERO_PAGE_X,    RP2A03_ADDR_MODE_ZERO_PAGE_Y,    RP2A03_ADDR_MODE_RELATIVE,    RP2A03_ADDR_MODE_ABSOLUTE,    RP2A03_ADDR_MODE_ABSOLUTE_X,    RP2A03_ADDR_MODE_ABSOLUTE_Y,    RP2A03_ADDR_MODE_INDIRECT,    RP2A03_ADDR_MODE_INDEXED_INDIRECT,    RP2A03_ADDR_MODE_INDIRECT_INDEXED} rp2a03_addr_mode_t;// Tabela de ciclos por instruçãostatic const uint8_t RP2A03_CYCLES_TABLE[256] = {    /*        0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */    /* 0x00 */ 7, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 4, 4, 6, 6,    /* 0x10 */ 2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,    /* 0x20 */ 6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 4, 4, 6, 6,    /* 0x30 */ 2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,    /* 0x40 */ 6, 6, 2, 8, 3, 3, 5, 5, 3, 2, 2, 2, 3, 4, 6, 6,    /* 0x50 */ 2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,    /* 0x60 */ 6, 6, 2, 8, 3, 3, 5, 5, 4, 2, 2, 2, 5, 4, 6, 6,    /* 0x70 */ 2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,    /* 0x80 */ 2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,    /* 0x90 */ 2, 6, 2, 6, 4, 4, 4, 4, 2, 5, 2, 5, 5, 5, 5, 5,    /* 0xA0 */ 2, 6, 2, 6, 3, 3, 3, 3, 2, 2, 2, 2, 4, 4, 4, 4,    /* 0xB0 */ 2, 5, 2, 5, 4, 4, 4, 4, 2, 4, 2, 4, 4, 4, 4, 4,    /* 0xC0 */ 2, 6, 2, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,    /* 0xD0 */ 2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7,    /* 0xE0 */ 2, 6, 3, 8, 3, 3, 5, 5, 2, 2, 2, 2, 4, 4, 6, 6,    /* 0xF0 */ 2, 5, 2, 8, 4, 4, 6, 6, 2, 4, 2, 7, 4, 4, 7, 7};// Nomes dos modos de endereçamento (para logging)static const char *RP2A03_ADDR_MODE_NAMES[] = {    "Implícito",    "Acumulador",    "Imediato",    "Zero Page",    "Zero Page,X",    "Zero Page,Y",    "Relativo",    "Absoluto",    "Absoluto,X",    "Absoluto,Y",    "Indireto",    "Indexado Indireto",    "Indireto Indexado"};// Nomes das instruções (para logging)static const char *RP2A03_INSTRUCTION_NAMES[] = {    "ADC", "AND", "ASL", "BCC", "BCS", "BEQ", "BIT", "BMI",    "BNE", "BPL", "BRK", "BVC", "BVS", "CLC", "CLD", "CLI",    "CLV", "CMP", "CPX", "CPY", "DEC", "DEX", "DEY", "EOR",    "INC", "INX", "INY", "JMP", "JSR", "LDA", "LDX", "LDY",    "LSR", "NOP", "ORA", "PHA", "PHP", "PLA", "PLP", "ROL",    "ROR", "RTI", "RTS", "SBC", "SEC", "SED", "SEI", "STA",    "STX", "STY", "TAX", "TAY", "TSX", "TXA", "TXS", "TYA",    "???", // Instrução inválida};// Definições para debugchar RP2A03_DEBUG_BUFFER[256];// Estrutura para definir uma instruçãotypedef struct{    const char *name;                         // Nome da instrução    uint8_t (*execute)(rp2a03_t *, uint16_t); // Função para executar a instrução    rp2a03_addr_mode_t addr_mode;             // Modo de endereçamento    uint8_t cycles;                           // Ciclos base} rp2a03_instruction_t;// Declarações de funções auxiliares para os modos de endereçamentostatic uint16_t addr_implicit(rp2a03_t *cpu);static uint16_t addr_accumulator(rp2a03_t *cpu);static uint16_t addr_immediate(rp2a03_t *cpu);static uint16_t addr_zero_page(rp2a03_t *cpu);static uint16_t addr_zero_page_x(rp2a03_t *cpu);static uint16_t addr_zero_page_y(rp2a03_t *cpu);static uint16_t addr_relative(rp2a03_t *cpu);static uint16_t addr_absolute(rp2a03_t *cpu);static uint16_t addr_absolute_x(rp2a03_t *cpu);static uint16_t addr_absolute_y(rp2a03_t *cpu);static uint16_t addr_indirect(rp2a03_t *cpu);static uint16_t addr_indexed_indirect(rp2a03_t *cpu);static uint16_t addr_indirect_indexed(rp2a03_t *cpu);// Declarações de funções para implementar instruçõesstatic uint8_t inst_adc(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_and(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_asl(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_bcc(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_bcs(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_beq(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_bit(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_bmi(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_bne(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_bpl(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_brk(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_bvc(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_bvs(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_clc(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_cld(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_cli(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_clv(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_cmp(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_cpx(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_cpy(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_dec(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_dex(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_dey(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_eor(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_inc(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_inx(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_iny(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_jmp(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_jsr(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_lda(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_ldx(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_ldy(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_lsr(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_nop(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_ora(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_pha(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_php(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_pla(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_plp(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_rol(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_ror(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_rti(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_rts(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_sbc(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_sec(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_sed(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_sei(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_sta(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_stx(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_sty(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_tax(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_tay(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_tsx(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_txa(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_txs(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_tya(rp2a03_t *cpu, uint16_t addr);static uint8_t inst_illegal(rp2a03_t *cpu, uint16_t addr);// Tabela de instruçõesstatic const rp2a03_instruction_t RP2A03_INSTRUCTIONS[256] = {    // 0x00-0x0F    {"BRK", inst_brk, RP2A03_ADDR_MODE_IMPLICIT, 7},    {"ORA", inst_ora, RP2A03_ADDR_MODE_INDEXED_INDIRECT, 6},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 2},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 8},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 3},    {"ORA", inst_ora, RP2A03_ADDR_MODE_ZERO_PAGE, 3},    {"ASL", inst_asl, RP2A03_ADDR_MODE_ZERO_PAGE, 5},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 5},    {"PHP", inst_php, RP2A03_ADDR_MODE_IMPLICIT, 3},    {"ORA", inst_ora, RP2A03_ADDR_MODE_IMMEDIATE, 2},    {"ASL", inst_asl, RP2A03_ADDR_MODE_ACCUMULATOR, 2},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 2},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 4},    {"ORA", inst_ora, RP2A03_ADDR_MODE_ABSOLUTE, 4},    {"ASL", inst_asl, RP2A03_ADDR_MODE_ABSOLUTE, 6},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 6},    // 0x10-0x1F    {"BPL", inst_bpl, RP2A03_ADDR_MODE_RELATIVE, 2},    {"ORA", inst_ora, RP2A03_ADDR_MODE_INDIRECT_INDEXED, 5},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 2},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 8},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 4},    {"ORA", inst_ora, RP2A03_ADDR_MODE_ZERO_PAGE_X, 4},    {"ASL", inst_asl, RP2A03_ADDR_MODE_ZERO_PAGE_X, 6},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 6},    {"CLC", inst_clc, RP2A03_ADDR_MODE_IMPLICIT, 2},    {"ORA", inst_ora, RP2A03_ADDR_MODE_ABSOLUTE_Y, 4},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 2},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 7},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 4},    {"ORA", inst_ora, RP2A03_ADDR_MODE_ABSOLUTE_X, 4},    {"ASL", inst_asl, RP2A03_ADDR_MODE_ABSOLUTE_X, 7},    {"???", inst_illegal, RP2A03_ADDR_MODE_IMPLICIT, 7},};// Implementação de funções auxiliares para endereçamentostatic uint16_t addr_implicit(rp2a03_t *cpu){    return 0; // Não usa endereço}static uint16_t addr_accumulator(rp2a03_t *cpu){    return 0; // Usa o acumulador}static uint16_t addr_immediate(rp2a03_t *cpu){    return cpu->pc++; // O valor está no próximo byte}static uint16_t addr_zero_page(rp2a03_t *cpu){    return cpu->read_mem(cpu->context, cpu->pc++);}static uint16_t addr_zero_page_x(rp2a03_t *cpu){    return (cpu->read_mem(cpu->context, cpu->pc++) + cpu->x) & 0xFF;}static uint16_t addr_zero_page_y(rp2a03_t *cpu){    return (cpu->read_mem(cpu->context, cpu->pc++) + cpu->y) & 0xFF;}static uint16_t addr_relative(rp2a03_t *cpu){    int8_t offset = (int8_t)cpu->read_mem(cpu->context, cpu->pc++);    return cpu->pc + offset;}static uint16_t addr_absolute(rp2a03_t *cpu){    uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++);    addr |= (cpu->read_mem(cpu->context, cpu->pc++) << 8);    return addr;}static uint16_t addr_absolute_x(rp2a03_t *cpu){    uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++);    addr |= (cpu->read_mem(cpu->context, cpu->pc++) << 8);    return addr + cpu->x;}static uint16_t addr_absolute_y(rp2a03_t *cpu){    uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++);    addr |= (cpu->read_mem(cpu->context, cpu->pc++) << 8);    return addr + cpu->y;}static uint16_t addr_indirect(rp2a03_t *cpu){    uint16_t ptr = cpu->read_mem(cpu->context, cpu->pc++);    ptr |= (cpu->read_mem(cpu->context, cpu->pc++) << 8);    // Emular bug da página de hardware do 6502    if ((ptr & 0xFF) == 0xFF)    {        uint16_t addr = cpu->read_mem(cpu->context, ptr);        addr |= (cpu->read_mem(cpu->context, ptr & 0xFF00) << 8);        return addr;    }    else    {        uint16_t addr = cpu->read_mem(cpu->context, ptr);        addr |= (cpu->read_mem(cpu->context, ptr + 1) << 8);        return addr;    }}static uint16_t addr_indexed_indirect(rp2a03_t *cpu){    uint8_t zp = (cpu->read_mem(cpu->context, cpu->pc++) + cpu->x) & 0xFF;    uint16_t addr = cpu->read_mem(cpu->context, zp);    addr |= (cpu->read_mem(cpu->context, (zp + 1) & 0xFF) << 8);    return addr;}static uint16_t addr_indirect_indexed(rp2a03_t *cpu){    uint8_t zp = cpu->read_mem(cpu->context, cpu->pc++);    uint16_t addr = cpu->read_mem(cpu->context, zp);    addr |= (cpu->read_mem(cpu->context, (zp + 1) & 0xFF) << 8);    return addr + cpu->y;}// Implementando algumas das instruções mais básicasstatic uint8_t inst_lda(rp2a03_t *cpu, uint16_t addr){    cpu->a = cpu->read_mem(cpu->context, addr);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->a == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->a & 0x80);    return 0; // Sem ciclos extras}static uint8_t inst_ldx(rp2a03_t *cpu, uint16_t addr){    cpu->x = cpu->read_mem(cpu->context, addr);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->x == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->x & 0x80);    return 0;}static uint8_t inst_ldy(rp2a03_t *cpu, uint16_t addr){    cpu->y = cpu->read_mem(cpu->context, addr);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->y == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->y & 0x80);    return 0;}static uint8_t inst_sta(rp2a03_t *cpu, uint16_t addr){    cpu->write_mem(cpu->context, addr, cpu->a);    return 0;}static uint8_t inst_stx(rp2a03_t *cpu, uint16_t addr){    cpu->write_mem(cpu->context, addr, cpu->x);    return 0;}static uint8_t inst_sty(rp2a03_t *cpu, uint16_t addr){    cpu->write_mem(cpu->context, addr, cpu->y);    return 0;}static uint8_t inst_jmp(rp2a03_t *cpu, uint16_t addr){    cpu->pc = addr;    return 0;}static uint8_t inst_nop(rp2a03_t *cpu, uint16_t addr){    return 0; // Não faz nada}// Implementação de instruções ilegais/não documentadasstatic uint8_t inst_illegal(rp2a03_t *cpu, uint16_t addr){    CPU_LOG_WARN("Instrução ilegal encontrada em $%04X", cpu->pc - 1);    return 0;}// Implementação de mais instruções importantes// Instruções de transferência entre registradoresstatic uint8_t inst_tax(rp2a03_t *cpu, uint16_t addr){    cpu->x = cpu->a;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->x == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->x & 0x80);    return 0;}static uint8_t inst_tay(rp2a03_t *cpu, uint16_t addr){    cpu->y = cpu->a;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->y == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->y & 0x80);    return 0;}static uint8_t inst_txa(rp2a03_t *cpu, uint16_t addr){    cpu->a = cpu->x;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->a == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->a & 0x80);    return 0;}static uint8_t inst_tya(rp2a03_t *cpu, uint16_t addr){    cpu->a = cpu->y;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->a == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->a & 0x80);    return 0;}static uint8_t inst_txs(rp2a03_t *cpu, uint16_t addr){    cpu->sp = cpu->x;    return 0; // Não afeta flags}static uint8_t inst_tsx(rp2a03_t *cpu, uint16_t addr){    cpu->x = cpu->sp;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->x == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->x & 0x80);    return 0;}// Operações com a pilhastatic uint8_t inst_pha(rp2a03_t *cpu, uint16_t addr){    cpu->write_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp, cpu->a);    cpu->sp--;    return 0;}static uint8_t inst_php(rp2a03_t *cpu, uint16_t addr){    // O 6502 sempre coloca as flags B e bit 5 quando empilha o status    uint8_t status = cpu->status | RP2A03_FLAG_BREAK | RP2A03_FLAG_UNUSED;    cpu->write_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp, status);    cpu->sp--;    return 0;}static uint8_t inst_pla(rp2a03_t *cpu, uint16_t addr){    cpu->sp++;    cpu->a = cpu->read_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->a == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->a & 0x80);    return 0;}static uint8_t inst_plp(rp2a03_t *cpu, uint16_t addr){    cpu->sp++;    // Quando desempilha o status, as flags B e bit 5 não são alteradas    uint8_t status = cpu->read_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp);    uint8_t flag_mask = ~(RP2A03_FLAG_BREAK | RP2A03_FLAG_UNUSED);    cpu->status = (cpu->status & ~flag_mask) | (status & flag_mask);    // No caso específico do 6502, o bit 5 é sempre 1    cpu->status |= RP2A03_FLAG_UNUSED;    return 0;}// Instruções de saltostatic uint8_t inst_jsr(rp2a03_t *cpu, uint16_t addr){    uint16_t return_addr = cpu->pc - 1;    cpu->write_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp, (return_addr >> 8) & 0xFF);    cpu->sp--;    cpu->write_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp, return_addr & 0xFF);    cpu->sp--;    cpu->pc = addr;    return 0;}static uint8_t inst_rts(rp2a03_t *cpu, uint16_t addr){    cpu->sp++;    uint16_t return_addr = cpu->read_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp);    cpu->sp++;    return_addr |= (cpu->read_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp) << 8);    cpu->pc = return_addr + 1;    return 0;}static uint8_t inst_rti(rp2a03_t *cpu, uint16_t addr){    // Primeiro recupera o status    cpu->sp++;    uint8_t status = cpu->read_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp);    // No RTI, todas as flags são restauradas, exceto B que é ignorada    uint8_t flag_mask = ~RP2A03_FLAG_BREAK;    cpu->status = (cpu->status & RP2A03_FLAG_BREAK) | (status & flag_mask);    // No caso específico do 6502, o bit 5 é sempre 1    cpu->status |= RP2A03_FLAG_UNUSED;    // Depois recupera o PC    cpu->sp++;    uint16_t return_addr = cpu->read_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp);    cpu->sp++;    return_addr |= (cpu->read_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp) << 8);    cpu->pc = return_addr;    return 0;}// Instruções de desvio condicional (branches)static uint8_t inst_bcc(rp2a03_t *cpu, uint16_t addr){    if (!rp2a03_get_flag(cpu, RP2A03_FLAG_CARRY))    {        // Ciclo extra se o branch for tomado        uint16_t old_pc = cpu->pc;        cpu->pc = addr;        // Ciclo extra se o branch cruzar uma página        if ((old_pc & 0xFF00) != (cpu->pc & 0xFF00))        {            return 2; // +2 ciclos: branch tomado e cruza página        }        return 1; // +1 ciclo: branch tomado sem cruzar página    }    return 0; // branch não tomado}static uint8_t inst_bcs(rp2a03_t *cpu, uint16_t addr){    if (rp2a03_get_flag(cpu, RP2A03_FLAG_CARRY))    {        uint16_t old_pc = cpu->pc;        cpu->pc = addr;        if ((old_pc & 0xFF00) != (cpu->pc & 0xFF00))        {            return 2;        }        return 1;    }    return 0;}static uint8_t inst_beq(rp2a03_t *cpu, uint16_t addr){    if (rp2a03_get_flag(cpu, RP2A03_FLAG_ZERO))    {        uint16_t old_pc = cpu->pc;        cpu->pc = addr;        if ((old_pc & 0xFF00) != (cpu->pc & 0xFF00))        {            return 2;        }        return 1;    }    return 0;}static uint8_t inst_bmi(rp2a03_t *cpu, uint16_t addr){    if (rp2a03_get_flag(cpu, RP2A03_FLAG_NEGATIVE))    {        uint16_t old_pc = cpu->pc;        cpu->pc = addr;        if ((old_pc & 0xFF00) != (cpu->pc & 0xFF00))        {            return 2;        }        return 1;    }    return 0;}static uint8_t inst_bne(rp2a03_t *cpu, uint16_t addr){    if (!rp2a03_get_flag(cpu, RP2A03_FLAG_ZERO))    {        uint16_t old_pc = cpu->pc;        cpu->pc = addr;        if ((old_pc & 0xFF00) != (cpu->pc & 0xFF00))        {            return 2;        }        return 1;    }    return 0;}static uint8_t inst_bpl(rp2a03_t *cpu, uint16_t addr){    if (!rp2a03_get_flag(cpu, RP2A03_FLAG_NEGATIVE))    {        uint16_t old_pc = cpu->pc;        cpu->pc = addr;        if ((old_pc & 0xFF00) != (cpu->pc & 0xFF00))        {            return 2;        }        return 1;    }    return 0;}static uint8_t inst_bvc(rp2a03_t *cpu, uint16_t addr){    if (!rp2a03_get_flag(cpu, RP2A03_FLAG_OVERFLOW))    {        uint16_t old_pc = cpu->pc;        cpu->pc = addr;        if ((old_pc & 0xFF00) != (cpu->pc & 0xFF00))        {            return 2;        }        return 1;    }    return 0;}static uint8_t inst_bvs(rp2a03_t *cpu, uint16_t addr){    if (rp2a03_get_flag(cpu, RP2A03_FLAG_OVERFLOW))    {        uint16_t old_pc = cpu->pc;        cpu->pc = addr;        if ((old_pc & 0xFF00) != (cpu->pc & 0xFF00))        {            return 2;        }        return 1;    }    return 0;}// Instruções de manipulação de flagsstatic uint8_t inst_clc(rp2a03_t *cpu, uint16_t addr){    rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, 0);    return 0;}static uint8_t inst_cld(rp2a03_t *cpu, uint16_t addr){    rp2a03_set_flag(cpu, RP2A03_FLAG_DECIMAL, 0);    return 0;}static uint8_t inst_cli(rp2a03_t *cpu, uint16_t addr){    rp2a03_set_flag(cpu, RP2A03_FLAG_INTERRUPT, 0);    return 0;}static uint8_t inst_clv(rp2a03_t *cpu, uint16_t addr){    rp2a03_set_flag(cpu, RP2A03_FLAG_OVERFLOW, 0);    return 0;}static uint8_t inst_sec(rp2a03_t *cpu, uint16_t addr){    rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, 1);    return 0;}static uint8_t inst_sed(rp2a03_t *cpu, uint16_t addr){    rp2a03_set_flag(cpu, RP2A03_FLAG_DECIMAL, 1);    return 0;}static uint8_t inst_sei(rp2a03_t *cpu, uint16_t addr){    rp2a03_set_flag(cpu, RP2A03_FLAG_INTERRUPT, 1);    return 0;}// Instruções de incremento e decrementostatic uint8_t inst_inc(rp2a03_t *cpu, uint16_t addr){    uint8_t value = cpu->read_mem(cpu->context, addr);    value++;    cpu->write_mem(cpu->context, addr, value);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, value == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, value & 0x80);    return 0;}static uint8_t inst_inx(rp2a03_t *cpu, uint16_t addr){    cpu->x++;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->x == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->x & 0x80);    return 0;}static uint8_t inst_iny(rp2a03_t *cpu, uint16_t addr){    cpu->y++;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->y == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->y & 0x80);    return 0;}static uint8_t inst_dec(rp2a03_t *cpu, uint16_t addr){    uint8_t value = cpu->read_mem(cpu->context, addr);    value--;    cpu->write_mem(cpu->context, addr, value);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, value == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, value & 0x80);    return 0;}static uint8_t inst_dex(rp2a03_t *cpu, uint16_t addr){    cpu->x--;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->x == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->x & 0x80);    return 0;}static uint8_t inst_dey(rp2a03_t *cpu, uint16_t addr){    cpu->y--;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->y == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->y & 0x80);    return 0;}// Instruções lógicas e aritméticasstatic uint8_t inst_and(rp2a03_t *cpu, uint16_t addr){    cpu->a &= cpu->read_mem(cpu->context, addr);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->a == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->a & 0x80);    return 0;}static uint8_t inst_ora(rp2a03_t *cpu, uint16_t addr){    cpu->a |= cpu->read_mem(cpu->context, addr);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->a == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->a & 0x80);    return 0;}static uint8_t inst_eor(rp2a03_t *cpu, uint16_t addr){    cpu->a ^= cpu->read_mem(cpu->context, addr);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, cpu->a == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, cpu->a & 0x80);    return 0;}static uint8_t inst_adc(rp2a03_t *cpu, uint16_t addr){    uint8_t value = cpu->read_mem(cpu->context, addr);    uint16_t result = cpu->a + value + (rp2a03_get_flag(cpu, RP2A03_FLAG_CARRY) ? 1 : 0);    // Calcula flags    uint8_t overflow = ((cpu->a ^ result) & (value ^ result) & 0x80) != 0;    rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, result > 0xFF);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, (result & 0xFF) == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_OVERFLOW, overflow);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, result & 0x80);    cpu->a = result & 0xFF;    return 0;}static uint8_t inst_sbc(rp2a03_t *cpu, uint16_t addr){    uint8_t value = cpu->read_mem(cpu->context, addr);    uint16_t result = cpu->a - value - (rp2a03_get_flag(cpu, RP2A03_FLAG_CARRY) ? 0 : 1);    // Calcula flags    uint8_t overflow = ((cpu->a ^ result) & ((~value) ^ result) & 0x80) != 0;    rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, result < 0x100);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, (result & 0xFF) == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_OVERFLOW, overflow);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, result & 0x80);    cpu->a = result & 0xFF;    return 0;}// Instruções de comparaçãostatic uint8_t inst_cmp(rp2a03_t *cpu, uint16_t addr){    uint8_t value = cpu->read_mem(cpu->context, addr);    uint16_t result = cpu->a - value;    rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, cpu->a >= value);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, (result & 0xFF) == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, result & 0x80);    return 0;}static uint8_t inst_cpx(rp2a03_t *cpu, uint16_t addr){    uint8_t value = cpu->read_mem(cpu->context, addr);    uint16_t result = cpu->x - value;    rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, cpu->x >= value);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, (result & 0xFF) == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, result & 0x80);    return 0;}static uint8_t inst_cpy(rp2a03_t *cpu, uint16_t addr){    uint8_t value = cpu->read_mem(cpu->context, addr);    uint16_t result = cpu->y - value;    rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, cpu->y >= value);    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, (result & 0xFF) == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, result & 0x80);    return 0;}// Instruções de deslocamento (shifts) e rotação (rotates)static uint8_t inst_asl(rp2a03_t *cpu, uint16_t addr){    uint8_t value;    // Modo acumulador    if (addr == 0 && cpu->pc == (cpu->pc - 1) + 1)    {        value = cpu->a;        rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, value & 0x80);        value <<= 1;        cpu->a = value;    }    // Outros modos    else    {        value = cpu->read_mem(cpu->context, addr);        rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, value & 0x80);        value <<= 1;        cpu->write_mem(cpu->context, addr, value);    }    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, value == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, value & 0x80);    return 0;}static uint8_t inst_lsr(rp2a03_t *cpu, uint16_t addr){    uint8_t value;    // Modo acumulador    if (addr == 0 && cpu->pc == (cpu->pc - 1) + 1)    {        value = cpu->a;        rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, value & 0x01);        value >>= 1;        cpu->a = value;    }    // Outros modos    else    {        value = cpu->read_mem(cpu->context, addr);        rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, value & 0x01);        value >>= 1;        cpu->write_mem(cpu->context, addr, value);    }    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, value == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, 0); // Sempre 0    return 0;}static uint8_t inst_rol(rp2a03_t *cpu, uint16_t addr){    uint8_t value;    uint8_t old_carry = rp2a03_get_flag(cpu, RP2A03_FLAG_CARRY);    // Modo acumulador    if (addr == 0 && cpu->pc == (cpu->pc - 1) + 1)    {        value = cpu->a;        rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, value & 0x80);        value = (value << 1) | old_carry;        cpu->a = value;    }    // Outros modos    else    {        value = cpu->read_mem(cpu->context, addr);        rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, value & 0x80);        value = (value << 1) | old_carry;        cpu->write_mem(cpu->context, addr, value);    }    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, value == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, value & 0x80);    return 0;}static uint8_t inst_ror(rp2a03_t *cpu, uint16_t addr){    uint8_t value;    uint8_t old_carry = rp2a03_get_flag(cpu, RP2A03_FLAG_CARRY);    // Modo acumulador    if (addr == 0 && cpu->pc == (cpu->pc - 1) + 1)    {        value = cpu->a;        rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, value & 0x01);        value = (value >> 1) | (old_carry << 7);        cpu->a = value;    }    // Outros modos    else    {        value = cpu->read_mem(cpu->context, addr);        rp2a03_set_flag(cpu, RP2A03_FLAG_CARRY, value & 0x01);        value = (value >> 1) | (old_carry << 7);        cpu->write_mem(cpu->context, addr, value);    }    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, value == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, value & 0x80);    return 0;}// Instruções especiaisstatic uint8_t inst_bit(rp2a03_t *cpu, uint16_t addr){    uint8_t value = cpu->read_mem(cpu->context, addr);    uint8_t result = cpu->a & value;    rp2a03_set_flag(cpu, RP2A03_FLAG_ZERO, result == 0);    rp2a03_set_flag(cpu, RP2A03_FLAG_OVERFLOW, value & 0x40);    rp2a03_set_flag(cpu, RP2A03_FLAG_NEGATIVE, value & 0x80);    return 0;}static uint8_t inst_brk(rp2a03_t *cpu, uint16_t addr){    // BRK incrementa PC por 2 bytes (o byte BRK + padding)    cpu->pc++;    // Empilha PC    cpu->write_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp, (cpu->pc >> 8) & 0xFF);    cpu->sp--;    cpu->write_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp, cpu->pc & 0xFF);    cpu->sp--;    // Empilha status com B e bit 5 setados    uint8_t status = cpu->status | RP2A03_FLAG_BREAK | RP2A03_FLAG_UNUSED;    cpu->write_mem(cpu->context, RP2A03_STACK_BASE + cpu->sp, status);    cpu->sp--;    // Seta flag de interrupção    rp2a03_set_flag(cpu, RP2A03_FLAG_INTERRUPT, 1);    // Carrega vetor de IRQ    cpu->pc = read_word(cpu, RP2A03_IRQ_VECTOR);    return 0;}/** * @brief Lê uma palavra (16 bits) da memória em formato little-endian * * @param cpu Ponteiro para a CPU * @param addr Endereço de memória * @return uint16_t Palavra lida */static uint16_t read_word(rp2a03_t *cpu, uint16_t addr){    uint16_t value = cpu->read_mem(cpu->context, addr);    value |= (cpu->read_mem(cpu->context, addr + 1) << 8);    return value;}/** * @brief Inicializa a CPU RP2A03 * * @param config Configuração da CPU * @return rp2a03_t* Ponteiro para a CPU inicializada, ou NULL em caso de erro */rp2a03_t *rp2a03_init(const rp2a03_config_t *config){    if (!config)    {        CPU_LOG_ERROR("rp2a03_init: configuração inválida");        return NULL;    }    rp2a03_t *cpu = (rp2a03_t *)malloc(sizeof(rp2a03_t));    if (!cpu)    {        CPU_LOG_ERROR("rp2a03_init: falha na alocação de memória");        return NULL;    }    // Inicializa a CPU com valores padrão    memset(cpu, 0, sizeof(rp2a03_t));    // Configura as funções de acesso à memória    cpu->read_mem = config->read_mem;    cpu->write_mem = config->write_mem;    cpu->context = config->context;    cpu->log_level = config->log_level;    // Inicializa o estado da CPU    rp2a03_reset(cpu);    CPU_LOG_INFO("CPU RP2A03 inicializada com sucesso");    return cpu;}/** * @brief Finaliza a CPU RP2A03 e libera recursos * * @param cpu Ponteiro para a CPU */void rp2a03_shutdown(rp2a03_t *cpu){    if (!cpu)    {        CPU_LOG_WARN("rp2a03_shutdown: CPU já está desligada");        return;    }    CPU_LOG_INFO("Desligando CPU RP2A03");    // Libera o ponteiro da CPU    free(cpu);}/** * @brief Reseta a CPU RP2A03 * * @param cpu Ponteiro para a CPU */void rp2a03_reset(rp2a03_t *cpu){    if (!cpu)    {        CPU_LOG_ERROR("rp2a03_reset: CPU inválida");        return;    }    CPU_LOG_INFO("Resetando CPU RP2A03");    // Reseta registradores    cpu->a = 0;    cpu->x = 0;    cpu->y = 0;    cpu->sp = 0xFD;                                           // O ponteiro de pilha é inicializado em 0xFD após um reset    cpu->status = RP2A03_FLAG_INTERRUPT | RP2A03_FLAG_UNUSED; // Interrupção desabilitada e bit não usado sempre 1    // Lê o vetor de reset em 0xFFFC-0xFFFD    uint16_t reset_vector_lo = cpu->read_mem(cpu->context, 0xFFFC);    uint16_t reset_vector_hi = cpu->read_mem(cpu->context, 0xFFFD);    cpu->pc = (reset_vector_hi << 8) | reset_vector_lo;    // Reseta contador de ciclos e estado de interrupção    cpu->cycles = 0;    cpu->remaining_cycles = 0;    cpu->stall_cycles = 0;    cpu->pending_interrupt = RP2A03_INTERRUPT_NONE;    CPU_LOG_DEBUG("CPU resetada: PC=0x%04X, SP=0x%02X, Status=0x%02X",                  cpu->pc, cpu->sp, cpu->status);}/** * @brief Executa a CPU por um número específico de ciclos * * @param cpu Ponteiro para a CPU * @param cycles Número de ciclos a executar * @return int Número de ciclos realmente executados, ou código de erro negativo */int rp2a03_execute(rp2a03_t *cpu, int cycles){    if (!cpu)    {        CPU_LOG_ERROR("rp2a03_execute: CPU inválida");        return RP2A03_ERROR_INVALID_ADDRESS;    }    int executed_cycles = 0;    // Primeiro, verifica ciclos de stall (por DMA ou outros motivos)    if (cpu->stall_cycles > 0)    {        int stall_to_execute = (cpu->stall_cycles <= cycles) ? cpu->stall_cycles : cycles;        cpu->stall_cycles -= stall_to_execute;        executed_cycles += stall_to_execute;        cycles -= stall_to_execute;        if (cycles <= 0)        {            cpu->cycles += executed_cycles;            return executed_cycles;        }    }    // Processa interrupções pendentes    if (cpu->pending_interrupt != RP2A03_INTERRUPT_NONE)    {        int irq_cycles = 0;        switch (cpu->pending_interrupt)        {        case RP2A03_INTERRUPT_NMI:            // NMI: Salva PC e status na pilha, e salta para o vetor em 0xFFFA-0xFFFB            cpu->write_mem(cpu->context, 0x0100 + cpu->sp, (cpu->pc >> 8) & 0xFF);            cpu->sp = (cpu->sp - 1) & 0xFF;            cpu->write_mem(cpu->context, 0x0100 + cpu->sp, cpu->pc & 0xFF);            cpu->sp = (cpu->sp - 1) & 0xFF;            // Salva o status (com B = 0)            cpu->write_mem(cpu->context, 0x0100 + cpu->sp, (cpu->status & ~RP2A03_FLAG_BREAK) | RP2A03_FLAG_UNUSED);            cpu->sp = (cpu->sp - 1) & 0xFF;            // Define a flag de interrupção            cpu->status |= RP2A03_FLAG_INTERRUPT;            // Lê o vetor NMI            uint16_t nmi_vector_lo = cpu->read_mem(cpu->context, 0xFFFA);            uint16_t nmi_vector_hi = cpu->read_mem(cpu->context, 0xFFFB);            cpu->pc = (nmi_vector_hi << 8) | nmi_vector_lo;            irq_cycles = 7; // NMI leva 7 ciclos            executed_cycles += irq_cycles;            cycles -= irq_cycles;            break;        case RP2A03_INTERRUPT_IRQ:            // IRQ: Só processa se a flag I estiver desligada            if (!(cpu->status & RP2A03_FLAG_INTERRUPT))            {                // Salva PC e status na pilha                cpu->write_mem(cpu->context, 0x0100 + cpu->sp, (cpu->pc >> 8) & 0xFF);                cpu->sp = (cpu->sp - 1) & 0xFF;                cpu->write_mem(cpu->context, 0x0100 + cpu->sp, cpu->pc & 0xFF);                cpu->sp = (cpu->sp - 1) & 0xFF;                // Salva o status (com B = 0)                cpu->write_mem(cpu->context, 0x0100 + cpu->sp, (cpu->status & ~RP2A03_FLAG_BREAK) | RP2A03_FLAG_UNUSED);                cpu->sp = (cpu->sp - 1) & 0xFF;                // Define a flag de interrupção                cpu->status |= RP2A03_FLAG_INTERRUPT;                // Lê o vetor IRQ/BRK                uint16_t irq_vector_lo = cpu->read_mem(cpu->context, 0xFFFE);                uint16_t irq_vector_hi = cpu->read_mem(cpu->context, 0xFFFF);                cpu->pc = (irq_vector_hi << 8) | irq_vector_lo;                irq_cycles = 7; // IRQ leva 7 ciclos                executed_cycles += irq_cycles;                cycles -= irq_cycles;            }            break;        case RP2A03_INTERRUPT_RESET:            // Reset: Reinicia a CPU            rp2a03_reset(cpu);            irq_cycles = 7; // Reset leva 7 ciclos            executed_cycles += irq_cycles;            cycles -= irq_cycles;            break;        default:            break;        }        cpu->pending_interrupt = RP2A03_INTERRUPT_NONE;        if (cycles <= 0)        {            cpu->cycles += executed_cycles;            return executed_cycles;        }    }    // Executa instruções até atingir o número de ciclos solicitados    while (cycles > 0)    {        // Lê o opcode        uint8_t opcode = cpu->read_mem(cpu->context, cpu->pc++);        const rp2a03_instruction_t *instruction = &RP2A03_INSTRUCTIONS[opcode];        // Obtém o endereço efetivo baseado no modo de endereçamento        uint16_t addr = 0;        switch (instruction->addr_mode)        {        case RP2A03_ADDR_MODE_IMPLICIT:            addr = addr_implicit(cpu);            break;        case RP2A03_ADDR_MODE_ACCUMULATOR:            addr = addr_accumulator(cpu);            break;        case RP2A03_ADDR_MODE_IMMEDIATE:            addr = addr_immediate(cpu);            break;        case RP2A03_ADDR_MODE_ZERO_PAGE:            addr = addr_zero_page(cpu);            break;        case RP2A03_ADDR_MODE_ZERO_PAGE_X:            addr = addr_zero_page_x(cpu);            break;        case RP2A03_ADDR_MODE_ZERO_PAGE_Y:            addr = addr_zero_page_y(cpu);            break;        case RP2A03_ADDR_MODE_RELATIVE:            addr = addr_relative(cpu);            break;        case RP2A03_ADDR_MODE_ABSOLUTE:            addr = addr_absolute(cpu);            break;        case RP2A03_ADDR_MODE_ABSOLUTE_X:            addr = addr_absolute_x(cpu);            break;        case RP2A03_ADDR_MODE_ABSOLUTE_Y:            addr = addr_absolute_y(cpu);            break;        case RP2A03_ADDR_MODE_INDIRECT:            addr = addr_indirect(cpu);            break;        case RP2A03_ADDR_MODE_INDEXED_INDIRECT:            addr = addr_indexed_indirect(cpu);            break;        case RP2A03_ADDR_MODE_INDIRECT_INDEXED:            addr = addr_indirect_indexed(cpu);            break;        }        // Executa a instrução        uint8_t extra_cycles = instruction->execute(cpu, addr);        // Atualiza os ciclos        int total_cycles = instruction->cycles + extra_cycles;        executed_cycles += total_cycles;        cycles -= total_cycles;        CPU_LOG_DEBUG("Executado opcode 0x%02X (%s) em PC=0x%04X, ciclos=%d",                      opcode, instruction->name, cpu->pc - 1, total_cycles);    }    // Atualiza o contador total de ciclos    cpu->cycles += executed_cycles;    return executed_cycles;}/** * @brief Aciona uma interrupção na CPU * * @param cpu Ponteiro para a CPU * @param interrupt Tipo de interrupção */void rp2a03_trigger_interrupt(rp2a03_t *cpu, rp2a03_interrupt_t interrupt){    if (!cpu)    {        CPU_LOG_ERROR("rp2a03_trigger_interrupt: CPU inválida");        return;    }    // NMI tem maior prioridade, seguido por RESET e IRQ    if (interrupt == RP2A03_INTERRUPT_NMI)    {        cpu->pending_interrupt = RP2A03_INTERRUPT_NMI;    }    else if (interrupt == RP2A03_INTERRUPT_RESET)    {        if (cpu->pending_interrupt != RP2A03_INTERRUPT_NMI)        {            cpu->pending_interrupt = RP2A03_INTERRUPT_RESET;        }    }    else if (interrupt == RP2A03_INTERRUPT_IRQ)    {        if (cpu->pending_interrupt == RP2A03_INTERRUPT_NONE)        {            cpu->pending_interrupt = RP2A03_INTERRUPT_IRQ;        }    }}/** * @brief Adiciona ciclos de stall à CPU */void rp2a03_add_stall_cycles(rp2a03_t *cpu, int cycles){    if (!cpu || cycles <= 0)        return;    cpu->stall_cycles += cycles;    CPU_LOG_TRACE("RP2A03: Adicionados %d ciclos de stall, total: %d",                  cycles, cpu->stall_cycles);}/** * @brief Obtém o valor de um registrador da CPU */uint16_t rp2a03_get_register(rp2a03_t *cpu, const char *reg){    if (!cpu || !reg)        return 0;    if (strcmp(reg, "a") == 0)        return cpu->a;    if (strcmp(reg, "x") == 0)        return cpu->x;    if (strcmp(reg, "y") == 0)        return cpu->y;    if (strcmp(reg, "sp") == 0)        return cpu->sp;    if (strcmp(reg, "status") == 0)        return cpu->status;    if (strcmp(reg, "pc") == 0)        return cpu->pc;    CPU_LOG_WARN("RP2A03: Tentativa de obter registrador desconhecido: %s", reg);    return 0;}/** * @brief Define o valor de um registrador da CPU */void rp2a03_set_register(rp2a03_t *cpu, const char *reg, uint16_t value){    if (!cpu || !reg)        return;    if (strcmp(reg, "a") == 0)        cpu->a = value & 0xFF;    else if (strcmp(reg, "x") == 0)        cpu->x = value & 0xFF;    else if (strcmp(reg, "y") == 0)        cpu->y = value & 0xFF;    else if (strcmp(reg, "sp") == 0)        cpu->sp = value & 0xFF;    else if (strcmp(reg, "status") == 0)        cpu->status = value & 0xFF;    else if (strcmp(reg, "pc") == 0)        cpu->pc = value & 0xFFFF;    else        CPU_LOG_WARN("RP2A03: Tentativa de definir registrador desconhecido: %s", reg);}/** * @brief Verifica se uma flag do registrador de status está ativa */int rp2a03_get_flag(rp2a03_t *cpu, uint8_t flag){    if (!cpu)        return 0;    return (cpu->status & flag) ? 1 : 0;}/** * @brief Define ou limpa uma flag do registrador de status */void rp2a03_set_flag(rp2a03_t *cpu, uint8_t flag, int value){    if (!cpu)        return;    if (value)        cpu->status |= flag;    else        cpu->status &= ~flag;}/** * @brief Gera um dump do estado atual da CPU (para debug) */int rp2a03_dump_state(rp2a03_t *cpu, char *buffer, int buffer_size){    if (!cpu || !buffer || buffer_size <= 0)        return 0;    // Prepara string de flags    char flags[9];    flags[0] = (cpu->status & RP2A03_FLAG_NEGATIVE) ? 'N' : '.';    flags[1] = (cpu->status & RP2A03_FLAG_OVERFLOW) ? 'V' : '.';    flags[2] = (cpu->status & RP2A03_FLAG_UNUSED) ? 'U' : '.';    flags[3] = (cpu->status & RP2A03_FLAG_BREAK) ? 'B' : '.';    flags[4] = (cpu->status & RP2A03_FLAG_DECIMAL) ? 'D' : '.';    flags[5] = (cpu->status & RP2A03_FLAG_INTERRUPT) ? 'I' : '.';    flags[6] = (cpu->status & RP2A03_FLAG_ZERO) ? 'Z' : '.';    flags[7] = (cpu->status & RP2A03_FLAG_CARRY) ? 'C' : '.';    flags[8] = '\0';    // Gera string formatada com o estado    int bytes_written = snprintf(buffer, buffer_size,                                 "A:%02X X:%02X Y:%02X SP:%02X P:%02X (%s) PC:%04X CYC:%llu",                                 cpu->a, cpu->x, cpu->y, cpu->sp, cpu->status, flags, cpu->pc, cpu->cycles);    return bytes_written;}
