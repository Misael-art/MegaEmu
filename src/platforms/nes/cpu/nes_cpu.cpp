/** * @file nes_cpu.cpp * @brief Implementação da classe NESCPU para a CPU do NES em C++ * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-13 */#include "nes_cpu.hpp"#include <stdexcept>#include <iostream>namespace MegaEmu{    namespace Platforms    {        namespace NES        {            NESCPU::NESCPU(void *memory)                : m_cpu(nullptr), m_initialized(false)            {                // Inicializar CPU usando a interface C                m_cpu = nes_cpu_init(static_cast<struct nes_memory_t *>(memory));                if (!m_cpu)                {                    throw std::runtime_error("Falha ao inicializar NESCPU");                }                m_initialized = true;                std::cout << "NESCPU inicializada com sucesso" << std::endl;            }            NESCPU::~NESCPU()            {                if (m_cpu)                {                    nes_cpu_shutdown(m_cpu);                    m_cpu = nullptr;                }                m_initialized = false;                std::cout << "NESCPU destruída" << std::endl;            }            void NESCPU::initialize()            {                // A inicialização já é feita no construtor                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("NESCPU não está inicializada corretamente");                }            }            void NESCPU::reset()            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de resetar NESCPU não inicializada");                }                nes_cpu_reset(m_cpu);            }            void NESCPU::cycle()            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de executar ciclo em NESCPU não inicializada");                }                nes_cpu_cycle(m_cpu);            }            int NESCPU::step()            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de executar passo em NESCPU não inicializada");                }                return nes_cpu_step(m_cpu);            }            void NESCPU::triggerNMI()            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de disparar NMI em NESCPU não inicializada");                }                nes_cpu_trigger_nmi(m_cpu);            }            void NESCPU::triggerIRQ()            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de disparar IRQ em NESCPU não inicializada");                }                nes_cpu_trigger_irq(m_cpu);            }            void NESCPU::setMemoryCallbacks(nes_cpu_read_func_t readFunc, nes_cpu_write_func_t writeFunc, void *context)            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de configurar callbacks em NESCPU não inicializada");                }                nes_cpu_set_memory_callbacks(m_cpu, readFunc, writeFunc, context);            }            uint8_t NESCPU::getRegisterA() const            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de acessar registrador em NESCPU não inicializada");                }                return m_cpu->a;            }            uint8_t NESCPU::getRegisterX() const            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de acessar registrador em NESCPU não inicializada");                }                return m_cpu->x;            }            uint8_t NESCPU::getRegisterY() const            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de acessar registrador em NESCPU não inicializada");                }                return m_cpu->y;            }            uint8_t NESCPU::getStackPointer() const            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de acessar stack pointer em NESCPU não inicializada");                }                return m_cpu->s;            }            uint16_t NESCPU::getProgramCounter() const            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de acessar program counter em NESCPU não inicializada");                }                return m_cpu->pc;            }            uint8_t NESCPU::getStatusRegister() const            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de acessar registrador de status em NESCPU não inicializada");                }                return m_cpu->p;            }            uint32_t NESCPU::getCycles() const            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de acessar contador de ciclos em NESCPU não inicializada");                }                return m_cpu->cycles;            }            void NESCPU::setAPU(void *apu)            {                if (!m_initialized || !m_cpu)                {                    throw std::runtime_error("Tentativa de configurar APU em NESCPU não inicializada");                }                m_cpu->apu = static_cast<struct nes_apu_t *>(apu);            }        } // namespace NES    } // namespace Platforms} // namespace MegaEmu