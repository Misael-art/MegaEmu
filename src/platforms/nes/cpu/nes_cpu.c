#include "platforms/nes/cpu/nes_cpu.h" #include "platforms/nes/cpu/rp2a03.h" #include "utils/error_handling.h" #include "utils/enhanced_log.h" #include "utils/log_categories.h" #include "platforms/nes/memory/nes_memory.h" // Incluir header de memória#include <stdlib.h>// Macros de log específicas para o CPU#define CPU_LOG_INFO(msg, ...) EMU_LOG_INFO(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)#define CPU_LOG_ERROR(msg, ...) EMU_LOG_ERROR(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)#define CPU_LOG_TRACE(msg, ...) EMU_LOG_TRACE(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)#define CPU_LOG_WARN(msg, ...) EMU_LOG_WARN(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)#define CPU_LOG_DEBUG(msg, ...) EMU_LOG_DEBUG(EMU_LOG_CAT_CPU, msg, ##__VA_ARGS__)// Definições para opcodes ilegais/não-oficiaistypedef enum{    OP_TYPE_UNKNOWN = 0,    OP_TYPE_NOP, // No Operation (vários NOPs não oficiais)    OP_TYPE_LAX, // Load A and X with Memory    OP_TYPE_SAX, // Store A AND X    OP_TYPE_DCP, // Decrement Memory and Compare    OP_TYPE_ISC, // Increment Memory and Subtract with Carry    OP_TYPE_SLO, // Shift Left and OR    OP_TYPE_RLA, // Rotate Left and AND    OP_TYPE_SRE, // Shift Right and EOR    OP_TYPE_RRA, // Rotate Right and ADC    OP_TYPE_ANC, // AND with Carry    OP_TYPE_ALR, // AND + LSR    OP_TYPE_ARR, // AND + ROR    OP_TYPE_XAA, // Transfer X to A AND Immediate    OP_TYPE_AXS, // A AND X Minus Immediate    OP_TYPE_TAS, // Store A AND X AND H+1 into SP, A AND X AND H into Memory    OP_TYPE_LAS, // Load A, X and SP with Memory AND SP    OP_TYPE_AHX, // Store A AND X AND H into Memory    OP_TYPE_SHX, // Store X AND H into Memory    OP_TYPE_SHY  // Store Y AND H into Memory} illegal_opcode_type_t;typedef enum{    ADDR_MODE_UNKNOWN = 0,    ADDR_MODE_IMPLICIT,    ADDR_MODE_ACCUMULATOR,    ADDR_MODE_IMMEDIATE,    ADDR_MODE_ZERO_PAGE,    ADDR_MODE_ZERO_PAGE_X,    ADDR_MODE_ZERO_PAGE_Y,    ADDR_MODE_RELATIVE,    ADDR_MODE_ABSOLUTE,    ADDR_MODE_ABSOLUTE_X,    ADDR_MODE_ABSOLUTE_Y,    ADDR_MODE_INDIRECT,    ADDR_MODE_INDIRECT_X,    ADDR_MODE_INDIRECT_Y} addressing_mode_t;typedef struct{    uint8_t opcode;    illegal_opcode_type_t type;    addressing_mode_t addr_mode;    uint8_t cycles;    const char *name;} illegal_opcode_info_t;// Tabela de opcodes ilegais/não-oficiaisconst illegal_opcode_info_t illegal_opcodes[] = {    // NOPs não oficiais (alguns com diferentes modos de endereçamento)    {0x1A, OP_TYPE_NOP, ADDR_MODE_IMPLICIT, 2, "NOP (Illegal)"},    {0x3A, OP_TYPE_NOP, ADDR_MODE_IMPLICIT, 2, "NOP (Illegal)"},    {0x5A, OP_TYPE_NOP, ADDR_MODE_IMPLICIT, 2, "NOP (Illegal)"},    {0x7A, OP_TYPE_NOP, ADDR_MODE_IMPLICIT, 2, "NOP (Illegal)"},    {0xDA, OP_TYPE_NOP, ADDR_MODE_IMPLICIT, 2, "NOP (Illegal)"},    {0xFA, OP_TYPE_NOP, ADDR_MODE_IMPLICIT, 2, "NOP (Illegal)"},    {0x80, OP_TYPE_NOP, ADDR_MODE_IMMEDIATE, 2, "NOP (Illegal)"},    {0x82, OP_TYPE_NOP, ADDR_MODE_IMMEDIATE, 2, "NOP (Illegal)"},    {0x89, OP_TYPE_NOP, ADDR_MODE_IMMEDIATE, 2, "NOP (Illegal)"},    {0xC2, OP_TYPE_NOP, ADDR_MODE_IMMEDIATE, 2, "NOP (Illegal)"},    {0xE2, OP_TYPE_NOP, ADDR_MODE_IMMEDIATE, 2, "NOP (Illegal)"},    {0x04, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE, 3, "NOP (Illegal)"},    {0x44, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE, 3, "NOP (Illegal)"},    {0x64, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE, 3, "NOP (Illegal)"},    {0x14, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE_X, 4, "NOP (Illegal)"},    {0x34, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE_X, 4, "NOP (Illegal)"},    {0x54, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE_X, 4, "NOP (Illegal)"},    {0x74, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE_X, 4, "NOP (Illegal)"},    {0xD4, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE_X, 4, "NOP (Illegal)"},    {0xF4, OP_TYPE_NOP, ADDR_MODE_ZERO_PAGE_X, 4, "NOP (Illegal)"},    {0x0C, OP_TYPE_NOP, ADDR_MODE_ABSOLUTE, 4, "NOP (Illegal)"},    {0x1C, OP_TYPE_NOP, ADDR_MODE_ABSOLUTE_X, 4, "NOP (Illegal)"},    {0x3C, OP_TYPE_NOP, ADDR_MODE_ABSOLUTE_X, 4, "NOP (Illegal)"},    {0x5C, OP_TYPE_NOP, ADDR_MODE_ABSOLUTE_X, 4, "NOP (Illegal)"},    {0x7C, OP_TYPE_NOP, ADDR_MODE_ABSOLUTE_X, 4, "NOP (Illegal)"},    {0xDC, OP_TYPE_NOP, ADDR_MODE_ABSOLUTE_X, 4, "NOP (Illegal)"},    {0xFC, OP_TYPE_NOP, ADDR_MODE_ABSOLUTE_X, 4, "NOP (Illegal)"},    // Opcodes ilegais específicos que estavam faltando na implementação    {0x6B, OP_TYPE_ARR, ADDR_MODE_IMMEDIATE, 2, "ARR (Illegal)"},    {0x22, OP_TYPE_SAX, ADDR_MODE_ZERO_PAGE, 3, "SAX (Illegal)"},    {0x73, OP_TYPE_RRA, ADDR_MODE_INDIRECT_Y, 8, "RRA (Illegal)"},    {0x40, OP_TYPE_UNKNOWN, ADDR_MODE_IMPLICIT, 6, "RTI"}, // RTI é oficial, não ilegal    {0x5F, OP_TYPE_SRE, ADDR_MODE_ABSOLUTE_X, 7, "SRE (Illegal)"},    {0xEF, OP_TYPE_ISC, ADDR_MODE_ABSOLUTE, 6, "ISC (Illegal)"},    {0x0E, OP_TYPE_UNKNOWN, ADDR_MODE_ABSOLUTE, 6, "ASL"},    // ASL é oficial, não ilegal    {0xDD, OP_TYPE_UNKNOWN, ADDR_MODE_ABSOLUTE_X, 4, "CMP"},  // CMP é oficial, não ilegal    {0x2A, OP_TYPE_UNKNOWN, ADDR_MODE_ACCUMULATOR, 2, "ROL"}, // ROL é oficial, não ilegal    // Outros opcodes ilegais importantes    {0xA7, OP_TYPE_LAX, ADDR_MODE_ZERO_PAGE, 3, "LAX (Illegal)"},    {0xB7, OP_TYPE_LAX, ADDR_MODE_ZERO_PAGE_Y, 4, "LAX (Illegal)"},    {0xAF, OP_TYPE_LAX, ADDR_MODE_ABSOLUTE, 4, "LAX (Illegal)"},    {0xBF, OP_TYPE_LAX, ADDR_MODE_ABSOLUTE_Y, 4, "LAX (Illegal)"},    {0xA3, OP_TYPE_LAX, ADDR_MODE_INDIRECT_X, 6, "LAX (Illegal)"},    {0xB3, OP_TYPE_LAX, ADDR_MODE_INDIRECT_Y, 5, "LAX (Illegal)"},    {0x87, OP_TYPE_SAX, ADDR_MODE_ZERO_PAGE, 3, "SAX (Illegal)"},    {0x97, OP_TYPE_SAX, ADDR_MODE_ZERO_PAGE_Y, 4, "SAX (Illegal)"},    {0x8F, OP_TYPE_SAX, ADDR_MODE_ABSOLUTE, 4, "SAX (Illegal)"},    {0x83, OP_TYPE_SAX, ADDR_MODE_INDIRECT_X, 6, "SAX (Illegal)"},    {0xC7, OP_TYPE_DCP, ADDR_MODE_ZERO_PAGE, 5, "DCP (Illegal)"},    {0xD7, OP_TYPE_DCP, ADDR_MODE_ZERO_PAGE_X, 6, "DCP (Illegal)"},    {0xCF, OP_TYPE_DCP, ADDR_MODE_ABSOLUTE, 6, "DCP (Illegal)"},    {0xDF, OP_TYPE_DCP, ADDR_MODE_ABSOLUTE_X, 7, "DCP (Illegal)"},    {0xDB, OP_TYPE_DCP, ADDR_MODE_ABSOLUTE_Y, 7, "DCP (Illegal)"},    {0xC3, OP_TYPE_DCP, ADDR_MODE_INDIRECT_X, 8, "DCP (Illegal)"},    {0xD3, OP_TYPE_DCP, ADDR_MODE_INDIRECT_Y, 8, "DCP (Illegal)"},    {0x07, OP_TYPE_SLO, ADDR_MODE_ZERO_PAGE, 5, "SLO (Illegal)"},    {0x17, OP_TYPE_SLO, ADDR_MODE_ZERO_PAGE_X, 6, "SLO (Illegal)"},    {0x0F, OP_TYPE_SLO, ADDR_MODE_ABSOLUTE, 6, "SLO (Illegal)"},    {0x1F, OP_TYPE_SLO, ADDR_MODE_ABSOLUTE_X, 7, "SLO (Illegal)"},    {0x1B, OP_TYPE_SLO, ADDR_MODE_ABSOLUTE_Y, 7, "SLO (Illegal)"},    {0x03, OP_TYPE_SLO, ADDR_MODE_INDIRECT_X, 8, "SLO (Illegal)"},    {0x13, OP_TYPE_SLO, ADDR_MODE_INDIRECT_Y, 8, "SLO (Illegal)"},    {0xE7, OP_TYPE_ISC, ADDR_MODE_ZERO_PAGE, 5, "ISC (Illegal)"},    {0xF7, OP_TYPE_ISC, ADDR_MODE_ZERO_PAGE_X, 6, "ISC (Illegal)"},    {0xE3, OP_TYPE_ISC, ADDR_MODE_INDIRECT_X, 8, "ISC (Illegal)"},    {0xF3, OP_TYPE_ISC, ADDR_MODE_INDIRECT_Y, 8, "ISC (Illegal)"},    {0xEB, OP_TYPE_ISC, ADDR_MODE_IMMEDIATE, 2, "ISC (Illegal)"},    {0xFB, OP_TYPE_ISC, ADDR_MODE_ABSOLUTE_Y, 7, "ISC (Illegal)"},    {0x27, OP_TYPE_RLA, ADDR_MODE_ZERO_PAGE, 5, "RLA (Illegal)"},    {0x37, OP_TYPE_RLA, ADDR_MODE_ZERO_PAGE_X, 6, "RLA (Illegal)"},    {0x2F, OP_TYPE_RLA, ADDR_MODE_ABSOLUTE, 6, "RLA (Illegal)"},    {0x3F, OP_TYPE_RLA, ADDR_MODE_ABSOLUTE_X, 7, "RLA (Illegal)"},    {0x3B, OP_TYPE_RLA, ADDR_MODE_ABSOLUTE_Y, 7, "RLA (Illegal)"},    {0x23, OP_TYPE_RLA, ADDR_MODE_INDIRECT_X, 8, "RLA (Illegal)"},    {0x33, OP_TYPE_RLA, ADDR_MODE_INDIRECT_Y, 8, "RLA (Illegal)"},    {0x47, OP_TYPE_SRE, ADDR_MODE_ZERO_PAGE, 5, "SRE (Illegal)"},    {0x57, OP_TYPE_SRE, ADDR_MODE_ZERO_PAGE_X, 6, "SRE (Illegal)"},    {0x4F, OP_TYPE_SRE, ADDR_MODE_ABSOLUTE, 6, "SRE (Illegal)"},    {0x5B, OP_TYPE_SRE, ADDR_MODE_ABSOLUTE_Y, 7, "SRE (Illegal)"},    {0x43, OP_TYPE_SRE, ADDR_MODE_INDIRECT_X, 8, "SRE (Illegal)"},    {0x53, OP_TYPE_SRE, ADDR_MODE_INDIRECT_Y, 8, "SRE (Illegal)"},    {0x67, OP_TYPE_RRA, ADDR_MODE_ZERO_PAGE, 5, "RRA (Illegal)"},    {0x77, OP_TYPE_RRA, ADDR_MODE_ZERO_PAGE_X, 6, "RRA (Illegal)"},    {0x6F, OP_TYPE_RRA, ADDR_MODE_ABSOLUTE, 6, "RRA (Illegal)"},    {0x7F, OP_TYPE_RRA, ADDR_MODE_ABSOLUTE_X, 7, "RRA (Illegal)"},    {0x7B, OP_TYPE_RRA, ADDR_MODE_ABSOLUTE_Y, 7, "RRA (Illegal)"},    {0x63, OP_TYPE_RRA, ADDR_MODE_INDIRECT_X, 8, "RRA (Illegal)"},    {0x0B, OP_TYPE_ANC, ADDR_MODE_IMMEDIATE, 2, "ANC (Illegal)"},    {0x2B, OP_TYPE_ANC, ADDR_MODE_IMMEDIATE, 2, "ANC (Illegal)"},    {0x4B, OP_TYPE_ALR, ADDR_MODE_IMMEDIATE, 2, "ALR (Illegal)"},    {0x8B, OP_TYPE_XAA, ADDR_MODE_IMMEDIATE, 2, "XAA (Illegal)"},    {0xCB, OP_TYPE_AXS, ADDR_MODE_IMMEDIATE, 2, "AXS (Illegal)"},    {0x9F, OP_TYPE_AHX, ADDR_MODE_ABSOLUTE_Y, 5, "AHX (Illegal)"},    {0x93, OP_TYPE_AHX, ADDR_MODE_INDIRECT_Y, 6, "AHX (Illegal)"},    {0x9E, OP_TYPE_SHX, ADDR_MODE_ABSOLUTE_Y, 5, "SHX (Illegal)"},    {0x9C, OP_TYPE_SHY, ADDR_MODE_ABSOLUTE_X, 5, "SHY (Illegal)"},    {0x9B, OP_TYPE_TAS, ADDR_MODE_ABSOLUTE_Y, 5, "TAS (Illegal)"},    {0xBB, OP_TYPE_LAS, ADDR_MODE_ABSOLUTE_Y, 4, "LAS (Illegal)"},    // Marca o fim da tabela    {0, OP_TYPE_UNKNOWN, ADDR_MODE_UNKNOWN, 0, NULL}};// Procura informações sobre um opcode ilegalconst illegal_opcode_info_t *find_illegal_opcode(uint8_t opcode){    for (int i = 0; illegal_opcodes[i].name != NULL; i++)    {        if (illegal_opcodes[i].opcode == opcode)        {            return &illegal_opcodes[i];        }    }    return NULL;}// Implementa a lógica para opcodes ilegais/não-oficiaisstatic int execute_illegal_opcode(nes_cpu_t *cpu, const illegal_opcode_info_t *info){    if (!cpu || !info)        return 0;    uint8_t opcode = info->opcode;    uint8_t cycles = info->cycles;    uint16_t addr = 0;    uint8_t value = 0;    uint16_t result = 0;    uint8_t temp = 0;    // Pre-calcula o endereço efetivo com base no modo de endereçamento    switch (info->addr_mode)    {    case ADDR_MODE_IMMEDIATE:        addr = cpu->pc++;        value = cpu->read_mem(cpu->context, addr);        break;    case ADDR_MODE_ZERO_PAGE:        addr = cpu->read_mem(cpu->context, cpu->pc++);        value = cpu->read_mem(cpu->context, addr);        break;    case ADDR_MODE_ZERO_PAGE_X:        addr = (cpu->read_mem(cpu->context, cpu->pc++) + cpu->x) & 0xFF;        value = cpu->read_mem(cpu->context, addr);        break;    case ADDR_MODE_ZERO_PAGE_Y:        addr = (cpu->read_mem(cpu->context, cpu->pc++) + cpu->y) & 0xFF;        value = cpu->read_mem(cpu->context, addr);        break;    case ADDR_MODE_ABSOLUTE:        addr = cpu->read_mem(cpu->context, cpu->pc++);        addr |= cpu->read_mem(cpu->context, cpu->pc++) << 8;        value = cpu->read_mem(cpu->context, addr);        break;    case ADDR_MODE_ABSOLUTE_X:    {        uint16_t base_addr = cpu->read_mem(cpu->context, cpu->pc++);        base_addr |= cpu->read_mem(cpu->context, cpu->pc++) << 8;        addr = base_addr + cpu->x;        value = cpu->read_mem(cpu->context, addr);    }    break;    case ADDR_MODE_ABSOLUTE_Y:    {        uint16_t base_addr = cpu->read_mem(cpu->context, cpu->pc++);        base_addr |= cpu->read_mem(cpu->context, cpu->pc++) << 8;        addr = base_addr + cpu->y;        value = cpu->read_mem(cpu->context, addr);    }    break;    case ADDR_MODE_INDIRECT_X:    {        uint8_t zp_addr = (cpu->read_mem(cpu->context, cpu->pc++) + cpu->x) & 0xFF;        addr = cpu->read_mem(cpu->context, zp_addr);        addr |= cpu->read_mem(cpu->context, (zp_addr + 1) & 0xFF) << 8;        value = cpu->read_mem(cpu->context, addr);    }    break;    case ADDR_MODE_INDIRECT_Y:    {        uint8_t zp_addr = cpu->read_mem(cpu->context, cpu->pc++);        uint16_t base_addr = cpu->read_mem(cpu->context, zp_addr);        base_addr |= cpu->read_mem(cpu->context, (zp_addr + 1) & 0xFF) << 8;        addr = base_addr + cpu->y;        value = cpu->read_mem(cpu->context, addr);    }    break;    case ADDR_MODE_ACCUMULATOR:    case ADDR_MODE_IMPLICIT:        // Não precisa de endereço        break;    default:        CPU_LOG_WARN("Modo de endereçamento desconhecido para opcode ilegal 0x%02X", opcode);        break;    }    // Executa a operação baseada no tipo de opcode    switch (info->type)    {    case OP_TYPE_NOP:        // Já consumimos os bytes no cálculo de endereço, não precisa fazer nada        break;    case OP_TYPE_LAX:        // Carrega o mesmo valor em A e X        cpu->a = cpu->x = value;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    case OP_TYPE_SAX:        // Armazena A AND X        cpu->write_mem(cpu->context, addr, cpu->a & cpu->x);        break;    case OP_TYPE_DCP:        // Decrementa memória        value = (value - 1) & 0xFF;        cpu->write_mem(cpu->context, addr, value);        // Compara com acumulador (como CMP)        result = cpu->a - value;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a >= value)            cpu->p |= RP2A03_FLAG_CARRY;        if (cpu->a == value)            cpu->p |= RP2A03_FLAG_ZERO;        if ((result & 0x80) != 0)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    case OP_TYPE_ISC:        // Incrementa memória        value = (value + 1) & 0xFF;        cpu->write_mem(cpu->context, addr, value);        // Subtrai do acumulador com carry (como SBC)        result = cpu->a - value - (!(cpu->p & RP2A03_FLAG_CARRY) ? 1 : 0);        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_OVERFLOW | RP2A03_FLAG_NEGATIVE));        if (result <= 0xFF)            cpu->p |= RP2A03_FLAG_CARRY;        if ((result & 0xFF) == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (((cpu->a ^ value) & 0x80) && ((cpu->a ^ result) & 0x80))            cpu->p |= RP2A03_FLAG_OVERFLOW;        if (result & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        cpu->a = result & 0xFF;        break;    case OP_TYPE_SLO:        // Shift Left        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (value & 0x80)            cpu->p |= RP2A03_FLAG_CARRY;        value <<= 1;        cpu->write_mem(cpu->context, addr, value);        // OR com acumulador        cpu->a |= value;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    case OP_TYPE_RLA:        // Rotate Left        temp = (value << 1) | (cpu->p & RP2A03_FLAG_CARRY ? 1 : 0);        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (value & 0x80)            cpu->p |= RP2A03_FLAG_CARRY;        cpu->write_mem(cpu->context, addr, temp);        // AND com acumulador        cpu->a &= temp;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    case OP_TYPE_SRE:        // Shift Right        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (value & 0x01)            cpu->p |= RP2A03_FLAG_CARRY;        value >>= 1;        cpu->write_mem(cpu->context, addr, value);        // EOR com acumulador        cpu->a ^= value;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    case OP_TYPE_RRA:        // Rotate Right        temp = (value >> 1) | (cpu->p & RP2A03_FLAG_CARRY ? 0x80 : 0);        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (value & 0x01)            cpu->p |= RP2A03_FLAG_CARRY;        cpu->write_mem(cpu->context, addr, temp);        // ADC        result = cpu->a + temp + (cpu->p & RP2A03_FLAG_CARRY ? 1 : 0);        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_OVERFLOW | RP2A03_FLAG_NEGATIVE));        if (result > 0xFF)            cpu->p |= RP2A03_FLAG_CARRY;        if ((result & 0xFF) == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if ((~(cpu->a ^ temp) & (cpu->a ^ result) & 0x80) != 0)            cpu->p |= RP2A03_FLAG_OVERFLOW;        if (result & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        cpu->a = result & 0xFF;        break;    case OP_TYPE_ANC:        // AND + set Carry as bit 7        cpu->a &= value;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)        {            cpu->p |= RP2A03_FLAG_NEGATIVE;            cpu->p |= RP2A03_FLAG_CARRY;        }        break;    case OP_TYPE_ALR:        // AND + LSR        cpu->a &= value;        // LSR        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (cpu->a & 0x01)            cpu->p |= RP2A03_FLAG_CARRY;        cpu->a >>= 1;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    case OP_TYPE_ARR:        // AND + ROR (comportamento complexo)        cpu->a &= value;        // ROR        temp = cpu->a;        cpu->a = (cpu->a >> 1) | (cpu->p & RP2A03_FLAG_CARRY ? 0x80 : 0);        // Flags especiais para ARR        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_OVERFLOW | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        if ((cpu->a >> 6) & 0x01)            cpu->p |= RP2A03_FLAG_CARRY;        if (((cpu->a >> 6) & 0x01) ^ ((cpu->a >> 5) & 0x01))            cpu->p |= RP2A03_FLAG_OVERFLOW;        break;    case OP_TYPE_XAA:        // Operação instável/não-determinística - simplificando        cpu->a = cpu->x & value;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    case OP_TYPE_AXS:        // A AND X - value        result = (cpu->a & cpu->x) - value;        cpu->x = result & 0xFF;        // Atualiza flags        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (result <= 0xFF)            cpu->p |= RP2A03_FLAG_CARRY;        if (cpu->x == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->x & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    // Outras implementações para opcodes mais raros ou com comportamento instável    case OP_TYPE_TAS:    case OP_TYPE_LAS:    case OP_TYPE_AHX:    case OP_TYPE_SHX:    case OP_TYPE_SHY:        // Estes opcodes têm comportamento instável ou dependente de hardware        // Implementamos o comportamento mais comum documentado        CPU_LOG_WARN("Opcode instável 0x%02X (%s) executado em PC=0x%04X",                     opcode, info->name, cpu->pc - 1);        break;    case OP_TYPE_UNKNOWN:    default:        CPU_LOG_WARN("Tipo de opcode ilegal desconhecido: 0x%02X", opcode);        break;    }    CPU_LOG_TRACE("Executado opcode ilegal/não oficial 0x%02X (%s) em PC=0x%04X",                  opcode, info->name, cpu->pc - 1);    return cycles;}/** * @brief Inicializa o CPU do NES * @param memory Ponteiro para o subsistema de memória * @return Ponteiro para o CPU inicializado, ou NULL em caso de erro */nes_cpu_t *nes_cpu_init(struct nes_memory_t *memory){    if (!memory)    {        CPU_LOG_ERROR("Ponteiro de memória inválido");        return NULL;    }    nes_cpu_t *cpu = (nes_cpu_t *)calloc(1, sizeof(nes_cpu_t));    if (!cpu)    {        CPU_LOG_ERROR("Falha ao alocar memória para o CPU");        return NULL;    }    // Inicializa os registradores    cpu->a = 0;    cpu->x = 0;    cpu->y = 0;    cpu->s = 0xFD;    cpu->p = 0x34;    cpu->pc = 0xC000;    // Inicializa o estado interno    cpu->cycles = 0;    cpu->irq_pending = 0;    cpu->nmi_pending = 0;    cpu->reset_pending = 0;    // Configura o ponteiro de memória    cpu->memory = memory;    // Inicializa os ponteiros de função    cpu->read_mem = NULL;    cpu->write_mem = NULL;    cpu->context = NULL;    CPU_LOG_INFO("CPU inicializado com sucesso");    return cpu;}/** * @brief Configura as funções de acesso à memória * @param cpu Ponteiro para o CPU * @param read_func Função para leitura de memória * @param write_func Função para escrita em memória * @param context Contexto para as funções de memória */void nes_cpu_set_memory_callbacks(nes_cpu_t *cpu,                                  nes_cpu_read_func_t read_func,                                  nes_cpu_write_func_t write_func,                                  void *context){    if (!cpu)    {        CPU_LOG_ERROR("nes_cpu_set_memory_callbacks: CPU é NULL");        return;    }    cpu->read_mem = read_func;    cpu->write_mem = write_func;    cpu->context = context;}/** * @brief Finaliza e libera recursos do CPU * @param cpu Ponteiro para o CPU */void nes_cpu_shutdown(nes_cpu_t *cpu){    if (!cpu)    {        CPU_LOG_WARN("Tentativa de finalizar CPU NULL");        return;    }    free(cpu);    CPU_LOG_INFO("CPU finalizado");}/** * @brief Reseta o estado do CPU * @param cpu Ponteiro para o CPU */void nes_cpu_reset(nes_cpu_t *cpu){    if (!cpu)    {        CPU_LOG_ERROR("Tentativa de resetar CPU NULL");        return;    }    // Reseta registradores    cpu->a = 0;    cpu->x = 0;    cpu->y = 0;    cpu->s = 0xFD;    cpu->p = 0x34; // Seta o flag I (interrupções desativadas) e o bit 5 que é sempre 1 no RP2A03    // Reseta estado interno    cpu->cycles = 0;    cpu->irq_pending = 0;    cpu->nmi_pending = 0;    cpu->reset_pending = 0;    // Lê o vetor de reset (0xFFFC-0xFFFD) para determinar o endereço inicial    if (cpu->read_mem && cpu->context)    {        uint8_t lo = cpu->read_mem(cpu->context, 0xFFFC);        uint8_t hi = cpu->read_mem(cpu->context, 0xFFFD);        cpu->pc = (hi << 8) | lo;        // Log detalhado do vetor de reset para diagnóstico        CPU_LOG_INFO("CPU resetado. Vetor de reset: 0x%04X (lo=0x%02X, hi=0x%02X)",                     cpu->pc, lo, hi);        // Verificação adicional para evitar problemas de PC inválido        if (cpu->pc < 0x8000 || cpu->pc > 0xFFFF)        {            CPU_LOG_WARN("Vetor de reset aponta para endereço potencialmente inválido: 0x%04X", cpu->pc);            // Em caso de vetor de reset obviamente inválido, use um fallback            if (cpu->pc == 0x0000)            {                cpu->pc = 0x8000; // Endereço comum de início da ROM                CPU_LOG_WARN("Vetor de reset detectado como 0x0000, usando fallback para 0x8000");            }        }    }    else    {        // Fallback para valor padrão se as funções de memória não estiverem disponíveis        cpu->pc = 0x8000; // Mais comum que o antigo 0xC000        CPU_LOG_WARN("CPU resetado com endereço padrão: 0x8000. Funções de memória não disponíveis.");    }    // Verificação adicional da matriz de memória    if (cpu->memory == NULL)    {        CPU_LOG_ERROR("CPU reset: Ponteiro de memória é NULL");    }    // Re-configuração de callbacks de memória, se necessário    if (cpu->memory && (!cpu->read_mem || !cpu->write_mem || !cpu->context))    {        CPU_LOG_WARN("CPU reset: Reconfigurando callbacks de memória");        cpu->read_mem = (nes_cpu_read_func_t)nes_memory_cpu_read;        cpu->write_mem = (nes_cpu_write_func_t)nes_memory_cpu_write;        cpu->context = cpu->memory;    }}/** * @brief Gera uma interrupção NMI no CPU * @param cpu Ponteiro para o CPU */void nes_cpu_trigger_nmi(nes_cpu_t *cpu){    if (!cpu)    {        CPU_LOG_ERROR("Tentativa de gerar NMI em CPU NULL");        return;    }    cpu->nmi_pending = 1;    CPU_LOG_TRACE("NMI gerado");}/** * @brief Gera uma interrupção IRQ no CPU * @param cpu Ponteiro para o CPU */void nes_cpu_trigger_irq(nes_cpu_t *cpu){    if (!cpu)    {        CPU_LOG_ERROR("Tentativa de gerar IRQ em CPU NULL");        return;    }    cpu->irq_pending = 1;    CPU_LOG_TRACE("IRQ gerado");}/** * @brief Executa uma instrução do CPU e retorna o número de ciclos utilizados * @param cpu Ponteiro para o CPU * @return Número de ciclos utilizados */int nes_cpu_step(nes_cpu_t *cpu){    if (!cpu || !cpu->read_mem || !cpu->context)    {        CPU_LOG_ERROR("Tentativa de executar instrução com CPU inválido ou não configurado");        return 0;    }    // Verificar e processar interrupções pendentes    if (cpu->nmi_pending)    {        // Processar NMI (Non-Maskable Interrupt)        cpu->nmi_pending = 0;        // Salva o PC atual na pilha (primeiro byte mais significativo, depois menos significativo)        cpu->write_mem(cpu->context, 0x0100 + cpu->s, (cpu->pc >> 8) & 0xFF);        cpu->s = (cpu->s - 1) & 0xFF;        cpu->write_mem(cpu->context, 0x0100 + cpu->s, cpu->pc & 0xFF);        cpu->s = (cpu->s - 1) & 0xFF;        // Salva o registrador de status na pilha (com o bit B limpo)        cpu->write_mem(cpu->context, 0x0100 + cpu->s, cpu->p & ~RP2A03_FLAG_BREAK);        cpu->s = (cpu->s - 1) & 0xFF;        // Desabilita interrupções e limpa o flag decimal (esse último não tem efeito no NES, mas é o comportamento padrão)        cpu->p |= RP2A03_FLAG_INTERRUPT;        cpu->p &= ~RP2A03_FLAG_DECIMAL;        // Carrega endereço do handler de NMI (0xFFFA-0xFFFB)        uint16_t nmi_vector = cpu->read_mem(cpu->context, 0xFFFA) | (cpu->read_mem(cpu->context, 0xFFFB) << 8);        cpu->pc = nmi_vector;        return 7; // NMI leva 7 ciclos    }    else if (cpu->irq_pending && !(cpu->p & RP2A03_FLAG_INTERRUPT))    {        // Processar IRQ (Interrupt Request) - apenas se o flag I estiver limpo        cpu->irq_pending = 0;        // Salva o PC atual na pilha        cpu->write_mem(cpu->context, 0x0100 + cpu->s, (cpu->pc >> 8) & 0xFF);        cpu->s = (cpu->s - 1) & 0xFF;        cpu->write_mem(cpu->context, 0x0100 + cpu->s, cpu->pc & 0xFF);        cpu->s = (cpu->s - 1) & 0xFF;        // Salva o registrador de status na pilha (com o bit B limpo)        cpu->write_mem(cpu->context, 0x0100 + cpu->s, cpu->p & ~RP2A03_FLAG_BREAK);        cpu->s = (cpu->s - 1) & 0xFF;        // Desabilita interrupções e limpa o flag decimal        cpu->p |= RP2A03_FLAG_INTERRUPT;        cpu->p &= ~RP2A03_FLAG_DECIMAL;        // Carrega endereço do handler de IRQ/BRK (0xFFFE-0xFFFF)        uint16_t irq_vector = cpu->read_mem(cpu->context, 0xFFFE) | (cpu->read_mem(cpu->context, 0xFFFF) << 8);        cpu->pc = irq_vector;        return 7; // IRQ leva 7 ciclos    }    else if (cpu->reset_pending)    {        // Processar RESET        cpu->reset_pending = 0;        // Não salva nada na pilha, apenas redefine registradores e carrega o vetor de reset        cpu->s = (cpu->s - 3) & 0xFF;    // Decrementa o SP como se tivesse empilhado 3 bytes, mas sem escrever        cpu->p |= RP2A03_FLAG_INTERRUPT; // Desabilita interrupções        cpu->p &= ~RP2A03_FLAG_DECIMAL;  // Limpa o flag decimal        // Carrega endereço do handler de RESET (0xFFFC-0xFFFD)        uint16_t reset_vector = cpu->read_mem(cpu->context, 0xFFFC) | (cpu->read_mem(cpu->context, 0xFFFD) << 8);        // Registra em log o valor do vetor de reset para debug        CPU_LOG_INFO("Vetor de reset lido: 0x%04X", reset_vector);        cpu->pc = reset_vector;        return 7; // RESET leva 7 ciclos (emulação simplificada)    }    // Se chegou aqui, não havia interrupções a processar, então executa a próxima instrução    // Lê o próximo opcode    uint8_t opcode = cpu->read_mem(cpu->context, cpu->pc++);    int cycles = 0;    // Debug - Logar instrução em execução    CPU_LOG_TRACE("Executando opcode 0x%02X em PC=0x%04X", opcode, cpu->pc - 1);    // Executa a instrução correspondente ao opcode    switch (opcode)    {    case 0x78: // SEI - Set Interrupt Disable        cpu->p |= 0x04;        break;    case 0x38: // SEC - Set Carry Flag    {        cpu->p |= 0x01; // Set carry flag        cycles = 2;        break;    }    case 0x18: // CLC - Clear Carry Flag    {        cpu->p &= ~0x01; // Clear carry flag        cycles = 2;        break;    }    case 0xF8: // SED - Set Decimal Flag    {        cpu->p |= 0x08; // Set decimal flag        cycles = 2;        break;    }    case 0x58: // CLI - Clear Interrupt Flag    {        cpu->p &= ~0x04; // Clear interrupt flag        cycles = 2;        break;    }    case 0xD8: // CLD - Clear Decimal Flag    {        cpu->p &= ~0x08; // Clear decimal flag        cycles = 2;        break;    }    case 0x69: // ADC Immediate    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        uint16_t result = cpu->a + value + (cpu->p & 0x01);        // Atualiza flags        cpu->p = (cpu->p & 0x3C) |                                                // Mantém flags não afetadas                 ((result > 0xFF) ? 0x01 : 0x00) |                                // Carry                 ((~(cpu->a ^ value) & (cpu->a ^ result) & 0x80) ? 0x40 : 0x00) | // Overflow                 ((result & 0x80) ? 0x80 : 0x00) |                                // Negative                 ((result & 0xFF) ? 0x00 : 0x02);                                 // Zero        cpu->a = result & 0xFF;        cycles = 2;        break;    }    case 0xA9: // LDA Immediate    {        cpu->a = cpu->read_mem(cpu->context, cpu->pc++);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0x8D: // STA Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        cpu->write_mem(cpu->context, addr, cpu->a);        cycles = 4;        break;    }    case 0xAD: // LDA Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        cpu->a = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & ~0x82) | (cpu->a & 0x80) | (cpu->a == 0 ? 0x02 : 0);        cycles = 4;        break;    }    case 0x20: // JSR Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        cpu->write_mem(cpu->context, 0x0100 + cpu->s, (cpu->pc - 1) >> 8);        cpu->s = (cpu->s - 1) & 0xFF;        cpu->write_mem(cpu->context, 0x0100 + cpu->s, (cpu->pc - 1) & 0xFF);        cpu->s = (cpu->s - 1) & 0xFF;        cpu->pc = addr;        cycles = 6;        break;    }    case 0x60: // RTS    {        cpu->s = (cpu->s + 1) & 0xFF;        uint16_t addr = cpu->read_mem(cpu->context, 0x0100 + cpu->s);        cpu->s = (cpu->s + 1) & 0xFF;        addr |= cpu->read_mem(cpu->context, 0x0100 + cpu->s) << 8;        cpu->pc = addr + 1;        cycles = 6;        break;    }    case 0x85: // STA Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        cpu->write_mem(cpu->context, addr, cpu->a);        cycles = 3;        break;    }    case 0xA5: // LDA Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        cpu->a = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 3;        break;    }    case 0x00: // BRK    {        cpu->pc++;        cpu->write_mem(cpu->context, 0x0100 + cpu->s, (cpu->pc >> 8) & 0xFF);        cpu->s = (cpu->s - 1) & 0xFF;        cpu->write_mem(cpu->context, 0x0100 + cpu->s, cpu->pc & 0xFF);        cpu->s = (cpu->s - 1) & 0xFF;        cpu->write_mem(cpu->context, 0x0100 + cpu->s, cpu->p | 0x10);        cpu->s = (cpu->s - 1) & 0xFF;        cpu->p |= 0x04; // Set interrupt disable flag        cpu->pc = (cpu->read_mem(cpu->context, 0xFFFF) << 8) | cpu->read_mem(cpu->context, 0xFFFE);        cycles = 7;        break;    }    case 0x95: // STA Zero Page,X    {        uint8_t addr = (cpu->read_mem(cpu->context, cpu->pc++) + cpu->x) & 0xFF;        cpu->write_mem(cpu->context, addr, cpu->a);        cycles = 4;        break;    }    case 0xB5: // LDA Zero Page,X    {        uint8_t addr = (cpu->read_mem(cpu->context, cpu->pc++) + cpu->x) & 0xFF;        cpu->a = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 4;        break;    }    case 0xA2: // LDX Immediate    {        cpu->x = cpu->read_mem(cpu->context, cpu->pc++);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->x & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->x ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0xA6: // LDX Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        cpu->x = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->x & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->x ? 0x00 : 0x02);           // Zero        cycles = 3;        break;    }    case 0xA0: // LDY Immediate    {        cpu->y = cpu->read_mem(cpu->context, cpu->pc++);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->y & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->y ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0xA4: // LDY Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        cpu->y = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->y & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->y ? 0x00 : 0x02);           // Zero        cycles = 3;        break;    }    case 0xC5: // CMP Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t value = cpu->read_mem(cpu->context, addr);        uint16_t result = cpu->a - value;        cpu->p = (cpu->p & 0x7C) |                 // Mantém flags não afetadas                 ((result & 0x80) ? 0x80 : 0x00) | // Negative                 ((result & 0xFF) ? 0x00 : 0x02) | // Zero                 (cpu->a >= value ? 0x01 : 0x00);  // Carry        cycles = 3;        break;    }    case 0xC9: // CMP Immediate    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        uint16_t result = cpu->a - value;        cpu->p = (cpu->p & 0x7C) |                 // Mantém flags não afetadas                 ((result & 0x80) ? 0x80 : 0x00) | // Negative                 ((result & 0xFF) ? 0x00 : 0x02) | // Zero                 (cpu->a >= value ? 0x01 : 0x00);  // Carry        cycles = 2;        break;    }    case 0xBD: // LDA Absolute,X    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        addr += cpu->x;        cpu->a = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 4;        break;    }    case 0x9D: // STA Absolute,X    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        addr += cpu->x;        cpu->write_mem(cpu->context, addr, cpu->a);        cycles = 5;        break;    }    case 0x30: // BMI    {        int8_t offset = cpu->read_mem(cpu->context, cpu->pc++);        if (cpu->p & 0x80)        {            uint16_t old_pc = cpu->pc;            cpu->pc += offset;            cycles = 3 + ((old_pc & 0xFF00) != (cpu->pc & 0xFF00) ? 1 : 0);        }        else        {            cycles = 2;        }        break;    }    case 0x10: // BPL    {        int8_t offset = cpu->read_mem(cpu->context, cpu->pc++);        if (!(cpu->p & 0x80))        {            uint16_t old_pc = cpu->pc;            cpu->pc += offset;            cycles = 3 + ((old_pc & 0xFF00) != (cpu->pc & 0xFF00) ? 1 : 0);        }        else        {            cycles = 2;        }        break;    }    case 0x90: // BCC - Branch if Carry Clear    {        int8_t offset = cpu->read_mem(cpu->context, cpu->pc++);        if (!(cpu->p & 0x01)) // Carry flag clear        {            uint16_t old_pc = cpu->pc;            cpu->pc += offset;            cycles = 3 + ((old_pc & 0xFF00) != (cpu->pc & 0xFF00) ? 1 : 0); // +1 se cruzar página        }        else        {            cycles = 2;        }        break;    }    case 0xF0: // BEQ - Branch if Equal (Zero Set)    {        int8_t offset = cpu->read_mem(cpu->context, cpu->pc++);        if (cpu->p & 0x02) // Zero flag set        {            uint16_t old_pc = cpu->pc;            cpu->pc += offset;            cycles = 3 + ((old_pc & 0xFF00) != (cpu->pc & 0xFF00) ? 1 : 0); // +1 se cruzar página        }        else        {            cycles = 2;        }        break;    }    case 0x09: // ORA Immediate    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        cpu->a |= value;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0x68: // PLA - Pull Accumulator    {        cpu->s = (cpu->s + 1) & 0xFF;        cpu->a = cpu->read_mem(cpu->context, 0x0100 + cpu->s);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 4;        break;    }    case 0x48: // PHA - Push Accumulator    {        cpu->write_mem(cpu->context, 0x0100 + cpu->s, cpu->a);        cpu->s = (cpu->s - 1) & 0xFF;        cycles = 3;        break;    }    case 0x4C: // JMP Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        cpu->pc = addr;        cycles = 3;        break;    }    case 0x6C: // JMP Indirect    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        // Bug na CPU 6502: se o endereço estiver no fim da página, não incrementa corretamente        uint16_t low = cpu->read_mem(cpu->context, addr);        uint16_t high = cpu->read_mem(cpu->context, (addr & 0xFF00) | ((addr + 1) & 0xFF));        cpu->pc = low | (high << 8);        cycles = 5;        break;    }    case 0x29: // AND Immediate    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        cpu->a &= value;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0x25: // AND Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t value = cpu->read_mem(cpu->context, addr);        cpu->a &= value;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 3;        break;    }    case 0x49: // EOR Immediate    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        cpu->a ^= value;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0xB8: // CLV - Clear Overflow Flag    {        cpu->p &= ~0x40; // Clear overflow flag        cycles = 2;        break;    }    case 0xE5: // SBC Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t value = cpu->read_mem(cpu->context, addr);        uint16_t result = cpu->a - value - (1 - (cpu->p & 0x01));        // Atualiza flags        cpu->p = (cpu->p & 0x3C) |                                                // Mantém flags não afetadas                 ((result > 0xFF) ? 0x00 : 0x01) |                                // Carry (invertido em SBC)                 ((~(cpu->a ^ value) & (cpu->a ^ result) & 0x80) ? 0x40 : 0x00) | // Overflow                 ((result & 0x80) ? 0x80 : 0x00) |                                // Negative                 ((result & 0xFF) ? 0x00 : 0x02);                                 // Zero        cpu->a = result & 0xFF;        cycles = 3;        break;    }    case 0xE9: // SBC Immediate    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        uint16_t result = cpu->a - value - (1 - (cpu->p & 0x01));        // Atualiza flags        cpu->p = (cpu->p & 0x3C) |                                                // Mantém flags não afetadas                 ((result > 0xFF) ? 0x00 : 0x01) |                                // Carry (invertido em SBC)                 ((~(cpu->a ^ value) & (cpu->a ^ result) & 0x80) ? 0x40 : 0x00) | // Overflow                 ((result & 0x80) ? 0x80 : 0x00) |                                // Negative                 ((result & 0xFF) ? 0x00 : 0x02);                                 // Zero        cpu->a = result & 0xFF;        cycles = 2;        break;    }    case 0x84: // STY Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        cpu->write_mem(cpu->context, addr, cpu->y);        cycles = 3;        break;    }    case 0x8C: // STY Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        cpu->write_mem(cpu->context, addr, cpu->y);        cycles = 4;        break;    }    case 0xA8: // TAY - Transfer Accumulator to Y    {        cpu->y = cpu->a;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->y & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->y ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0xAA: // TAX - Transfer Accumulator to X    {        cpu->x = cpu->a;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->x & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->x ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0x8A: // TXA - Transfer X to Accumulator    {        cpu->a = cpu->x;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0x98: // TYA - Transfer Y to Accumulator    {        cpu->a = cpu->y;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0xC8: // INY - Increment Y    {        cpu->y = (cpu->y + 1) & 0xFF;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->y & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->y ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0xE8: // INX - Increment X    {        cpu->x = (cpu->x + 1) & 0xFF;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->x & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->x ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0xCA: // DEX - Decrement X    {        cpu->x = (cpu->x - 1) & 0xFF;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->x & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->x ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0x88: // DEY - Decrement Y    {        cpu->y = (cpu->y - 1) & 0xFF;        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->y & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->y ? 0x00 : 0x02);           // Zero        cycles = 2;        break;    }    case 0xEA: // NOP        break;    case 0xB0: // BCS - Branch if Carry Set    {        int8_t offset = cpu->read_mem(cpu->context, cpu->pc++);        if (cpu->p & 0x01) // Carry flag set        {            uint16_t old_pc = cpu->pc;            cpu->pc += offset;            cycles = 3 + ((old_pc & 0xFF00) != (cpu->pc & 0xFF00) ? 1 : 0); // +1 se cruzar página        }        else        {            cycles = 2;        }        break;    }    case 0xD0: // BNE - Branch if Not Equal (Zero Clear)    {        int8_t offset = cpu->read_mem(cpu->context, cpu->pc++);        if (!(cpu->p & 0x02)) // Zero flag clear        {            uint16_t old_pc = cpu->pc;            cpu->pc += offset;            cycles = 3 + ((old_pc & 0xFF00) != (cpu->pc & 0xFF00) ? 1 : 0); // +1 se cruzar página        }        else        {            cycles = 2;        }        break;    }    case 0xB4: // LDY Zero Page,X    {        uint8_t addr = (cpu->read_mem(cpu->context, cpu->pc++) + cpu->x) & 0xFF;        cpu->y = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->y & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->y ? 0x00 : 0x02);           // Zero        cycles = 4;        break;    }    case 0xB9: // LDA Absolute,Y    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint16_t effective_addr = addr + cpu->y;        // +1 ciclo se cruzar página        cycles = 4 + ((addr & 0xFF00) != (effective_addr & 0xFF00) ? 1 : 0);        cpu->a = cpu->read_mem(cpu->context, effective_addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        break;    }    case 0x24: // BIT Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t value = cpu->read_mem(cpu->context, addr);        // Bit 7 e 6 de value vão para as flags N e V        cpu->p = (cpu->p & 0x3D) |                 // Limpa N, V, Z                 (value & 0xC0) |                  // Bits 7 e 6 para N e V                 ((value & cpu->a) ? 0x00 : 0x02); // Zero se AND for zero        cycles = 3;        break;    }    case 0xE6: // INC Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t value = cpu->read_mem(cpu->context, addr);        value = (value + 1) & 0xFF;        cpu->write_mem(cpu->context, addr, value);        cpu->p = (cpu->p & 0x7D) |                // Mantém flags não afetadas                 ((value & 0x80) ? 0x80 : 0x00) | // Negative                 (value ? 0x00 : 0x02);           // Zero        cycles = 5;        break;    }    case 0x19: // ORA Absolute,Y    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint16_t effective_addr = addr + cpu->y;        // +1 ciclo se cruzar página        cycles = 4 + ((addr & 0xFF00) != (effective_addr & 0xFF00) ? 1 : 0);        uint8_t value = cpu->read_mem(cpu->context, effective_addr);        cpu->a |= value; // Operação OR        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        break;    }    case 0xFF: // Opcode ilegal/não oficial (tratado como NOP)    {        // Este opcode não é oficialmente documentado, mas aparece em alguns jogos        // Tratamos como NOP (sem operação) com 2 ciclos        CPU_LOG_WARN("Opcode ilegal 0xFF encontrado em PC=0x%04X - tratado como NOP", cpu->pc - 1);        cycles = 2;        break;    }    case 0x05: // ORA Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t value = cpu->read_mem(cpu->context, addr);        cpu->a |= value; // Operação OR        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 3;        break;    }    case 0x99: // STA Absolute,Y    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint16_t effective_addr = addr + cpu->y;        // Não existe +1 ciclo para cruzamento de página em operações de escrita        cpu->write_mem(cpu->context, effective_addr, cpu->a);        cycles = 5; // STA Absolute,Y sempre consome 5 ciclos        break;    }    // Implementações básicas para opcodes ilegais mais comuns    case 0x1A: // NOP (Ilegal)    case 0x1C: // NOP (Ilegal)    case 0x1D: // ORA Absolute,X (Duplicado, mas tratamos como legítimo)    case 0x1E: // ASL Absolute,X (Duplicado, mas tratamos como legítimo)    case 0x80: // NOP (Ilegal) com byte imediato    case 0x82: // NOP (Ilegal) com byte imediato    {        // Tratamos a maioria dos opcodes ilegais como NOP        // Alguns deles consomem um byte extra, então avançamos o PC        if (opcode == 0x80 || opcode == 0x82)        {            cpu->pc++; // Esses NOP ilegais consomem um byte adicional            cycles = 2;        }        else if (opcode == 0x1D || opcode == 0x1E)        {            // Para opcodes duplicados, implementamos como o oficial            uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++);            addr |= cpu->read_mem(cpu->context, cpu->pc++) << 8;            uint16_t effective_addr = addr + cpu->x;            cycles = 4 + ((addr & 0xFF00) != (effective_addr & 0xFF00) ? 1 : 0);            // ORA Absolute,X            if (opcode == 0x1D)            {                uint8_t value = cpu->read_mem(cpu->context, effective_addr);                cpu->a |= value;                cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                         ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                         (cpu->a ? 0x00 : 0x02);           // Zero            }            // ASL Absolute,X            else if (opcode == 0x1E)            {                uint8_t value = cpu->read_mem(cpu->context, effective_addr);                cpu->p = (cpu->p & 0x7C) |               // Mantém flags não afetadas, exceto C                         ((value & 0x80) ? 0x01 : 0x00); // Carry recebe o bit 7                value <<= 1; // Shift left                cpu->p |= ((value & 0x80) ? 0x80 : 0x00) | // Negative                          (value ? 0x00 : 0x02);           // Zero                cpu->write_mem(cpu->context, effective_addr, value);                cycles = 7; // ASL Absolute,X sempre consome 7 ciclos            }        }        else        {            // Opcodes NOP simples            cycles = 2;        }        CPU_LOG_WARN("Opcode não oficial/ilegal 0x%02X tratado em PC=0x%04X", opcode, cpu->pc - 1);        break;    }    case 0xAC: // LDY Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        cpu->y = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->y & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->y ? 0x00 : 0x02);           // Zero        cycles = 4;        break;    }    case 0xB1: // LDA Indirect,Y    {        uint8_t zp_addr = cpu->read_mem(cpu->context, cpu->pc++);        // Lê o endereço de 16 bits armazenado em zero page        uint16_t addr = cpu->read_mem(cpu->context, zp_addr);        addr |= cpu->read_mem(cpu->context, (zp_addr + 1) & 0xFF) << 8;        uint16_t effective_addr = addr + cpu->y;        // +1 ciclo se cruzar página        cycles = 5 + ((addr & 0xFF00) != (effective_addr & 0xFF00) ? 1 : 0);        cpu->a = cpu->read_mem(cpu->context, effective_addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        break;    }    case 0xC0: // CPY Immediate    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t result = cpu->y - value;        cpu->p = (cpu->p & 0x7C) |                   // Mantém flags não afetadas, exceto C                 ((cpu->y >= value) ? 0x01 : 0x00) | // Carry set se Y >= value                 ((result & 0x80) ? 0x80 : 0x00) |   // Negative                 (result ? 0x00 : 0x02);             // Zero        cycles = 2;        break;    }    case 0x06: // ASL Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t value = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7C) |               // Mantém flags não afetadas, exceto C                 ((value & 0x80) ? 0x01 : 0x00); // Carry recebe o bit 7        value <<= 1; // Shift left        cpu->p |= ((value & 0x80) ? 0x80 : 0x00) | // Negative                  (value ? 0x00 : 0x02);           // Zero        cpu->write_mem(cpu->context, addr, value);        cycles = 5;        break;    }    case 0x0D: // ORA Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint8_t value = cpu->read_mem(cpu->context, addr);        cpu->a |= value; // Operação OR        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 4;        break;    }    case 0x2D: // AND Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint8_t value = cpu->read_mem(cpu->context, addr);        cpu->a &= value; // Operação AND        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->a & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->a ? 0x00 : 0x02);           // Zero        cycles = 4;        break;    }    case 0xE0: // CPX Immediate    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t result = cpu->x - value;        cpu->p = (cpu->p & 0x7C) |                   // Mantém flags não afetadas, exceto C                 ((cpu->x >= value) ? 0x01 : 0x00) | // Carry set se X >= value                 ((result & 0x80) ? 0x80 : 0x00) |   // Negative                 (result ? 0x00 : 0x02);             // Zero        cycles = 2;        break;    }    case 0xAE: // LDX Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        cpu->x = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->x & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->x ? 0x00 : 0x02);           // Zero        cycles = 4;        break;    }    case 0xBC: // LDY Absolute,X    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint16_t effective_addr = addr + cpu->x;        // +1 ciclo se cruzar página        cycles = 4 + ((addr & 0xFF00) != (effective_addr & 0xFF00) ? 1 : 0);        cpu->y = cpu->read_mem(cpu->context, effective_addr);        cpu->p = (cpu->p & 0x7D) |                 // Mantém flags não afetadas                 ((cpu->y & 0x80) ? 0x80 : 0x00) | // Negative                 (cpu->y ? 0x00 : 0x02);           // Zero        break;    }    case 0x86: // STX Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        cpu->write_mem(cpu->context, addr, cpu->x);        cycles = 3;        break;    }    case 0x2C: // BIT Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint8_t value = cpu->read_mem(cpu->context, addr);        // Bit 7 e 6 de value vão para as flags N e V        cpu->p = (cpu->p & 0x3D) |                 // Limpa N, V, Z                 (value & 0xC0) |                  // Bits 7 e 6 para N e V                 ((value & cpu->a) ? 0x00 : 0x02); // Zero se AND for zero        cycles = 4;        break;    }    case 0xEE: // INC Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint8_t value = cpu->read_mem(cpu->context, addr);        value = (value + 1) & 0xFF;        cpu->write_mem(cpu->context, addr, value);        cpu->p = (cpu->p & 0x7D) |                // Mantém flags não afetadas                 ((value & 0x80) ? 0x80 : 0x00) | // Negative                 (value ? 0x00 : 0x02);           // Zero        cycles = 6;        break;    }    case 0xD9: // CMP Absolute,Y    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint16_t effective_addr = addr + cpu->y;        // +1 ciclo se cruzar página        cycles = 4 + ((addr & 0xFF00) != (effective_addr & 0xFF00) ? 1 : 0);        uint8_t value = cpu->read_mem(cpu->context, effective_addr);        uint8_t result = cpu->a - value;        cpu->p = (cpu->p & 0x7C) |                   // Mantém flags não afetadas, exceto C                 ((cpu->a >= value) ? 0x01 : 0x00) | // Carry set se A >= value                 ((result & 0x80) ? 0x80 : 0x00) |   // Negative                 (result ? 0x00 : 0x02);             // Zero        break;    }    case 0x26: // ROL Zero Page    {        uint8_t addr = cpu->read_mem(cpu->context, cpu->pc++);        uint8_t value = cpu->read_mem(cpu->context, addr);        uint8_t old_carry = (cpu->p & 0x01) ? 1 : 0;        cpu->p = (cpu->p & 0x7C) |               // Mantém flags não afetadas, exceto C                 ((value & 0x80) ? 0x01 : 0x00); // Carry recebe o bit 7        value = ((value << 1) | old_carry) & 0xFF; // Rotate left, bit 0 recebe o carry antigo        cpu->p |= ((value & 0x80) ? 0x80 : 0x00) | // Negative                  (value ? 0x00 : 0x02);           // Zero        cpu->write_mem(cpu->context, addr, value);        cycles = 5;        break;    }    // Implementações para mais opcodes ilegais/não documentados    case 0x07: // SLO Zero Page (Ilegal)    case 0x17: // SLO Zero Page,X (Ilegal)    case 0x03: // SLO Indirect,X (Ilegal)    case 0x13: // SLO Indirect,Y (Ilegal)    case 0x0F: // SLO Absolute (Ilegal)    case 0x1B: // SLO Absolute,Y (Ilegal)    case 0xD7: // DCP Zero Page,X (Ilegal)    case 0xC7: // DCP Zero Page (Ilegal)    case 0xD3: // DCP Indirect,Y (Ilegal)    case 0xC3: // DCP Indirect,X (Ilegal)    case 0xCF: // DCP Absolute (Ilegal)    case 0xDF: // DCP Absolute,X (Ilegal)    case 0xDB: // DCP Absolute,Y (Ilegal)    case 0x33: // RLA Indirect,Y (Ilegal)    case 0x23: // RLA Indirect,X (Ilegal)    case 0x27: // RLA Zero Page (Ilegal)    case 0x37: // RLA Zero Page,X (Ilegal)    case 0x2F: // RLA Absolute (Ilegal)    case 0x3F: // RLA Absolute,X (Ilegal)    case 0x3B: // RLA Absolute,Y (Ilegal)    {        // Tratamos a maioria dos opcodes ilegais como NOP        // Alguns deles consomem bytes extras, então avançamos o PC        // Opcodes com endereçamento Absolute        if (opcode == 0x0F || opcode == 0x1B ||            opcode == 0xCF || opcode == 0xDF || opcode == 0xDB ||            opcode == 0x2F || opcode == 0x3F || opcode == 0x3B)        {            cpu->pc += 2; // Consomem 2 bytes adicionais            cycles = 4;        }        // Opcodes com endereçamento Zero Page        else if (opcode == 0x07 || opcode == 0x17 ||                 opcode == 0xC7 || opcode == 0xD7 ||                 opcode == 0x27 || opcode == 0x37)        {            cpu->pc += 1; // Consomem 1 byte adicional            cycles = 3;        }        // Opcodes com endereçamento Indirect        else if (opcode == 0x03 || opcode == 0x13 ||                 opcode == 0xC3 || opcode == 0xD3 ||                 opcode == 0x23 || opcode == 0x33)        {            cpu->pc += 1; // Consomem 1 byte adicional            cycles = 6;        }        else        {            // Outros opcodes ilegais            cycles = 2;        }        CPU_LOG_WARN("Opcode não oficial/ilegal 0x%02X tratado em PC=0x%04X", opcode, cpu->pc - 1);        break;    }    case 0x91: // STA Indirect,Y    {        uint8_t zp_addr = cpu->read_mem(cpu->context, cpu->pc++);        // Lê o endereço de 16 bits armazenado em zero page        uint16_t addr = cpu->read_mem(cpu->context, zp_addr);        addr |= cpu->read_mem(cpu->context, (zp_addr + 1) & 0xFF) << 8;        // Adiciona Y ao endereço        uint16_t effective_addr = addr + cpu->y;        // Escreve o valor do acumulador no endereço calculado        cpu->write_mem(cpu->context, effective_addr, cpu->a);        // STA sempre leva 6 ciclos no modo Indirect,Y        cycles = 6;        break;    }    case 0xBA: // TSX - Transfer Stack Pointer to X    {        // Transfere o valor do Stack Pointer para o registrador X        cpu->x = cpu->s;        // Atualiza as flags Zero e Negative        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->x == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->x & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        // TSX leva 2 ciclos        cycles = 2;        break;    }        // Implementação dos opcodes faltantes    case 0x6B: // ARR - Illegal opcode (AND + ROR)    {        uint8_t value = cpu->read_mem(cpu->context, cpu->pc++);        cpu->a &= value; // AND        uint8_t old_carry = (cpu->p & RP2A03_FLAG_CARRY);        // ROR        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_OVERFLOW | RP2A03_FLAG_NEGATIVE));        if (cpu->a & 0x01)            cpu->p |= RP2A03_FLAG_CARRY;        cpu->a = (cpu->a >> 1) | (old_carry ? 0x80 : 0);        // Flags especiais para ARR        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        if (((cpu->a >> 6) & 0x01) ^ ((cpu->a >> 5) & 0x01))            cpu->p |= RP2A03_FLAG_OVERFLOW;        cycles = 2;        break;    }    case 0x73: // RRA - Illegal opcode (ROR + ADC)    {        uint8_t zp_addr = cpu->read_mem(cpu->context, cpu->pc++);        uint16_t addr = cpu->read_mem(cpu->context, zp_addr) |                        (cpu->read_mem(cpu->context, (zp_addr + 1) & 0xFF) << 8);        uint16_t effective_addr = addr + cpu->y;        uint8_t value = cpu->read_mem(cpu->context, effective_addr);        // ROR        uint8_t old_carry = (cpu->p & RP2A03_FLAG_CARRY) ? 1 : 0;        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (value & 0x01)            cpu->p |= RP2A03_FLAG_CARRY;        value = (value >> 1) | (old_carry << 7);        cpu->write_mem(cpu->context, effective_addr, value);        // ADC        uint16_t sum = cpu->a + value + (cpu->p & RP2A03_FLAG_CARRY ? 1 : 0);        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_OVERFLOW | RP2A03_FLAG_NEGATIVE));        if (sum > 0xFF)            cpu->p |= RP2A03_FLAG_CARRY;        if ((sum & 0xFF) == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (~(cpu->a ^ value) & (cpu->a ^ sum) & 0x80)            cpu->p |= RP2A03_FLAG_OVERFLOW;        if (sum & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        cpu->a = sum & 0xFF;        cycles = 8;        break;    }    case 0x5F: // SRE - Illegal opcode (LSR + EOR)    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint16_t effective_addr = addr + cpu->x;        uint8_t value = cpu->read_mem(cpu->context, effective_addr);        // LSR        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (value & 0x01)            cpu->p |= RP2A03_FLAG_CARRY;        value >>= 1;        cpu->write_mem(cpu->context, effective_addr, value);        // EOR        cpu->a ^= value;        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        cycles = 7;        break;    }    case 0xEF: // ISC/ISB - Illegal opcode (INC + SBC)    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint8_t value = cpu->read_mem(cpu->context, addr);        // INC        value = (value + 1) & 0xFF;        cpu->write_mem(cpu->context, addr, value);        // SBC        uint16_t temp = cpu->a - value - (!(cpu->p & RP2A03_FLAG_CARRY) ? 1 : 0);        uint8_t result = temp & 0xFF;        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_OVERFLOW | RP2A03_FLAG_NEGATIVE));        if (temp <= 0xFF)            cpu->p |= RP2A03_FLAG_CARRY;        if (result == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if ((cpu->a ^ value) & (cpu->a ^ result) & 0x80)            cpu->p |= RP2A03_FLAG_OVERFLOW;        if (result & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        cpu->a = result;        cycles = 6;        break;    }    case 0x40: // RTI - Return from Interrupt    {        // Recupera o status da pilha        cpu->s = (cpu->s + 1) & 0xFF;        cpu->p = cpu->read_mem(cpu->context, 0x0100 + cpu->s) | 0x20;        cpu->p &= ~RP2A03_FLAG_BREAK;        // Recupera o PC da pilha        cpu->s = (cpu->s + 1) & 0xFF;        uint16_t pc_low = cpu->read_mem(cpu->context, 0x0100 + cpu->s);        cpu->s = (cpu->s + 1) & 0xFF;        uint16_t pc_high = cpu->read_mem(cpu->context, 0x0100 + cpu->s);        cpu->pc = (pc_high << 8) | pc_low;        cycles = 6;        break;    }    case 0x2A: // ROL A - Rotate Left Accumulator    {        uint8_t old_carry = (cpu->p & RP2A03_FLAG_CARRY) ? 1 : 0;        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_CARRY;        cpu->a = ((cpu->a << 1) | old_carry) & 0xFF;        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (cpu->a & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        cycles = 2;        break;    }    case 0x0E: // ASL Absolute    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint8_t value = cpu->read_mem(cpu->context, addr);        cpu->p = (cpu->p & ~RP2A03_FLAG_CARRY);        if (value & 0x80)            cpu->p |= RP2A03_FLAG_CARRY;        value <<= 1;        cpu->write_mem(cpu->context, addr, value);        cpu->p = (cpu->p & ~(RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (value == 0)            cpu->p |= RP2A03_FLAG_ZERO;        if (value & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        cycles = 6;        break;    }    case 0xDD: // CMP Absolute,X    {        uint16_t addr = cpu->read_mem(cpu->context, cpu->pc++) |                        (cpu->read_mem(cpu->context, cpu->pc++) << 8);        uint16_t effective_addr = addr + cpu->x;        cycles = 4 + ((addr & 0xFF00) != (effective_addr & 0xFF00) ? 1 : 0);        uint8_t value = cpu->read_mem(cpu->context, effective_addr);        uint8_t result = cpu->a - value;        cpu->p = (cpu->p & ~(RP2A03_FLAG_CARRY | RP2A03_FLAG_ZERO | RP2A03_FLAG_NEGATIVE));        if (cpu->a >= value)            cpu->p |= RP2A03_FLAG_CARRY;        if (cpu->a == value)            cpu->p |= RP2A03_FLAG_ZERO;        if (result & 0x80)            cpu->p |= RP2A03_FLAG_NEGATIVE;        break;    }    default:        // Verifica se é um opcode ilegal conhecido        const illegal_opcode_info_t *illegal_info = find_illegal_opcode(opcode);        if (illegal_info)        {            cycles = execute_illegal_opcode(cpu, illegal_info);            CPU_LOG_TRACE("Executado opcode ilegal 0x%02X (%s) em PC=0x%04X",                          opcode, illegal_info->name, cpu->pc - 1);            break;        }        // Determina o formato da instrução com base no opcode        if ((opcode & 0x0F) == 0x00 || (opcode & 0x0F) == 0x02 || (opcode & 0x0F) == 0x08 || (opcode & 0x0F) == 0x0A)        {            cycles = 2; // Formato 1 byte        }        else if ((opcode & 0x0F) == 0x01 || (opcode & 0x0F) == 0x03 || (opcode & 0x0F) == 0x05 || (opcode & 0x0F) == 0x07 ||                 (opcode & 0x0F) == 0x09 || (opcode & 0x0F) == 0x0B || (opcode & 0x0F) == 0x0D || (opcode & 0x0F) == 0x0F)        {            cpu->pc++; // Formato 2 bytes            cycles = 2;        }        else        {            cpu->pc += 2; // Formato 3 bytes            cycles = 4;        }        CPU_LOG_WARN("Opcode não implementado: 0x%02X em PC=0x%04X - tratado como NOP", opcode, cpu->pc - 1);        break;    }    cpu->cycles += cycles;    return cycles;}/** * @brief Executa um ciclo da CPU do NES * @param cpu Ponteiro para o CPU */void nes_cpu_cycle(nes_cpu_t *cpu){    if (!cpu)    {        CPU_LOG_ERROR("nes_cpu_cycle: CPU inválida");        return;    }    // Incrementa o contador de ciclos    cpu->cycles++;    // Executa um passo da CPU a cada X ciclos    // Aqui estamos simplificando, na implementação real seria mais complexo    if (cpu->cycles % 12 == 0)    {        nes_cpu_step(cpu);    }}
