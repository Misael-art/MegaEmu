/** * @file rp2a03.h * @brief Definições para a CPU RP2A03 (variante da CPU 6502) usada no NES */#ifndef RP2A03_H#define RP2A03_H#ifdef __cplusplusextern "C"{#endif#include <stdint.h>#include "utils/enhanced_log.h"/** * @brief Códigos de erro específicos para a CPU RP2A03 */#define RP2A03_ERROR_NONE 0              /**< Sem erro */#define RP2A03_ERROR_INVALID_OPCODE -10  /**< Opcode inválido */#define RP2A03_ERROR_INVALID_ADDRESS -11 /**< Endereço inválido */#define RP2A03_ERROR_STACK_OVERFLOW -12  /**< Estouro de pilha */#define RP2A03_ERROR_STACK_UNDERFLOW -13 /**< Subfluxo de pilha *//** * @brief Flags do registrador de status */#define RP2A03_FLAG_CARRY 0x01#define RP2A03_FLAG_ZERO 0x02#define RP2A03_FLAG_INTERRUPT 0x04#define RP2A03_FLAG_DECIMAL 0x08#define RP2A03_FLAG_BREAK 0x10#define RP2A03_FLAG_UNUSED 0x20#define RP2A03_FLAG_OVERFLOW 0x40#define RP2A03_FLAG_NEGATIVE 0x80    /**     * @brief Tipos de interrupção     */    typedef enum    {        RP2A03_INTERRUPT_NONE, /**< Sem interrupção */        RP2A03_INTERRUPT_NMI,  /**< Interrupção Não-Mascarável (NMI) */        RP2A03_INTERRUPT_IRQ,  /**< Interrupção normal (IRQ) */        RP2A03_INTERRUPT_RESET /**< Reset */    } rp2a03_interrupt_t;    /**     * @brief Funções de callback para acesso à memória     */    typedef uint8_t (*rp2a03_read_func_t)(void *context, uint16_t address);    typedef void (*rp2a03_write_func_t)(void *context, uint16_t address, uint8_t value);    /**     * @brief Configuração da CPU RP2A03     */    typedef struct    {        rp2a03_read_func_t read_mem;   /**< Função para leitura de memória */        rp2a03_write_func_t write_mem; /**< Função para escrita de memória */        void *context;                 /**< Contexto para callbacks de memória */        int32_t log_level;             /**< Nível de log para a CPU */    } rp2a03_config_t;    /**     * @brief Estrutura da CPU RP2A03     */    typedef struct    {        // Registradores        uint8_t a;      /**< Acumulador */        uint8_t x;      /**< Registrador de índice X */        uint8_t y;      /**< Registrador de índice Y */        uint8_t sp;     /**< Ponteiro de pilha */        uint8_t status; /**< Registrador de status (flags) */        uint16_t pc;    /**< Contador de programa */        // Estado da CPU        uint64_t cycles;                      /**< Contador de ciclos */        int32_t remaining_cycles;             /**< Ciclos restantes para a instrução atual */        int32_t stall_cycles;                 /**< Ciclos de stall (por DMA ou outros motivos) */        rp2a03_interrupt_t pending_interrupt; /**< Interrupção pendente */        // Funções de acesso à memória        rp2a03_read_func_t read_mem;   /**< Função para leitura de memória */        rp2a03_write_func_t write_mem; /**< Função para escrita de memória */        void *context;                 /**< Contexto para callbacks de memória */        // Estado do log        int32_t log_level; /**< Nível de log para a CPU */    } rp2a03_t;    /**     * @brief Inicializa a CPU RP2A03     *     * @param config Configuração da CPU     * @return rp2a03_t* Ponteiro para a CPU inicializada, ou NULL em caso de erro     */    rp2a03_t *rp2a03_init(const rp2a03_config_t *config);    /**     * @brief Finaliza a CPU RP2A03 e libera recursos     *     * @param cpu Ponteiro para a CPU     */    void rp2a03_shutdown(rp2a03_t *cpu);    /**     * @brief Reseta a CPU RP2A03     *     * @param cpu Ponteiro para a CPU     */    void rp2a03_reset(rp2a03_t *cpu);    /**     * @brief Executa a CPU por um número específico de ciclos     *     * @param cpu Ponteiro para a CPU     * @param cycles Número de ciclos a executar     * @return int32_t Número de ciclos realmente executados, ou código de erro negativo     */    int32_t rp2a03_execute(rp2a03_t *cpu, int32_t cycles);    /**     * @brief Aciona uma interrupção na CPU     *     * @param cpu Ponteiro para a CPU     * @param interrupt Tipo de interrupção     */    void rp2a03_trigger_interrupt(rp2a03_t *cpu, rp2a03_interrupt_t interrupt);    /**     * @brief Adiciona ciclos de stall à CPU (por DMA ou outros motivos)     *     * @param cpu Ponteiro para a CPU     * @param cycles Número de ciclos de stall a adicionar     */    void rp2a03_add_stall_cycles(rp2a03_t *cpu, int32_t cycles);    /**     * @brief Obtém o valor de um registrador da CPU     *     * @param cpu Ponteiro para a CPU     * @param reg Nome do registrador (a, x, y, sp, status, pc)     * @return uint16_t Valor do registrador (8 ou 16 bits dependendo do registrador)     */    uint16_t rp2a03_get_register(rp2a03_t *cpu, const char *reg);    /**     * @brief Define o valor de um registrador da CPU     *     * @param cpu Ponteiro para a CPU     * @param reg Nome do registrador (a, x, y, sp, status, pc)     * @param value Valor a definir     */    void rp2a03_set_register(rp2a03_t *cpu, const char *reg, uint16_t value);    /**     * @brief Verifica se uma flag do registrador de status está ativa     *     * @param cpu Ponteiro para a CPU     * @param flag Flag a verificar (usar constantes RP2A03_FLAG_*)     * @return int32_t 1 se a flag está ativa, 0 caso contrário     */    int32_t rp2a03_get_flag(rp2a03_t *cpu, uint8_t flag);    /**     * @brief Define ou limpa uma flag do registrador de status     *     * @param cpu Ponteiro para a CPU     * @param flag Flag a modificar (usar constantes RP2A03_FLAG_*)     * @param value 1 para definir a flag, 0 para limpá-la     */    void rp2a03_set_flag(rp2a03_t *cpu, uint8_t flag, int32_t value);    /**     * @brief Gera um dump do estado atual da CPU (para debug)     *     * @param cpu Ponteiro para a CPU     * @param buffer Buffer para receber o dump     * @param buffer_size Tamanho do buffer     * @return int32_t Número de bytes escritos no buffer     */    int32_t rp2a03_dump_state(rp2a03_t *cpu, char *buffer, int32_t buffer_size);#ifdef __cplusplus}#endif#endif /* RP2A03_H */