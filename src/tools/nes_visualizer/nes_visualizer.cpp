/** * @file nes_visualizer.cpp * @brief Implementação do visualizador para o emulador de NES usando SDL2 * @author Mega_Emu Team * @version 1.0.0 * @date 2024-03-13 */#include "nes_visualizer.hpp"#include <iostream>#include <chrono>#include <thread>#include <cstring>namespace MegaEmu{    namespace Tools    {        NESVisualizer::NESVisualizer()            : m_window(nullptr), m_renderer(nullptr), m_texture(nullptr), m_scale(3), m_screenWidth(256), m_screenHeight(240), m_isRunning(false)        {            // Inicializar o controlador com zeros            std::memset(&m_controllerState, 0, sizeof(Core::ControllerState));        }        NESVisualizer::~NESVisualizer()        {            shutdown();        }        bool NESVisualizer::initialize(const std::string &windowTitle, int scale)        {            // Salvar fator de escala            m_scale = scale;            // Inicializar SDL            if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0)            {                std::cerr << "Erro ao inicializar SDL: " << SDL_GetError() << std::endl;                return false;            }            // Criar janela            m_window = SDL_CreateWindow(                windowTitle.c_str(),                SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,                m_screenWidth * m_scale, m_screenHeight * m_scale,                SDL_WINDOW_SHOWN);            if (!m_window)            {                std::cerr << "Erro ao criar janela: " << SDL_GetError() << std::endl;                shutdown();                return false;            }            // Criar renderer            m_renderer = SDL_CreateRenderer(                m_window, -1,                SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);            if (!m_renderer)            {                std::cerr << "Erro ao criar renderer: " << SDL_GetError() << std::endl;                shutdown();                return false;            }            // Criar textura            m_texture = SDL_CreateTexture(                m_renderer,                SDL_PIXELFORMAT_ARGB8888,                SDL_TEXTUREACCESS_STREAMING,                m_screenWidth, m_screenHeight);            if (!m_texture)            {                std::cerr << "Erro ao criar textura: " << SDL_GetError() << std::endl;                shutdown();                return false;            }            // Configurar qualidade de escala            SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");            SDL_RenderSetLogicalSize(m_renderer, m_screenWidth, m_screenHeight);            // Criar instância NES            try            {                m_nes = std::make_unique<Platforms::NES>();                if (!m_nes->initialize())                {                    std::cerr << "Erro ao inicializar emulador NES" << std::endl;                    shutdown();                    return false;                }            }            catch (const std::exception &e)            {                std::cerr << "Exceção ao inicializar NES: " << e.what() << std::endl;                shutdown();                return false;            }            m_isRunning = true;            std::cout << "Visualizador NES inicializado com sucesso" << std::endl;            return true;        }        bool NESVisualizer::loadROM(const std::string &filename)        {            if (!m_nes)            {                std::cerr << "Emulador NES não inicializado" << std::endl;                return false;            }            try            {                if (!m_nes->loadROM(filename))                {                    std::cerr << "Erro ao carregar ROM: " << filename << std::endl;                    return false;                }                std::cout << "ROM carregada com sucesso: " << filename << std::endl;                return true;            }            catch (const std::exception &e)            {                std::cerr << "Exceção ao carregar ROM: " << e.what() << std::endl;                return false;            }        }        void NESVisualizer::run()        {            if (!m_isRunning || !m_nes)            {                std::cerr << "Visualizador não está inicializado corretamente" << std::endl;                return;            }            std::cout << "Iniciando loop principal do visualizador..." << std::endl;            // Configurar FPS target (aprox. 60fps)            const auto frameDuration = std::chrono::milliseconds(16);            // Loop principal            while (m_isRunning)            {                auto frameStart = std::chrono::high_resolution_clock::now();                // Processar eventos                m_isRunning = processEvents();                // Atualizar emulação                update();                // Renderizar                render();                // Controle de FPS                auto frameEnd = std::chrono::high_resolution_clock::now();                auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(frameEnd - frameStart);                if (elapsedTime < frameDuration)                {                    std::this_thread::sleep_for(frameDuration - elapsedTime);                }            }        }        bool NESVisualizer::processEvents()        {            SDL_Event event;            while (SDL_PollEvent(&event))            {                switch (event.type)                {                case SDL_QUIT:                    return false;                case SDL_KEYDOWN:                    if (event.key.keysym.sym == SDLK_ESCAPE)                    {                        return false;                    }                    else if (event.key.keysym.sym == SDLK_F12)                    {                        takeScreenshot("nes_screenshot");                    }                    break;                }            }            // Atualizar estado do controle com base nas teclas pressionadas            const uint8_t *keyStates = SDL_GetKeyboardState(NULL);            updateControllerState(keyStates);            return true;        }        void NESVisualizer::updateControllerState(const uint8_t *keyStates)        {            // Limpar estado anterior de "solto" para todos os botões            m_controllerState.up.released = false;            m_controllerState.down.released = false;            m_controllerState.left.released = false;            m_controllerState.right.released = false;            m_controllerState.a.released = false;            m_controllerState.b.released = false;            m_controllerState.start.released = false;            m_controllerState.select.released = false;            // Setas direcionais            bool upPressed = keyStates[SDL_SCANCODE_UP] || keyStates[SDL_SCANCODE_W];            bool downPressed = keyStates[SDL_SCANCODE_DOWN] || keyStates[SDL_SCANCODE_S];            bool leftPressed = keyStates[SDL_SCANCODE_LEFT] || keyStates[SDL_SCANCODE_A];            bool rightPressed = keyStates[SDL_SCANCODE_RIGHT] || keyStates[SDL_SCANCODE_D];            // Botões            bool aPressed = keyStates[SDL_SCANCODE_X] || keyStates[SDL_SCANCODE_J];            bool bPressed = keyStates[SDL_SCANCODE_Z] || keyStates[SDL_SCANCODE_K];            bool startPressed = keyStates[SDL_SCANCODE_RETURN];            bool selectPressed = keyStates[SDL_SCANCODE_RSHIFT];            // Atualizar estado de botões - Up            if (upPressed && !m_controllerState.up.held)            {                m_controllerState.up.pressed = true;                m_controllerState.up.held = true;            }            else if (!upPressed && m_controllerState.up.held)            {                m_controllerState.up.pressed = false;                m_controllerState.up.held = false;                m_controllerState.up.released = true;            }            else            {                m_controllerState.up.pressed = false;            }            // Down            if (downPressed && !m_controllerState.down.held)            {                m_controllerState.down.pressed = true;                m_controllerState.down.held = true;            }            else if (!downPressed && m_controllerState.down.held)            {                m_controllerState.down.pressed = false;                m_controllerState.down.held = false;                m_controllerState.down.released = true;            }            else            {                m_controllerState.down.pressed = false;            }            // Left            if (leftPressed && !m_controllerState.left.held)            {                m_controllerState.left.pressed = true;                m_controllerState.left.held = true;            }            else if (!leftPressed && m_controllerState.left.held)            {                m_controllerState.left.pressed = false;                m_controllerState.left.held = false;                m_controllerState.left.released = true;            }            else            {                m_controllerState.left.pressed = false;            }            // Right            if (rightPressed && !m_controllerState.right.held)            {                m_controllerState.right.pressed = true;                m_controllerState.right.held = true;            }            else if (!rightPressed && m_controllerState.right.held)            {                m_controllerState.right.pressed = false;                m_controllerState.right.held = false;                m_controllerState.right.released = true;            }            else            {                m_controllerState.right.pressed = false;            }            // A            if (aPressed && !m_controllerState.a.held)            {                m_controllerState.a.pressed = true;                m_controllerState.a.held = true;            }            else if (!aPressed && m_controllerState.a.held)            {                m_controllerState.a.pressed = false;                m_controllerState.a.held = false;                m_controllerState.a.released = true;            }            else            {                m_controllerState.a.pressed = false;            }            // B            if (bPressed && !m_controllerState.b.held)            {                m_controllerState.b.pressed = true;                m_controllerState.b.held = true;            }            else if (!bPressed && m_controllerState.b.held)            {                m_controllerState.b.pressed = false;                m_controllerState.b.held = false;                m_controllerState.b.released = true;            }            else            {                m_controllerState.b.pressed = false;            }            // Start            if (startPressed && !m_controllerState.start.held)            {                m_controllerState.start.pressed = true;                m_controllerState.start.held = true;            }            else if (!startPressed && m_controllerState.start.held)            {                m_controllerState.start.pressed = false;                m_controllerState.start.held = false;                m_controllerState.start.released = true;            }            else            {                m_controllerState.start.pressed = false;            }            // Select            if (selectPressed && !m_controllerState.select.held)            {                m_controllerState.select.pressed = true;                m_controllerState.select.held = true;            }            else if (!selectPressed && m_controllerState.select.held)            {                m_controllerState.select.pressed = false;                m_controllerState.select.held = false;                m_controllerState.select.released = true;            }            else            {                m_controllerState.select.pressed = false;            }            // Atualizar estado do controle no emulador            m_nes->updateControllerState(0, m_controllerState);        }        void NESVisualizer::update()        {            if (m_nes)            {                m_nes->runFrame();            }        }        void NESVisualizer::render()        {            if (!m_renderer || !m_texture || !m_nes)            {                return;            }            // Obter buffer de vídeo do NES            const uint32_t *frameBuffer = m_nes->getVideoBuffer();            if (!frameBuffer)            {                std::cerr << "Buffer de vídeo nulo obtido do emulador" << std::endl;                return;            }            // Atualizar textura com o buffer de vídeo            SDL_UpdateTexture(m_texture, NULL, frameBuffer, m_screenWidth * sizeof(uint32_t));            // Limpar tela            SDL_SetRenderDrawColor(m_renderer, 0, 0, 0, 255);            SDL_RenderClear(m_renderer);            // Renderizar textura            SDL_RenderCopy(m_renderer, m_texture, NULL, NULL);            // Apresentar            SDL_RenderPresent(m_renderer);        }        bool NESVisualizer::takeScreenshot(const std::string &filename)        {            if (!m_renderer || !m_nes)            {                std::cerr << "Não é possível tirar screenshot - renderer ou emulador não inicializado" << std::endl;                return false;            }            // Criar textura de superfície para capturar screenshot            SDL_Surface *screenshotSurface = SDL_CreateRGBSurface(                0, m_screenWidth, m_screenHeight, 32,                0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);            if (!screenshotSurface)            {                std::cerr << "Erro ao criar superfície para screenshot: " << SDL_GetError() << std::endl;                return false;            }            // Copiar dados do renderer para a superfície            SDL_RenderReadPixels(                m_renderer, NULL,                SDL_PIXELFORMAT_ARGB8888,                screenshotSurface->pixels,                screenshotSurface->pitch);            // Gerar nome de arquivo com timestamp            auto now = std::chrono::system_clock::now();            auto time = std::chrono::system_clock::to_time_t(now);            struct tm timeInfo;#ifdef _WIN32            localtime_s(&timeInfo, &time);#else            localtime_r(&time, &timeInfo);#endif            char buffer[100];            std::strftime(buffer, sizeof(buffer), "%Y%m%d_%H%M%S", &timeInfo);            std::string fullFilename = filename + "_" + buffer + ".bmp";            // Salvar como BMP            if (SDL_SaveBMP(screenshotSurface, fullFilename.c_str()) != 0)            {                std::cerr << "Erro ao salvar screenshot: " << SDL_GetError() << std::endl;                SDL_FreeSurface(screenshotSurface);                return false;            }            std::cout << "Screenshot salvo como " << fullFilename << std::endl;            SDL_FreeSurface(screenshotSurface);            return true;        }        void NESVisualizer::shutdown()        {            // Liberar recursos SDL            if (m_texture)            {                SDL_DestroyTexture(m_texture);                m_texture = nullptr;            }            if (m_renderer)            {                SDL_DestroyRenderer(m_renderer);                m_renderer = nullptr;            }            if (m_window)            {                SDL_DestroyWindow(m_window);                m_window = nullptr;            }            // Encerrar SDL            SDL_Quit();            // Liberar instância NES            m_nes.reset();            m_isRunning = false;            std::cout << "Visualizador NES encerrado" << std::endl;        }    } // namespace Tools} // namespace MegaEmu