from PIL import Imageimport numpy as npimport loggingclass NESParser:    def __init__(self):        self.chr_rom = None        self.palette = [(0,0,0), (85,85,85), (170,170,170), (255,255,255)]  # Paleta padrão em escala de cinza    def load_rom(self, rom_path):        """Carrega os dados CHR ROM de um arquivo NES"""        try:            with open(rom_path, 'rb') as f:                # Pula o cabeçalho iNES (16 bytes)                f.seek(16)                                # Lê os dados do CHR ROM                self.chr_rom = f.read()                return True        except Exception as e:            logging.error(f"Erro ao carregar ROM: {e}")            return False    def get_sprite(self, tile_index):        """Extrai um sprite 8x8 do CHR ROM"""        if not self.chr_rom or tile_index * 16 >= len(self.chr_rom):            return None        # Cada tile ocupa 16 bytes (8x8 pixels com 2 bits por pixel)        offset = tile_index * 16        tile_data = self.chr_rom[offset:offset + 16]        # Cria uma matriz 8x8 para o tile        tile = np.zeros((8, 8), dtype=np.uint8)        # Processa os planos de bits        for y in range(8):            byte1 = tile_data[y]            byte2 = tile_data[y + 8]                        for x in range(8):                # Combina os bits dos dois planos                pixel = ((byte1 >> (7 - x)) & 1) | (((byte2 >> (7 - x)) & 1) << 1)                tile[y][x] = pixel        return tile    def create_sprite_image(self, tile_index, scale=3):        """Cria uma imagem PIL do sprite com a escala especificada"""        tile = self.get_sprite(tile_index)        if tile is None:            return None        # Cria uma imagem PIL        img = Image.fromarray(tile * 85, mode='L')  # Multiplica por 85 para ter valores 0, 85, 170, 255        if scale > 1:            img = img.resize((8 * scale, 8 * scale), Image.NEAREST)                return img