import loggingimport numpy as npfrom ..core.parser_base import SpriteParserBaseclass SNESParser(SpriteParserBase):    def __init__(self):        super().__init__()        self.vram_data = None        self.cgram_data = None        self.bpp_mode = 4  # 4 ou 8 bpp            def decode_color(self, color_value):        """Decodifica cor do formato SNES (0BBB BBGG GGGR RRRR) para RGB"""        r = (color_value & 0x1F) * 8        g = ((color_value >> 5) & 0x1F) * 8        b = ((color_value >> 10) & 0x1F) * 8        return (r, g, b)    def load_sprite_data(self, vram_path, cgram_path=None):        """Carrega dados de sprite e paleta"""        try:            with open(vram_path, 'rb') as f:                self.vram_data = f.read()                        if cgram_path:                with open(cgram_path, 'rb') as f:                    self.cgram_data = f.read()                        logging.info(f"SNES data loaded: VRAM size={len(self.vram_data)}")            return True        except Exception as e:            logging.error(f"Error loading SNES data: {e}")            return False    def get_sprite(self, pattern_index, palette_index=0):        """Extrai sprite 8x8 ou 16x16 com informaÃ§Ãµes de cor"""        if not self.vram_data:            logging.error("No VRAM data loaded")            return None        bytes_per_tile = 32 if self.bpp_mode == 4 else 64        offset = pattern_index * bytes_per_tile                if offset + bytes_per_tile > len(self.vram_data):            logging.error(f"Pattern index {pattern_index} out of range")            return None        sprite_data = np.zeros((8, 8), dtype=np.uint8)                # Processa bits por plano        for y in range(8):            for plane in range(self.bpp_mode):                plane_data = self.vram_data[offset + y * 2 + plane * 16]                for x in range(8):                    bit = (plane_data >> (7 - x)) & 1                    sprite_data[y][x] |= (bit << plane)        return sprite_data + (palette_index * 16)