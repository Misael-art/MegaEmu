/** * @file test_megadrive_memory.c * @brief Testes para o sistema de memória do Mega Drive * * Implementa testes unitários para verificar o funcionamento * correto do sistema de memória do Mega Drive, incluindo * mapeamento de endereços, leitura/escrita e mirroring. */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <assert.h>#include "../platforms/megadrive/megadrive.h"#include "platforms/megadrive/memory/memory.h"#include "../core/core.h"#include "../core/interfaces/memory_interface.h"// Estrutura de teste para o Mega Drivetypedef struct{    md_platform_data_t platform_data;    uint8_t ram[64 * 1024];  // 64KB de RAM principal    uint8_t vram[64 * 1024]; // 64KB de VRAM    uint8_t rom[512 * 1024]; // 512KB de ROM para testes} test_md_memory_context_t;/** * @brief Configura o ambiente de teste */static test_md_memory_context_t *setup_test(){    test_md_memory_context_t *ctx = (test_md_memory_context_t *)malloc(sizeof(test_md_memory_context_t));    memset(ctx, 0, sizeof(test_md_memory_context_t));    // Inicializar com valores de teste    ctx->platform_data.ram = ctx->ram;    ctx->platform_data.ram_size = sizeof(ctx->ram);    // Preencher ROM com padrão de teste    for (int i = 0; i < sizeof(ctx->rom); i++)    {        ctx->rom[i] = (i & 0xFF);    }    ctx->platform_data.rom = ctx->rom;    ctx->platform_data.rom_size = sizeof(ctx->rom);    // Defina g_md_data global para o contexto de teste    extern md_platform_data_t *g_md_data;    g_md_data = &ctx->platform_data;    return ctx;}/** * @brief Limpa o ambiente de teste */static void teardown_test(test_md_memory_context_t *ctx){    if (ctx)    {        free(ctx);    }}/** * @brief Testa a leitura e escrita de 8 bits na RAM */static void test_ram_read_write_8(){    printf("Teste: Leitura/Escrita de 8 bits na RAM\n");    test_md_memory_context_t *ctx = setup_test();    // Testar escrita na RAM (endereços 0xE00000-0xFFFFFF)    uint32_t ram_address = 0xE00000;    uint8_t test_value = 0x42;    // Executar a função sob teste    extern void md_m68k_write_8(uint32_t address, uint8_t value);    md_m68k_write_8(ram_address, test_value);    // Verificar se o valor foi escrito corretamente na RAM    assert(ctx->ram[ram_address & 0xFFFF] == test_value);    // Testar leitura da RAM    extern uint8_t md_m68k_read_8(uint32_t address);    uint8_t read_value = md_m68k_read_8(ram_address);    // Verificar se o valor lido corresponde ao valor escrito    assert(read_value == test_value);    // Testar escrita/leitura em outro endereço    ram_address = 0xE00100;    test_value = 0x84;    md_m68k_write_8(ram_address, test_value);    read_value = md_m68k_read_8(ram_address);    assert(read_value == test_value);    teardown_test(ctx);    printf("OK\n");}/** * @brief Testa a leitura e escrita de 16 bits na RAM */static void test_ram_read_write_16(){    printf("Teste: Leitura/Escrita de 16 bits na RAM\n");    test_md_memory_context_t *ctx = setup_test();    // Testar escrita na RAM    uint32_t ram_address = 0xE00200;    uint16_t test_value = 0xABCD;    // Executar a função sob teste    extern void md_m68k_write_16(uint32_t address, uint16_t value);    md_m68k_write_16(ram_address, test_value);    // Verificar se o valor foi escrito corretamente na RAM (big endian)    assert(ctx->ram[(ram_address & 0xFFFF)] == ((test_value >> 8) & 0xFF));    assert(ctx->ram[(ram_address & 0xFFFF) + 1] == (test_value & 0xFF));    // Testar leitura da RAM    extern uint16_t md_m68k_read_16(uint32_t address);    uint16_t read_value = md_m68k_read_16(ram_address);    // Verificar se o valor lido corresponde ao valor escrito    assert(read_value == test_value);    teardown_test(ctx);    printf("OK\n");}/** * @brief Testa leitura da ROM */static void test_rom_read(){    printf("Teste: Leitura da ROM\n");    test_md_memory_context_t *ctx = setup_test();    // Testar leitura da ROM (endereços 0x000000-0x3FFFFF)    uint32_t rom_address = 0x000100;    // O valor esperado é baseado no padrão que preenchemos na ROM durante o setup    uint8_t expected_value = (rom_address & 0xFF);    // Executar a função sob teste    extern uint8_t md_m68k_read_8(uint32_t address);    uint8_t read_value = md_m68k_read_8(rom_address);    // Verificar se o valor lido corresponde ao esperado    assert(read_value == expected_value);    // Testar leitura de 16 bits    rom_address = 0x000200;    uint16_t expected_value_16 = ((rom_address & 0xFF) << 8) | ((rom_address + 1) & 0xFF);    extern uint16_t md_m68k_read_16(uint32_t address);    uint16_t read_value_16 = md_m68k_read_16(rom_address);    // Verificar leitura de 16 bits    assert(read_value_16 == expected_value_16);    teardown_test(ctx);    printf("OK\n");}/** * @brief Testa mirroring de memória RAM */static void test_ram_mirroring(){    printf("Teste: Mirroring de memória RAM\n");    test_md_memory_context_t *ctx = setup_test();    // Escrever na RAM no endereço 0xE00000    uint32_t ram_address = 0xE00000;    uint8_t test_value = 0x42;    extern void md_m68k_write_8(uint32_t address, uint8_t value);    md_m68k_write_8(ram_address, test_value);    // Testar mirroring - ler de endereço espelhado    uint32_t mirrored_address = 0xE10000; // Espelho dentro da RAM    extern uint8_t md_m68k_read_8(uint32_t address);    uint8_t read_value = md_m68k_read_8(mirrored_address);    // Deve obter o mesmo valor devido ao mirroring de endereços    assert(read_value == test_value);    // Escrever em outro endereço espelhado    mirrored_address = 0xF00000;    test_value = 0x84;    md_m68k_write_8(mirrored_address, test_value);    read_value = md_m68k_read_8(ram_address); // Ler do endereço original    // Verificar se o valor foi espelhado corretamente    assert(read_value == test_value);    teardown_test(ctx);    printf("OK\n");}/** * @brief Função principal que executa todos os testes */int main(int argc, char **argv){    printf("Iniciando testes do sistema de memória do Mega Drive...\n");    // Executar todos os testes    test_ram_read_write_8();    test_ram_read_write_16();    test_rom_read();    test_ram_mirroring();    printf("Todos os testes foram executados com sucesso!\n");    return 0;}