/** * @file test_framebuffer.c * @brief Testes unitários para as funções de manipulação de framebuffer *  * Este arquivo contém testes para as funções críticas relacionadas à * manipulação de framebuffer, verificando operações seguras de memória. */#include <stdio.h>#include <stdlib.h>#include <string.h>#include "../frontend/common/frontend.h"#include "../core/core.h"#include "../utils/log_utils.h"// Buffer de teste global para simular framebufferstatic uint32_t test_buffer[1024 * 768];static int test_result_count = 0;static int test_pass_count = 0;/** * @brief Função auxiliar para reportar resultados de teste */static void report_test(const char* test_name, int result) {    test_result_count++;    if (result) {        printf("[PASS] %s\n", test_name);        test_pass_count++;    } else {        printf("[FAIL] %s\n", test_name);    }}/** * @brief Testa a cópia segura do framebuffer */static void test_safe_framebuffer_copy() {    // Preparar dados de teste    uint32_t src_buffer[100 * 100];    uint32_t dst_buffer[320 * 240];        // Preencher fonte com padrão reconhecível    for (int i = 0; i < 100 * 100; i++) {        src_buffer[i] = 0xAA000000 | i;    }        // Limpar destino    memset(dst_buffer, 0, sizeof(dst_buffer));        // Dimensões de teste    const int src_width = 100;    const int src_height = 100;    const int dst_width = 320;    const int dst_height = 240;        // Simular a cópia segura implementada em emu_frontend_render_frame    for (int y = 0; y < src_height && y < dst_height; y++) {        for (int x = 0; x < src_width && x < dst_width; x++) {            // Calcular índices com verificação de limites            int src_idx = y * src_width + x;            int dst_idx = y * dst_width + x;                        // Verificar se os índices estão dentro dos limites            if (src_idx >= 0 && src_idx < src_width * src_height &&                dst_idx >= 0 && dst_idx < dst_width * dst_height) {                dst_buffer[dst_idx] = src_buffer[src_idx];            }        }    }        // Verificar se a cópia foi feita corretamente    int success = 1;    for (int y = 0; y < src_height; y++) {        for (int x = 0; x < src_width; x++) {            int src_idx = y * src_width + x;            int dst_idx = y * dst_width + x;                        if (dst_buffer[dst_idx] != src_buffer[src_idx]) {                printf("Erro na posição (%d,%d): esperado 0x%08X, obtido 0x%08X\n",                        x, y, src_buffer[src_idx], dst_buffer[dst_idx]);                success = 0;                break;            }        }        if (!success) break;    }        report_test("Cópia segura de framebuffer", success);}/** * @brief Testa a limpeza de framebuffer */static void test_framebuffer_clear() {    // Preparar dados de teste    uint32_t buffer[320 * 240];        // Preencher com valores não-zero    for (int i = 0; i < 320 * 240; i++) {        buffer[i] = 0xFFFFFFFF;    }        // Dimensões de teste    const int width = 320;    const int height = 240;        // Simular a limpeza de framebuffer implementada    memset(buffer, 0, width * height * sizeof(uint32_t));        // Verificar se a limpeza foi feita corretamente    int success = 1;    for (int i = 0; i < width * height; i++) {        if (buffer[i] != 0) {            printf("Erro na posição %d: esperado 0, obtido 0x%08X\n", i, buffer[i]);            success = 0;            break;        }    }        report_test("Limpeza de framebuffer", success);}/** * @brief Testa a correção de canal alfa */static void test_alpha_channel_correction() {    // Preparar dados de teste    uint32_t buffer[100 * 100];        // Preencher com valores sem canal alfa    for (int i = 0; i < 100 * 100; i++) {        buffer[i] = 0x00FFFFFF;  // RGB sem alfa    }        // Dimensões de teste    const int width = 100;    const int height = 100;        // Simular a correção de canal alfa implementada    for (int i = 0; i < width * height; i++) {        if ((buffer[i] & 0xFF000000) == 0) {            buffer[i] |= 0xFF000000;  // Definir canal alfa como opaco        }    }        // Verificar se a correção foi feita corretamente    int success = 1;    for (int i = 0; i < width * height; i++) {        if ((buffer[i] & 0xFF000000) != 0xFF000000) {            printf("Erro na posição %d: alfa não corrigido, valor 0x%08X\n", i, buffer[i]);            success = 0;            break;        }    }        report_test("Correção de canal alfa", success);}/** * @brief Testa a verificação de limites do framebuffer */static void test_framebuffer_bounds_check() {    const int max_width = 1024;    const int max_height = 768;        // Testar dimensões válidas    int valid_width = 640;    int valid_height = 480;    int valid_result = (valid_width > 0 && valid_height > 0 &&                         valid_width <= max_width && valid_height <= max_height);        // Testar dimensões inválidas    int invalid_width = 2000;    int invalid_height = 1500;    int invalid_result = (invalid_width > 0 && invalid_height > 0 &&                           invalid_width <= max_width && invalid_height <= max_height);        report_test("Verificação de limites válidos", valid_result == 1);    report_test("Verificação de limites inválidos", invalid_result == 0);}/** * @brief Função principal para executar os testes */int main(void) {    printf("Iniciando testes unitários de framebuffer\n");    printf("=========================================\n");        // Executar testes    test_safe_framebuffer_copy();    test_framebuffer_clear();    test_alpha_channel_correction();    test_framebuffer_bounds_check();        // Reportar resultados    printf("=========================================\n");    printf("Resultados: %d/%d testes passaram (%.1f%%)\n",            test_pass_count, test_result_count,            (test_result_count > 0) ? (test_pass_count * 100.0 / test_result_count) : 0.0);        return (test_pass_count == test_result_count) ? 0 : 1;} 