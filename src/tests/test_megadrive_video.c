/** * @file test_megadrive_video.c * @brief Testes para as funções de vídeo do Mega Drive */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <assert.h>#include "../platforms/megadrive/megadrive.h"#include "../platforms/megadrive/video/vdp.h"#include "../core/core.h"#include "../core/interfaces/video_interface.h"// Mock para a função emu_video_write_datastatic int g_write_data_called = 0;static emu_video_t g_last_write_data_video = NULL;static uint16_t g_last_write_data_address = 0;static uint8_t g_last_write_data_value = 0;bool mock_emu_video_write_data(emu_video_t video, uint16_t address, uint8_t value){    g_write_data_called++;    g_last_write_data_video = video;    g_last_write_data_address = address;    g_last_write_data_value = value;    return true;}// Mock para a função emu_video_write_controlstatic int g_write_control_called = 0;static emu_video_t g_last_write_control_video = NULL;static uint8_t g_last_write_control_value = 0;bool mock_emu_video_write_control(emu_video_t video, uint8_t value){    g_write_control_called++;    g_last_write_control_video = video;    g_last_write_control_value = value;    return true;}// Mock para a função emu_video_read_datastatic int g_read_data_called = 0;static emu_video_t g_last_read_data_video = NULL;static uint16_t g_last_read_data_address = 0;static uint8_t g_read_data_return_value = 0x42;bool mock_emu_video_read_data(emu_video_t video, uint16_t address, uint8_t *value){    g_read_data_called++;    g_last_read_data_video = video;    g_last_read_data_address = address;    *value = g_read_data_return_value;    return true;}// Mock para a função emu_video_read_controlstatic int g_read_control_called = 0;static emu_video_t g_last_read_control_video = NULL;static uint8_t g_read_control_return_value = 0x69;bool mock_emu_video_read_control(emu_video_t video, uint8_t *value){    g_read_control_called++;    g_last_read_control_video = video;    *value = g_read_control_return_value;    return true;}// Estrutura de teste para o Mega Drivetypedef struct{    md_platform_data_t platform_data;    emu_video_t mock_vdp;    uint8_t ram[64 * 1024];} test_md_context_t;/** * @brief Configura o ambiente de teste */static test_md_context_t *setup_test(){    test_md_context_t *ctx = (test_md_context_t *)malloc(sizeof(test_md_context_t));    memset(ctx, 0, sizeof(test_md_context_t));    // Inicializar com valores de teste    ctx->mock_vdp = malloc(1); // Mock para simular um ponteiro válido    ctx->platform_data.vdp = ctx->mock_vdp;    ctx->platform_data.ram = ctx->ram;    ctx->platform_data.ram_size = sizeof(ctx->ram);    // Substituir as funções de vídeo reais pelas mocks    emu_video_interface_t *vid_interface = emu_video_get_interface();    vid_interface->write_data = mock_emu_video_write_data;    vid_interface->write_control = mock_emu_video_write_control;    vid_interface->read_data = mock_emu_video_read_data;    vid_interface->read_control = mock_emu_video_read_control;    // Reset dos contadores de chamadas    g_write_data_called = 0;    g_write_control_called = 0;    g_read_data_called = 0;    g_read_control_called = 0;    return ctx;}/** * @brief Limpa o ambiente de teste */static void teardown_test(test_md_context_t *ctx){    if (ctx)    {        if (ctx->mock_vdp)        {            free(ctx->mock_vdp);        }        free(ctx);    }}/** * @brief Testa a escrita de 8 bits para o VDP */static void test_md_m68k_write_8(){    printf("Teste: md_m68k_write_8 para VDP\n");    test_md_context_t *ctx = setup_test();    // Definir g_md_data global para o contexto de teste    extern md_platform_data_t *g_md_data;    g_md_data = &ctx->platform_data;    // Chamar a função com um endereço na faixa do VDP (porta de dados + 1)    uint32_t address = 0xC00001; // VDP_PORT_DATA + 1    uint8_t value = 0x55;    // Executar a função sob teste (md_m68k_write_8)    extern void md_m68k_write_8(uint32_t address, uint8_t value);    md_m68k_write_8(address, value);    // Verificar se a função mock foi chamada com os parâmetros corretos    assert(g_write_data_called == 1);    assert(g_last_write_data_video == ctx->mock_vdp);    assert(g_last_write_data_address == (address & 0xFFFF));    assert(g_last_write_data_value == value);    // Teste para porta de controle    address = 0xC00005; // VDP_PORT_CONTROL + 1    value = 0xAA;    md_m68k_write_8(address, value);    assert(g_write_control_called == 1);    assert(g_last_write_control_video == ctx->mock_vdp);    assert(g_last_write_control_value == value);    teardown_test(ctx);    printf("OK\n");}/** * @brief Testa a escrita de 16 bits para o VDP */static void test_md_m68k_write_16(){    printf("Teste: md_m68k_write_16 para VDP\n");    test_md_context_t *ctx = setup_test();    // Definir g_md_data global para o contexto de teste    extern md_platform_data_t *g_md_data;    g_md_data = &ctx->platform_data;    // Chamar a função com um endereço na faixa do VDP (porta de dados)    uint32_t address = 0xC00000; // VDP_PORT_DATA    uint16_t value = 0x1234;    // Executar a função sob teste (md_m68k_write_16)    extern void md_m68k_write_16(uint32_t address, uint16_t value);    md_m68k_write_16(address, value);    // Verificar se a função mock foi chamada com os parâmetros corretos    assert(g_write_data_called == 1);    assert(g_last_write_data_video == ctx->mock_vdp);    assert(g_last_write_data_address == (address & 0xFFFF));    assert(g_last_write_data_value == value);    // Teste para porta de controle    address = 0xC00004; // VDP_PORT_CONTROL    value = 0x5678;    md_m68k_write_16(address, value);    assert(g_write_control_called == 1);    assert(g_last_write_control_video == ctx->mock_vdp);    assert(g_last_write_control_value == value);    teardown_test(ctx);    printf("OK\n");}/** * @brief Testa a leitura de 8 bits do VDP */static void test_md_m68k_read_8(){    printf("Teste: md_m68k_read_8 para VDP\n");    test_md_context_t *ctx = setup_test();    // Definir g_md_data global para o contexto de teste    extern md_platform_data_t *g_md_data;    g_md_data = &ctx->platform_data;    // Definir o valor de retorno para a leitura de dados    g_read_data_return_value = 0x42;    // Chamar a função com um endereço na faixa do VDP (porta de dados)    uint32_t address = 0xC00000; // VDP_PORT_DATA    // Executar a função sob teste (md_m68k_read_8)    extern uint8_t md_m68k_read_8(uint32_t address);    uint8_t result = md_m68k_read_8(address);    // Verificar se a função mock foi chamada com os parâmetros corretos    assert(g_read_data_called == 1);    assert(g_last_read_data_video == ctx->mock_vdp);    assert(g_last_read_data_address == (address & 0xFFFF));    // Verificar o valor retornado (deve ser o valor de retorno da mock)    assert(result == ((g_read_data_return_value >> 8) & 0xFF));    // Teste para porta de controle    address = 0xC00004; // VDP_PORT_CONTROL    g_read_control_return_value = 0x69;    result = md_m68k_read_8(address);    assert(g_read_control_called == 1);    assert(g_last_read_control_video == ctx->mock_vdp);    assert(result == ((g_read_control_return_value >> 8) & 0xFF));    teardown_test(ctx);    printf("OK\n");}/** * @brief Testa a leitura de 16 bits do VDP */static void test_md_m68k_read_16(){    printf("Teste: md_m68k_read_16 para VDP\n");    test_md_context_t *ctx = setup_test();    // Definir g_md_data global para o contexto de teste    extern md_platform_data_t *g_md_data;    g_md_data = &ctx->platform_data;    // Definir o valor de retorno para a leitura de dados    g_read_data_return_value = 0x42;    // Chamar a função com um endereço na faixa do VDP (porta de dados)    uint32_t address = 0xC00000; // VDP_PORT_DATA    // Executar a função sob teste (md_m68k_read_16)    extern uint16_t md_m68k_read_16(uint32_t address);    uint16_t result = md_m68k_read_16(address);    // Verificar se a função mock foi chamada com os parâmetros corretos    assert(g_read_data_called == 2); // Uma chamada para o byte alto e uma para o baixo    assert(g_last_read_data_video == ctx->mock_vdp);    // Verificar o valor retornado (deve combinar os dois bytes retornados)    assert(result == ((g_read_data_return_value << 8) | g_read_data_return_value));    // Reset dos contadores para o próximo teste    g_read_data_called = 0;    g_read_control_called = 0;    // Teste para porta de controle    address = 0xC00004; // VDP_PORT_CONTROL    g_read_control_return_value = 0x69;    result = md_m68k_read_16(address);    assert(g_read_control_called == 2); // Uma chamada para o byte alto e uma para o baixo    assert(g_last_read_control_video == ctx->mock_vdp);    assert(result == ((g_read_control_return_value << 8) | g_read_control_return_value));    teardown_test(ctx);    printf("OK\n");}/** * @brief Função principal para executar todos os testes */int main(){    printf("=== TESTE DE ACESSO AO VDP DO MEGA DRIVE ===\n");    test_md_m68k_write_8();    test_md_m68k_write_16();    test_md_m68k_read_8();    test_md_m68k_read_16();    printf("Todos os testes passaram com sucesso!\n");    return 0;}