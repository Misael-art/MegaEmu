void test_event_filtering(void) {    EventFilter filter = {        .type_mask = EMU_EVENT_CPU_INTERRUPT | EMU_EVENT_DMA_TRANSFER,        .time_start = 1000,        .time_end = 2000    };        EmuNodeEvent test_event = {        .type = EMU_EVENT_CPU_INTERRUPT,        .timestamp = 1500    };        TEST_ASSERT_TRUE(event_filter_match(&filter, &test_event));}void test_event_statistics(void) {    EventStats stats = {0};        for (int i = 0; i < 1000; i++) {        EmuNodeEvent event = {            .type = i % 3,            .timestamp = i * 100        };        event_stats_update(&stats, &event);    }        TEST_ASSERT_EQUAL(1000, stats.total_events);    TEST_ASSERT_EQUAL(334, stats.events_by_type[0]);}void test_performance_analysis(void) {    EventAnalyzer* analyzer = event_analyzer_create(1000);    analyzer->start_recording();        // Simular carga de eventos    for (int i = 0; i < 100; i++) {        EmuNodeEvent event = {            .type = EMU_EVENT_TIMER_TICK,            .timestamp = i * 1000        };        emu_dispatch_event(root_node, &event);    }        analyzer->stop_recording();        TEST_ASSERT_NOT_EQUAL(0, analyzer->metrics_buffer[0].processing_time);    TEST_ASSERT_LESS_THAN(1000, analyzer->metrics_buffer[0].queue_size);        event_analyzer_destroy(analyzer);}