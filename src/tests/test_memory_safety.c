/** * @file test_memory_safety.c * @brief Testes unitários para as funções de segurança de memória * * Este arquivo contém testes para as funções críticas relacionadas à * segurança de memória no core do emulador. */#include <stdio.h>#include <stdlib.h>#include <string.h>#include "../core/core.h"#include "../utils/error_handling.h"#include "../utils/log_utils.h"#include "../utils/enhanced_log.h"#include "../utils/platform_compat.h"// Contadores de testestatic int test_result_count = 0;static int test_pass_count = 0;/** * @brief Função auxiliar para reportar resultados de teste */static void report_test(const char *test_name, int result){    test_result_count++;    if (result)    {        printf("[PASS] %s\n", test_name);        test_pass_count++;    }    else    {        printf("[FAIL] %s\n", test_name);    }}/** * @brief Mock para a função de log */static void test_log(int level, const char *message){    const char *level_str = "UNKNOWN";    switch (level)    {    case EMU_LOG_LEVEL_ERROR:        level_str = "ERROR";        break;    case EMU_LOG_LEVEL_WARNING:        level_str = "WARNING";        break;    case EMU_LOG_LEVEL_INFO:        level_str = "INFO";        break;    case EMU_LOG_LEVEL_DEBUG:        level_str = "DEBUG";        break;    case EMU_LOG_LEVEL_TRACE:        level_str = "TRACE";        break;    }    printf("[TEST LOG] %s: %s\n", level_str, message);}/** * @brief Testa a validação de parâmetros em emu_platform_render_frame */static void test_platform_render_frame_params(){    // Para este teste, precisamos de stubs para simular a estrutura emu_platform_t    emu_platform_t test_platform = {0};    test_platform.initialized = 1; // Plataforma inicializada    // Buffer para o framebuffer    uint32_t framebuffer[320 * 240];    // Testar com parâmetros válidos    int width = 320;    int height = 240;    // Simular a verificação de parâmetros usando as macros atualizadas    int success_valid = 1;    // Teste usando EMU_CHECK_NULL - não causa erro aqui    if (&test_platform == NULL || framebuffer == NULL)    {        success_valid = 0;    }    // Teste usando EMU_CHECK_INIT - não causa erro aqui    if (!test_platform.initialized)    {        success_valid = 0;    }    // Teste usando EMU_CHECK_BOUNDS - não causa erro aqui    if (width <= 0 || width > 1024 || height <= 0 || height > 768)    {        success_valid = 0;    }    // Teste com dimensões válidas    int valid_width = 640;    int valid_height = 480;    int valid_result = (valid_width > 0 && valid_width <= 1024 &&                        valid_height > 0 && valid_height <= 768);    // Teste com dimensões inválidas    int invalid_width = 2000;    int invalid_height = 1500;    int invalid_result = (invalid_width > 0 && invalid_width <= 1024 &&                          invalid_height > 0 && invalid_height <= 768);    // Relatório de testes    report_test("Validação de parâmetros - válidos", success_valid == 1);    report_test("Verificação de limites válidos", valid_result);    report_test("Verificação de limites inválidos", !invalid_result);}/** * @brief Testa a correção de canal alfa pós-renderização */static void test_post_render_alpha_correction(){    // Criar buffer de teste    uint32_t framebuffer[100 * 100];    // Preencher com pixels sem alfa    for (int i = 0; i < 100 * 100; i++)    {        // Alguns pixels sem alfa, outros com alfa        if (i % 2 == 0)        {            framebuffer[i] = 0x00112233; // Sem alfa        }        else        {            framebuffer[i] = 0xFF445566; // Com alfa        }    }    // Simular a correção de alfa    for (int i = 0; i < 100 * 100; i++)    {        if ((framebuffer[i] & 0xFF000000) == 0)        {            framebuffer[i] |= 0xFF000000; // Adicionar alfa 0xFF        }    }    // Verificar se todos têm alfa    int all_have_alpha = 1;    for (int i = 0; i < 100 * 100; i++)    {        if ((framebuffer[i] & 0xFF000000) == 0)        {            all_have_alpha = 0;            break;        }    }    report_test("Correção de canal alfa", all_have_alpha);}/** * @brief Testa o padrão de fallback quando não há framebuffer */static void test_render_fallback_pattern(){    // Simular o caso de fallback onde não temos um framebuffer válido    uint32_t fallback_buffer[64 * 64];    memset(fallback_buffer, 0, sizeof(fallback_buffer));    // Gerar um padrão de xadrez para o fallback    for (int y = 0; y < 64; y++)    {        for (int x = 0; x < 64; x++)        {            if ((x + y) % 2 == 0)            {                fallback_buffer[y * 64 + x] = 0xFF888888; // Cinza escuro            }            else            {                fallback_buffer[y * 64 + x] = 0xFF444444; // Cinza mais escuro            }        }    }    // Verificar se o padrão está correto    int pattern_correct = 1;    for (int y = 0; y < 64; y++)    {        for (int x = 0; x < 64; x++)        {            uint32_t expected = ((x + y) % 2 == 0) ? 0xFF888888 : 0xFF444444;            if (fallback_buffer[y * 64 + x] != expected)            {                pattern_correct = 0;                break;            }        }        if (!pattern_correct)        {            break;        }    }    report_test("Padrão de fallback", pattern_correct);}int main(void){    printf("\n=== Testes de Segurança de Memória ===\n");    // Executar testes    test_platform_render_frame_params();    test_post_render_alpha_correction();    test_render_fallback_pattern();    // Relatório final    printf("\n=== Resultados ===\n");    printf("Total de testes: %d\n", test_result_count);    printf("Testes com sucesso: %d\n", test_pass_count);    printf("Testes com falha: %d\n", test_result_count - test_pass_count);    return (test_result_count == test_pass_count) ? 0 : 1;}