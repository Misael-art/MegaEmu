/** * @file main.cpp * @brief Arquivo principal do emulador Mega_Emu * @author Mega_Emu Team * @version 1.2.0 * @date 2024-07-22 */// Inclus√£o de headers C++#include <iostream>#include <SDL2/SDL.h>#ifdef USE_SDL2_IMAGE#include <SDL2/SDL_image.h>#endif#include <string>#include <vector>#include <filesystem>#include <fstream>#include <chrono>#include <thread>#include <memory>#include <algorithm>#include <cstdint>#include <ctime>#include <functional>// Incluir headers do sistema#include "core/rom_loader.h"#include "core/core_types.h"#include "frontend/renderer/nes_renderer.h"#include "frontend/renderer/text_renderer.h"#include "frontend/renderer/text_renderer_cpp_bridge.h"#include "frontend/gui_manager_cpp_bridge.h"#include "platforms/nes/nes.h"#include "platforms/nes/input/nes_input.h"#include "frontend/audio/menu_sounds.h"#include "frontend/gui_save_state.h"// Adicionar declara√ß√µes externas para o gerenciador de GUIextern "C"{    // Cria uma inst√¢ncia do gerenciador de GUI    gui_manager_t *gui_manager_create(SDL_Renderer *renderer);    // Destr√≥i uma inst√¢ncia do gerenciador de GUI    void gui_manager_destroy(gui_manager_t *manager);    // Processa um evento para o gerenciador de GUI    void gui_manager_process_event(gui_manager_t *manager, const gui_event_s *event);    // Renderiza os elementos gerenciados pelo gerenciador de GUI    void gui_manager_render(gui_manager_t *manager);    // Cria uma janela gerenciada pelo gerenciador de GUI    gui_element_id_t gui_manager_create_window(gui_manager_t *manager,                                               const char *title,                                               int x, int y, int width, int height,                                               uint32_t style);    // Cria um r√≥tulo gerenciado pelo gerenciador de GUI    gui_element_id_t gui_manager_create_label(gui_manager_t *manager,                                              gui_element_id_t parent_id,                                              const char *text,                                              int x, int y, int width, int height,                                              uint32_t align);    // Cria um bot√£o gerenciado pelo gerenciador de GUI    gui_element_id_t gui_manager_create_button(gui_manager_t *manager,                                               gui_element_id_t parent_id,                                               const char *text,                                               int x, int y, int width, int height,                                               void (*callback)(gui_element_s *, void *),                                               void *user_data);    // Define a visibilidade de um elemento    void gui_manager_set_element_visible(gui_manager_t *manager,                                         gui_element_id_t element_id,                                         bool visible);    // Traz um elemento para a frente da hierarquia    void gui_manager_bring_to_front(gui_manager_t *manager,                                    gui_element_id_t element_id);}namespace fs = std::filesystem;// Constantes do emulador#define NES_SCREEN_WIDTH 256#define NES_SCREEN_HEIGHT 240#define NES_DEFAULT_SCALE 3#define NES_AUDIO_BUFFER_SIZE 4096#define NES_ENABLE_VSYNC true// Defini√ß√µes para o modo de emula√ß√£oenum EmulationMode{    MODE_MENU,    MODE_ROM_BROWSER,    MODE_EMULATION};// Estrutura para representar um bot√£ostruct Button{    SDL_Rect rect;    std::string text;    SDL_Color color;    SDL_Color hoverColor;    bool isHovered;};// Estrutura para representar uma entrada no navegador de ROMsstruct RomEntry{    std::string name;    std::string path;    bool isDirectory;    SDL_Rect rect;    bool isHovered;};// Estrutura para anima√ß√£o de transi√ß√£ostruct Transition{    bool active;    float progress;    EmulationMode from_mode;    EmulationMode to_mode;    float duration;};// Buffers para renderiza√ß√£o e √°udiostatic uint32_t g_frame_buffer[NES_SCREEN_WIDTH * NES_SCREEN_HEIGHT];static int16_t g_audio_buffer[NES_AUDIO_BUFFER_SIZE];// Vari√°veis de estado globalstatic EmulationMode g_current_mode = MODE_MENU;static bool g_emulation_running = false;static bool g_fullscreen = false;static int g_scale_factor = NES_DEFAULT_SCALE;static std::string g_current_rom;// Vari√°veis para o navegador de ROMsstatic std::vector<RomEntry> g_rom_entries;static std::string g_current_directory;static int g_scroll_offset = 0;static const int ENTRIES_PER_PAGE = 10;static const int ENTRY_HEIGHT = 40;// Mapeamento de teclas para bot√µes do NESstruct KeyMapping{    SDL_Scancode key;    uint8_t nes_button;};static KeyMapping g_key_mapping[] = {    {SDL_SCANCODE_X, NES_BUTTON_A},    {SDL_SCANCODE_Z, NES_BUTTON_B},    {SDL_SCANCODE_BACKSPACE, NES_BUTTON_SELECT},    {SDL_SCANCODE_RETURN, NES_BUTTON_START},    {SDL_SCANCODE_UP, NES_BUTTON_UP},    {SDL_SCANCODE_DOWN, NES_BUTTON_DOWN},    {SDL_SCANCODE_LEFT, NES_BUTTON_LEFT},    {SDL_SCANCODE_RIGHT, NES_BUTTON_RIGHT}};// Estrutura para anima√ß√£o de transi√ß√£ostatic Transition g_transition = {false, 0.0f, MODE_MENU, MODE_MENU, 0.3f};// Estrutura para efeitos sonoros do menustruct MenuSounds{    SDL_AudioDeviceID device;    uint8_t *hover_sound;    uint8_t *select_sound;    uint8_t *back_sound;    int hover_length;    int select_length;    int back_length;};static MenuSounds g_menu_sounds = {0};// Declara√ß√µes de fun√ß√µesvoid startTransition(EmulationMode from, EmulationMode to);// Vari√°veis globais para controle de hoverstatic int hoveredButton = -1;static int hoveredEntry = -1;static bool was_hovered = false;// Vari√°veis globaisSDL_Window *g_window = NULL;SDL_Renderer *g_renderer = NULL;gui_manager_t *g_gui_manager = NULL;// Fun√ß√£o para renderizar um bot√£o com textovoid renderButton(SDL_Renderer *renderer, const Button &button){    // Definir a cor do bot√£o (normal ou hover)    if (button.isHovered)    {        SDL_SetRenderDrawColor(renderer,                               button.hoverColor.r,                               button.hoverColor.g,                               button.hoverColor.b,                               button.hoverColor.a);    }    else    {        SDL_SetRenderDrawColor(renderer,                               button.color.r,                               button.color.g,                               button.color.b,                               button.color.a);    }    // Desenhar o ret√¢ngulo do bot√£o    SDL_RenderFillRect(renderer, &button.rect);    // Desenhar a borda do bot√£o    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);    SDL_RenderDrawRect(renderer, &button.rect);    // Renderizar o texto do bot√£o    SDL_Color textColor = {255, 255, 255, 255};    text_renderer_draw_styled(button.text.c_str(),                              button.rect.x + button.rect.w / 2,                              button.rect.y + button.rect.h / 2 - 8,                              textColor,                              TEXT_SIZE_MEDIUM,                              TEXT_ALIGN_CENTER,                              TEXT_STYLE_NORMAL);}// Fun√ß√£o para obter o nome do sistemaconst char *getSystemName(SystemType system){    switch (system)    {    case SYSTEM_NES:        return "Nintendo Entertainment System";    case SYSTEM_SNES:        return "Super Nintendo";    case SYSTEM_MEGADRIVE:        return "Sega Mega Drive";    case SYSTEM_UNKNOWN:    default:        return "Sistema Desconhecido";    }}// Fun√ß√£o para processar entradas durante a emula√ß√£o (vers√£o SDL_Event)void processEmulationInputEvent(SDL_Event *event){    if (event->type == SDL_KEYDOWN)    {        switch (event->key.keysym.sym)        {        case SDLK_ESCAPE:            menu_sounds_play_back();            startTransition(MODE_EMULATION, MODE_MENU);            g_emulation_running = false;            g_current_mode = MODE_MENU;            break;        }    }}// Fun√ß√£o para processar entradas durante a emula√ß√£o (vers√£o controller_state)void processEmulationInputState(SDL_Event &event, uint8_t &controller_state){    // Processar eventos para o save state se estiver vis√≠vel    if (gui_save_state_is_visible())    {        cpp_gui_event_t gui_event = {0};        // Converter evento SDL para evento GUI        if (event.type == SDL_MOUSEMOTION)        {            gui_event.type = static_cast<int>(GUI_EVENT_MOUSE_MOVE);            gui_event.mouse.x = event.motion.x;            gui_event.mouse.y = event.motion.y;        }        else if (event.type == SDL_MOUSEBUTTONDOWN)        {            gui_event.type = static_cast<int>(GUI_EVENT_MOUSE_DOWN);            gui_event.mouse.x = event.button.x;            gui_event.mouse.y = event.button.y;            gui_event.mouse.button = event.button.button;        }        else if (event.type == SDL_MOUSEBUTTONUP)        {            gui_event.type = static_cast<int>(GUI_EVENT_MOUSE_UP);            gui_event.mouse.x = event.button.x;            gui_event.mouse.y = event.button.y;            gui_event.mouse.button = event.button.button;        }        // Obter o estado p√∫blico do save state        gui_save_state_t *state = reinterpret_cast<gui_save_state_t *>(gui_save_state_get_state());        // Processar o evento        gui_save_state_handle_event(state, &gui_event);        return;    }    // Estado inicial    if (event.type == SDL_KEYDOWN)    {        SDL_Scancode scancode = event.key.keysym.scancode;        // Teclas de sistema        if (scancode == SDL_SCANCODE_ESCAPE)        {            startTransition(MODE_EMULATION, MODE_MENU);            g_emulation_running = false;            g_current_mode = MODE_MENU;            return;        }        else if (scancode == SDL_SCANCODE_F11)        {            g_fullscreen = !g_fullscreen;            nes_renderer_set_fullscreen(g_fullscreen);            return;        }        else if (scancode == SDL_SCANCODE_F1)        {            // Mostrar interface de save state para salvar            gui_save_state_show(false, on_save_state_complete, NULL);            return;        }        else if (scancode == SDL_SCANCODE_F4)        {            // Mostrar interface de save state para carregar            gui_save_state_show(true, on_save_state_complete, NULL);            return;        }        else if (scancode == SDL_SCANCODE_F5)        {            // Reset            nes_reset();            return;        }        // Mapear teclas para bot√µes do NES        for (const auto &mapping : g_key_mapping)        {            if (scancode == mapping.key)            {                controller_state |= mapping.nes_button;                break;            }        }    }    else if (event.type == SDL_KEYUP)    {        SDL_Scancode scancode = event.key.keysym.scancode;        // Mapear teclas para bot√µes do NES        for (const auto &mapping : g_key_mapping)        {            if (scancode == mapping.key)            {                controller_state &= ~mapping.nes_button;                break;            }        }    }}// Fun√ß√£o para iniciar a emula√ß√£o com um arquivo ROM espec√≠ficobool startEmulation(const char *rom_path){    // Configurar o NES    nes_config_t config = {0};    config.audio_enabled = NES_ENABLE_AUDIO;    config.audio_sample_rate = NES_AUDIO_SAMPLE_RATE;    config.video_scale = g_scale_factor;    config.vsync_enabled = NES_ENABLE_VSYNC;    config.fullscreen = g_fullscreen;    config.filter_type = 0; // Sem filtro    config.region = NES_DEFAULT_REGION;    config.log_level = EMU_LOG_LEVEL_INFO;    config.rom_path = rom_path;    // Inicializar o emulador NES    if (nes_init(&config) != 0)    {        std::cerr << "Erro ao inicializar o emulador NES" << std::endl;        return false;    }    // Carregar a ROM    if (nes_load_rom(rom_path) != 0)    {        std::cerr << "Erro ao carregar a ROM: " << rom_path << std::endl;        nes_shutdown();        return false;    }    g_current_rom = rom_path;    g_emulation_running = true;    g_current_mode = MODE_EMULATION;    std::cout << "Emula√ß√£o iniciada com a ROM: " << rom_path << std::endl;    return true;}// Fun√ß√£o para encerrar a emula√ß√£ovoid stopEmulation(){    if (g_emulation_running)    {        nes_shutdown();        g_emulation_running = false;        g_current_mode = MODE_MENU;        std::cout << "Emula√ß√£o encerrada" << std::endl;    }}// Fun√ß√£o para executar um frame da emula√ß√£obool runEmulationFrame(){    if (!g_emulation_running)    {        return false;    }    // Executar um frame do NES    if (nes_run_frame(g_frame_buffer, g_audio_buffer, NES_AUDIO_BUFFER_SIZE) != 0)    {        std::cerr << "Erro ao executar frame do NES" << std::endl;        return false;    }    // Renderizar o frame    if (nes_renderer_render_frame(g_frame_buffer) != 0)    {        std::cerr << "Erro ao renderizar frame" << std::endl;        return false;    }    // Mostrar informa√ß√µes na tela durante a emula√ß√£o    SDL_Color white = {255, 255, 255, 255};    SDL_Color yellow = {255, 255, 0, 255};    // Mostrar o nome da ROM    std::string rom_name = g_current_rom;    size_t last_slash = rom_name.find_last_of("\\/");    if (last_slash != std::string::npos)    {        rom_name = rom_name.substr(last_slash + 1);    }    text_renderer_draw_styled(rom_name.c_str(), 10, 10, white, TEXT_SIZE_SMALL, TEXT_ALIGN_LEFT, TEXT_STYLE_NORMAL);    // Mostrar controles    std::string controls = "F1: Save | F4: Load | F5: Reset | ESC: Menu";    text_renderer_draw_styled(controls.c_str(), NES_SCREEN_WIDTH * g_scale_factor - 10, 10,                              yellow, TEXT_SIZE_SMALL, TEXT_ALIGN_RIGHT, TEXT_STYLE_NORMAL);    // Renderizar interface de save state se vis√≠vel    render_save_state();    return true;}// Fun√ß√£o para exibir o menu principalvoid renderMainMenu(SDL_Renderer *renderer, std::vector<Button> &buttons){    // Limpar a tela    SDL_SetRenderDrawColor(renderer, 20, 20, 40, 255);    SDL_RenderClear(renderer);    // Desenhar t√≠tulo    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);    SDL_Rect titleBar = {0, 0, 800, 80};    SDL_RenderFillRect(renderer, &titleBar);    // Desenhar linha separadora    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);    SDL_Rect separator = {0, 80, 800, 2};    SDL_RenderFillRect(renderer, &separator);    // Renderizar bot√µes    for (const auto &button : buttons)    {        renderButton(renderer, button);    }    // Renderizar t√≠tulo do emulador    SDL_Color titleColor = {20, 20, 100, 255};    text_renderer_draw_styled("MEGA_EMU", 400, 25, titleColor, TEXT_SIZE_XLARGE, TEXT_ALIGN_CENTER, TEXT_STYLE_BOLD);    SDL_Color subtitleColor = {60, 60, 60, 255};    text_renderer_draw_styled("Emulador Multi-Plataforma", 400, 55, subtitleColor, TEXT_SIZE_MEDIUM, TEXT_ALIGN_CENTER, TEXT_STYLE_NORMAL);    // Exibir informa√ß√£o sobre TTF    SDL_Color infoColor = {100, 100, 100, 255};    std::string ttf_info = text_renderer_has_ttf() ? "SDL2_TTF: Ativo" : "SDL2_TTF: Inativo";    text_renderer_draw_styled(ttf_info.c_str(), 790, 590, infoColor, TEXT_SIZE_SMALL, TEXT_ALIGN_RIGHT, TEXT_STYLE_NORMAL);    // Atualizar a tela    SDL_RenderPresent(renderer);}// Fun√ß√£o para carregar as entradas de ROM de um diret√≥riovoid loadRomEntries(const std::string &directory){    g_rom_entries.clear();    g_scroll_offset = 0;    g_current_directory = directory;    // Adicionar entrada para voltar ao diret√≥rio pai    if (fs::path(directory).has_parent_path())    {        RomEntry parentEntry;        parentEntry.name = "..";        parentEntry.path = fs::path(directory).parent_path().string();        parentEntry.isDirectory = true;        parentEntry.isHovered = false;        g_rom_entries.push_back(parentEntry);    }    // Listar diret√≥rios e ROMs    for (const auto &entry : fs::directory_iterator(directory))    {        RomEntry romEntry;        romEntry.name = entry.path().filename().string();        romEntry.path = entry.path().string();        romEntry.isDirectory = entry.is_directory();        romEntry.isHovered = false;        // Filtrar apenas diret√≥rios e arquivos .nes        if (romEntry.isDirectory ||            (entry.path().extension() == ".nes" && !entry.is_directory()))        {            g_rom_entries.push_back(romEntry);        }    }    // Ordenar entradas: diret√≥rios primeiro, depois ROMs    std::sort(g_rom_entries.begin(), g_rom_entries.end(),              [](const RomEntry &a, const RomEntry &b)              {                  if (a.isDirectory != b.isDirectory)                  {                      return a.isDirectory > b.isDirectory;                  }                  return a.name < b.name;              });    // Atualizar ret√¢ngulos para cada entrada    for (size_t i = 0; i < g_rom_entries.size(); i++)    {        g_rom_entries[i].rect = {            100,                         // x            120 + (int)i * ENTRY_HEIGHT, // y            600,                         // width            ENTRY_HEIGHT - 5             // height        };    }}// Fun√ß√£o para iniciar uma transi√ß√£ovoid startTransition(EmulationMode from, EmulationMode to){    g_transition.active = true;    g_transition.progress = 0.0f;    g_transition.from_mode = from;    g_transition.to_mode = to;}// Fun√ß√£o para atualizar e renderizar a transi√ß√£ovoid updateTransition(float delta_time, SDL_Renderer *renderer){    if (!g_transition.active)        return;    g_transition.progress += delta_time / g_transition.duration;    if (g_transition.progress >= 1.0f)    {        g_transition.active = false;        g_transition.progress = 0.0f;        return;    }    // Efeito de fade    int alpha = (int)(255 * (1.0f - g_transition.progress));    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);    SDL_SetRenderDrawColor(renderer, 0, 0, 0, alpha);    SDL_RenderFillRect(renderer, NULL);    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);}// Atualizar a fun√ß√£o renderRomBrowser para incluir mais feedback visualvoid renderRomBrowser(SDL_Renderer *renderer){    // Limpar a tela    SDL_SetRenderDrawColor(renderer, 20, 20, 40, 255);    SDL_RenderClear(renderer);    // Desenhar t√≠tulo    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);    SDL_Rect titleBar = {0, 0, 800, 80};    SDL_RenderFillRect(renderer, &titleBar);    // Desenhar linha separadora    SDL_SetRenderDrawColor(renderer, 100, 100, 100, 255);    SDL_Rect separator = {0, 80, 800, 2};    SDL_RenderFillRect(renderer, &separator);    // Renderizar t√≠tulo    SDL_Color titleColor = {20, 20, 100, 255};    text_renderer_draw_styled("Selecione uma ROM", 400, 25, titleColor, TEXT_SIZE_LARGE, TEXT_ALIGN_CENTER, TEXT_STYLE_BOLD);    // Renderizar diret√≥rio atual    SDL_Color pathColor = {60, 60, 60, 255};    text_renderer_draw_styled(g_current_directory.c_str(), 400, 55, pathColor, TEXT_SIZE_SMALL, TEXT_ALIGN_CENTER, TEXT_STYLE_NORMAL);    // Renderizar entradas vis√≠veis    int start_idx = g_scroll_offset;    int end_idx = std::min(start_idx + ENTRIES_PER_PAGE, (int)g_rom_entries.size());    for (int i = start_idx; i < end_idx; i++)    {        const auto &entry = g_rom_entries[i];        SDL_Color entryColor = entry.isDirectory ? SDL_Color{255, 200, 0, 255} : SDL_Color{255, 255, 255, 255};        // Desenhar fundo da entrada com gradiente        if (entry.isHovered)        {            for (int y = 0; y < entry.rect.h; y++)            {                int alpha = 40 + (int)(20.0f * (1.0f - (float)y / entry.rect.h));                SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);                SDL_SetRenderDrawColor(renderer, 60, 60, 100, alpha);                SDL_Rect line = {entry.rect.x, entry.rect.y + y, entry.rect.w, 1};                SDL_RenderFillRect(renderer, &line);            }            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);        }        // Desenhar √≠cone baseado no tipo        std::string icon = entry.isDirectory ? "üìÅ " : "üéÆ ";        std::string display_name = icon + (entry.isDirectory ? entry.name : entry.name);        // Desenhar sombra do texto        SDL_Color shadowColor = {0, 0, 0, 128};        text_renderer_draw_styled(display_name.c_str(),                                  entry.rect.x + 11,                                  entry.rect.y + entry.rect.h / 2 - 7,                                  shadowColor,                                  TEXT_SIZE_MEDIUM,                                  TEXT_ALIGN_LEFT,                                  TEXT_STYLE_NORMAL);        // Desenhar texto principal        text_renderer_draw_styled(display_name.c_str(),                                  entry.rect.x + 10,                                  entry.rect.y + entry.rect.h / 2 - 8,                                  entryColor,                                  TEXT_SIZE_MEDIUM,                                  TEXT_ALIGN_LEFT,                                  TEXT_STYLE_NORMAL);    }    // Adicionar barra de rolagem    if (g_rom_entries.size() > ENTRIES_PER_PAGE)    {        int scrollbar_height = 400;        int thumb_height = (int)(scrollbar_height * ((float)ENTRIES_PER_PAGE / g_rom_entries.size()));        int thumb_pos = (int)(scrollbar_height * ((float)g_scroll_offset / g_rom_entries.size()));        // Desenhar trilha da barra de rolagem        SDL_SetRenderDrawColor(renderer, 40, 40, 60, 255);        SDL_Rect scrollbar_track = {770, 100, 4, scrollbar_height};        SDL_RenderFillRect(renderer, &scrollbar_track);        // Desenhar o thumb da barra de rolagem        SDL_SetRenderDrawColor(renderer, 120, 120, 160, 255);        SDL_Rect scrollbar_thumb = {770, 100 + thumb_pos, 4, thumb_height};        SDL_RenderFillRect(renderer, &scrollbar_thumb);    }    // Renderizar indicadores de scroll se necess√°rio    if (g_scroll_offset > 0)    {        text_renderer_draw_styled("‚ñ≤", 780, 100, SDL_Color{255, 255, 255, 255},                                  TEXT_SIZE_MEDIUM, TEXT_ALIGN_CENTER, TEXT_STYLE_NORMAL);    }    if (end_idx < (int)g_rom_entries.size())    {        text_renderer_draw_styled("‚ñº", 780, 500, SDL_Color{255, 255, 255, 255},                                  TEXT_SIZE_MEDIUM, TEXT_ALIGN_CENTER, TEXT_STYLE_NORMAL);    }    // Renderizar instru√ß√µes    SDL_Color helpColor = {180, 180, 180, 255};    text_renderer_draw_styled("ESC: Voltar | ENTER: Selecionar | ‚Üë‚Üì: Navegar",                              400, 570, helpColor, TEXT_SIZE_SMALL, TEXT_ALIGN_CENTER, TEXT_STYLE_NORMAL);    SDL_RenderPresent(renderer);}// Fun√ß√£o para processar eventos do mouse no navegador de ROMsvoid processRomBrowserMouseWheel(SDL_Event &event){    if (event.type == SDL_MOUSEWHEEL)    {        if (event.wheel.y > 0)        { // Scroll up            if (g_scroll_offset > 0)            {                g_scroll_offset--;            }        }        else if (event.wheel.y < 0)        { // Scroll down            if (g_scroll_offset + ENTRIES_PER_PAGE < (int)g_rom_entries.size())            {                g_scroll_offset++;            }        }    }}// Fun√ß√£o para carregar efeitos sonorosbool loadMenuSounds(){    // Configurar especifica√ß√£o de √°udio    SDL_AudioSpec want, have;    SDL_memset(&want, 0, sizeof(want));    want.freq = 44100;    want.format = AUDIO_S16;    want.channels = 1;    want.samples = 4096;    want.callback = NULL;    g_menu_sounds.device = SDL_OpenAudioDevice(NULL, 0, &want, &have, 0);    if (g_menu_sounds.device == 0)    {        std::cerr << "Erro ao abrir dispositivo de √°udio: " << SDL_GetError() << std::endl;        return false;    }    SDL_PauseAudioDevice(g_menu_sounds.device, 0);    return true;}// Fun√ß√£o para reproduzir um efeito sonorovoid playMenuSound(uint8_t *sound, int length){    if (g_menu_sounds.device != 0)    {        SDL_QueueAudio(g_menu_sounds.device, sound, length);    }}// Fun√ß√£o para limpar recursos de √°udiovoid cleanupMenuSounds(){    if (g_menu_sounds.device != 0)    {        SDL_CloseAudioDevice(g_menu_sounds.device);    }}// Fun√ß√£o para processar entradas do navegador de ROMs (vers√£o SDL_Event)void processRomBrowserInputEvent(SDL_Event *event){    static int lastHoveredEntry = -1;    if (event->type == SDL_KEYDOWN)    {        switch (event->key.keysym.sym)        {        case SDLK_ESCAPE:            menu_sounds_play_back();            startTransition(MODE_ROM_BROWSER, MODE_MENU);            g_current_mode = MODE_MENU;            break;        case SDLK_UP:            if (g_scroll_offset > 0)            {                menu_sounds_play_hover();                g_scroll_offset--;            }            break;        case SDLK_DOWN:            if (g_scroll_offset + ENTRIES_PER_PAGE < (int)g_rom_entries.size())            {                menu_sounds_play_hover();                g_scroll_offset++;            }            break;        case SDLK_RETURN:            for (const auto &entry : g_rom_entries)            {                if (entry.isHovered)                {                    menu_sounds_play_select();                    if (entry.isDirectory)                    {                        loadRomEntries(entry.path);                    }                    else                    {                        startTransition(MODE_ROM_BROWSER, MODE_EMULATION);                        startEmulation(entry.path.c_str());                    }                    break;                }            }            break;        case SDLK_HOME:            if (g_scroll_offset > 0)            {                menu_sounds_play_hover();                g_scroll_offset = 0;            }            break;        case SDLK_END:            int max_scroll = std::max(0, (int)g_rom_entries.size() - ENTRIES_PER_PAGE);            if (g_scroll_offset < max_scroll)            {                menu_sounds_play_hover();                g_scroll_offset = max_scroll;            }            break;        }    }    else if (event->type == SDL_MOUSEMOTION)    {        int mouseX = event->motion.x;        int mouseY = event->motion.y;        bool any_hovered = false;        for (auto &entry : g_rom_entries)        {            bool was_hovered = entry.isHovered;            entry.isHovered = (mouseX >= entry.rect.x &&                               mouseX <= entry.rect.x + entry.rect.w &&                               mouseY >= entry.rect.y &&                               mouseY <= entry.rect.y + entry.rect.h);            if (entry.isHovered && !was_hovered)            {                menu_sounds_play_hover();            }            if (entry.isHovered)                any_hovered = true;        }        // Tocar som quando o mouse passa por uma entrada diferente        if (any_hovered && !was_hovered)        {            menu_sounds_play_hover();        }    }    else if (event->type == SDL_MOUSEBUTTONDOWN)    {        if (event->button.button == SDL_BUTTON_LEFT)        {            int mouseX = event->button.x;            int mouseY = event->button.y;            for (const auto &entry : g_rom_entries)            {                if (mouseX >= entry.rect.x &&                    mouseX <= entry.rect.x + entry.rect.w &&                    mouseY >= entry.rect.y &&                    mouseY <= entry.rect.y + entry.rect.h)                {                    menu_sounds_play_select();                    if (entry.isDirectory)                    {                        loadRomEntries(entry.path);                    }                    else                    {                        startTransition(MODE_ROM_BROWSER, MODE_EMULATION);                        startEmulation(entry.path.c_str());                    }                    break;                }            }        }    }    else if (event->type == SDL_MOUSEWHEEL)    {        if (event->wheel.y != 0)        {            menu_sounds_play_hover();        }        processRomBrowserMouseWheel(*event);    }    // Tocar som quando o mouse passa por uma entrada diferente    if (hoveredEntry != lastHoveredEntry && hoveredEntry != -1)    {        menu_sounds_play_hover();    }    lastHoveredEntry = hoveredEntry;}bool initializeSDL(void){    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0)    {        printf("Erro ao inicializar SDL: %s\n", SDL_GetError());        return false;    }    g_window = SDL_CreateWindow(        "Mega_Emu",        SDL_WINDOWPOS_UNDEFINED,        SDL_WINDOWPOS_UNDEFINED,        800,        600,        SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!g_window)    {        printf("Erro ao criar janela: %s\n", SDL_GetError());        return false;    }    g_renderer = SDL_CreateRenderer(g_window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);    if (!g_renderer)    {        printf("Erro ao criar renderer: %s\n", SDL_GetError());        SDL_DestroyWindow(g_window);        return false;    }    // ... existing code ...    // Inicializar sistema de sons do menu    if (!menu_sounds_init())    {        printf("Aviso: Falha ao inicializar sons do menu\n");        // Continuar mesmo se falhar, pois os sons n√£o s√£o cr√≠ticos    }    return true;}void cleanupSDL(void){    // Desligar sistema de sons do menu    menu_sounds_shutdown();    // ... existing code ...}void processMenuInput(SDL_Event *event){    static int lastHoveredButton = -1;    // ... existing code ...    // Tocar som quando o mouse passa por um bot√£o diferente    if (hoveredButton != lastHoveredButton && hoveredButton != -1)    {        menu_sounds_play_hover();    }    lastHoveredButton = hoveredButton;    if (event->type == SDL_MOUSEBUTTONDOWN)    {        if (event->button.button == SDL_BUTTON_LEFT)        {            if (hoveredButton != -1)            {                menu_sounds_play_select();                // ... existing code ...            }        }    }}// Callback para quando o usu√°rio seleciona um slot de save statevoid on_save_state_complete(bool success, bool is_load, int slot_index, void *user_data){    if (success)    {        if (is_load)        {            EMU_LOG_INFO(EMU_LOG_CAT_FRONTEND, "Estado carregado com sucesso do slot %d", slot_index + 1);        }        else        {            EMU_LOG_INFO(EMU_LOG_CAT_FRONTEND, "Estado salvo com sucesso no slot %d", slot_index + 1);        }    }    else    {        if (is_load)        {            EMU_LOG_ERROR(EMU_LOG_CAT_FRONTEND, "Falha ao carregar estado do slot %d", slot_index + 1);        }        else        {            EMU_LOG_ERROR(EMU_LOG_CAT_FRONTEND, "Falha ao salvar estado no slot %d", slot_index + 1);        }    }}// Inicializar o emuladorbool initialize(){    // Inicializar sistemas...    // Inicializar o gerenciador de GUI    g_gui_manager = gui_manager_create(g_renderer);    if (!g_gui_manager)    {        std::cerr << "Falha ao inicializar o gerenciador de GUI" << std::endl;        return false;    }    // Inicializar o sistema de save state    if (!gui_save_state_init(g_gui_manager, "nes"))    {        std::cerr << "Falha ao inicializar o sistema de save state" << std::endl;        return false;    }    return true;}// Finalizar o emuladorvoid shutdown(){    // Finalizar sistemas...    // Finalizar o sistema de save state    gui_save_state_shutdown();    // Finalizar o gerenciador de GUI    if (g_gui_manager)    {        gui_manager_destroy(g_gui_manager);        g_gui_manager = nullptr;    }}// Ajustar a fun√ß√£o para renderizar a interface de save statevoid render_save_state(){    if (gui_save_state_is_visible())    {        // Obter o estado p√∫blico do save state        gui_save_state_t *state = gui_save_state_get_state();        gui_save_state_render(state);    }}// Fun√ß√£o principalint main(int argc, char *argv[]){    std::cout << "Iniciando Mega_Emu..." << std::endl;    // Verificar argumentos de linha de comando    bool auto_start = false;    std::string auto_rom_path;    if (argc > 1)    {        auto_rom_path = argv[1];        auto_start = true;        std::cout << "ROM especificada na linha de comando: " << auto_rom_path << std::endl;    }    // Inicializa√ß√£o do SDL    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_JOYSTICK) < 0)    {        std::cerr << "Erro ao inicializar SDL: " << SDL_GetError() << std::endl;        return 1;    }    // Verificar se h√° joysticks conectados    int num_joysticks = SDL_NumJoysticks();    std::cout << "Joysticks encontrados: " << num_joysticks << std::endl;    // Abrir o primeiro joystick se dispon√≠vel    SDL_Joystick *joystick = nullptr;    if (num_joysticks > 0)    {        joystick = SDL_JoystickOpen(0);        if (joystick)        {            std::cout << "Joystick conectado: " << SDL_JoystickName(joystick) << std::endl;            std::cout << "N√∫mero de bot√µes: " << SDL_JoystickNumButtons(joystick) << std::endl;            std::cout << "N√∫mero de eixos: " << SDL_JoystickNumAxes(joystick) << std::endl;        }    }    // Cria√ß√£o da janela    SDL_Window *window = SDL_CreateWindow(        "Mega_Emu - Emulador Multi-Plataforma",        SDL_WINDOWPOS_CENTERED,        SDL_WINDOWPOS_CENTERED,        NES_SCREEN_WIDTH * g_scale_factor,        NES_SCREEN_HEIGHT * g_scale_factor,        SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window)    {        std::cerr << "Erro ao criar janela: " << SDL_GetError() << std::endl;        SDL_Quit();        return 1;    }    // Cria√ß√£o do renderer    SDL_Renderer *renderer = SDL_CreateRenderer(        window,        -1,        SDL_RENDERER_ACCELERATED | (NES_ENABLE_VSYNC ? SDL_RENDERER_PRESENTVSYNC : 0));    if (!renderer)    {        std::cerr << "Erro ao criar renderer: " << SDL_GetError() << std::endl;        SDL_DestroyWindow(window);        SDL_Quit();        return 1;    }    // Inicializar o renderer do NES    if (nes_renderer_init(window, renderer) != 0)    {        std::cerr << "Erro ao inicializar o renderer do NES" << std::endl;        SDL_DestroyRenderer(renderer);        SDL_DestroyWindow(window);        SDL_Quit();        return 1;    }    // Inicializar o renderer de texto    texture_cache_t texture_cache;    texture_cache.renderer = renderer;    texture_cache.max_entries = 100;    texture_cache.current_entries = 0;    texture_cache.cache_data = NULL;    if (!text_renderer_init(renderer, &texture_cache))    {        std::cerr << "Aviso: N√£o foi poss√≠vel inicializar o renderer de texto. Usando fallback." << std::endl;    }    // Criar bot√µes para o menu    std::vector<Button> buttons;    // Bot√£o NES    buttons.push_back({{300, 150, 200, 50},                       "Nintendo NES",                       {0, 120, 255, 255},                       {0, 160, 255, 255},                       false});    // Bot√£o SNES    buttons.push_back({{300, 220, 200, 50},                       "Super Nintendo",                       {120, 0, 255, 255},                       {160, 0, 255, 255},                       false});    // Bot√£o Mega Drive    buttons.push_back({{300, 290, 200, 50},                       "Sega Mega Drive",                       {255, 0, 120, 255},                       {255, 0, 160, 255},                       false});    // Bot√£o Sair    buttons.push_back({{300, 400, 200, 50},                       "Sair",                       {255, 0, 0, 255},                       {255, 80, 80, 255},                       false});    // Iniciar emula√ß√£o automaticamente se ROM foi especificada    if (auto_start && !auto_rom_path.empty())    {        if (!startEmulation(auto_rom_path.c_str()))        {            std::cerr << "Falha ao iniciar emula√ß√£o com ROM: " << auto_rom_path << std::endl;            g_current_mode = MODE_MENU;        }    }    // Inicializar sons do menu    if (!loadMenuSounds())    {        std::cerr << "Aviso: Sons do menu n√£o puderam ser carregados" << std::endl;    }    // Inicializar o sistema    if (!initialize())    {        std::cerr << "Falha ao inicializar o sistema" << std::endl;        return 1;    }    // Loop principal    bool running = true;    SDL_Event event;    int mouseX, mouseY;    uint8_t controller_state = 0;    uint32_t last_frame_time = SDL_GetTicks();    while (running)    {        // Calcular delta time para anima√ß√µes suaves        uint32_t current_time = SDL_GetTicks();        float delta_time = (current_time - last_frame_time) / 1000.0f;        last_frame_time = current_time;        // Processamento de eventos        while (SDL_PollEvent(&event))        {            if (event.type == SDL_QUIT)            {                running = false;                continue;            }            // Processar eventos baseado no modo atual            switch (g_current_mode)            {            case MODE_MENU:                if (event.type == SDL_KEYDOWN)                {                    if (event.key.keysym.sym == SDLK_ESCAPE)                    {                        running = false;                        continue;                    }                }                else if (event.type == SDL_MOUSEMOTION)                {                    mouseX = event.motion.x;                    mouseY = event.motion.y;                    // Verificar se o mouse est√° sobre algum bot√£o                    for (auto &button : buttons)                    {                        button.isHovered = (mouseX >= button.rect.x &&                                            mouseX <= button.rect.x + button.rect.w &&                                            mouseY >= button.rect.y &&                                            mouseY <= button.rect.y + button.rect.h);                    }                }                else if (event.type == SDL_MOUSEBUTTONDOWN)                {                    if (event.button.button == SDL_BUTTON_LEFT)                    {                        mouseX = event.button.x;                        mouseY = event.button.y;                        // Verificar se algum bot√£o foi clicado                        for (size_t i = 0; i < buttons.size(); i++)                        {                            if (mouseX >= buttons[i].rect.x &&                                mouseX <= buttons[i].rect.x + buttons[i].rect.w &&                                mouseY >= buttons[i].rect.y &&                                mouseY <= buttons[i].rect.y + buttons[i].rect.h)                            {                                // A√ß√£o do bot√£o                                if (i == 0)                                {                                    std::cout << "Selecionado: NES" << std::endl;                                    startTransition(MODE_MENU, MODE_ROM_BROWSER);                                    g_current_mode = MODE_ROM_BROWSER;                                    loadRomEntries("resources/roms/nes");                                }                                else if (i == 1)                                {                                    std::cout << "Selecionado: SNES (N√£o implementado)" << std::endl;                                }                                else if (i == 2)                                {                                    std::cout << "Selecionado: Mega Drive (N√£o implementado)" << std::endl;                                }                                else if (i == 3)                                {                                    running = false;                                }                            }                        }                    }                }                break;            case MODE_ROM_BROWSER:                processRomBrowserInputEvent(&event);                processRomBrowserMouseWheel(event);                break;            case MODE_EMULATION:                processEmulationInputState(event, controller_state);                break;            }        }        // Renderiza√ß√£o baseada no modo atual        switch (g_current_mode)        {        case MODE_MENU:            renderMainMenu(renderer, buttons);            break;        case MODE_ROM_BROWSER:            renderRomBrowser(renderer);            break;        case MODE_EMULATION:            // Atualizar o estado dos controles            nes_set_controller1(controller_state);            // Executar um frame do NES            if (!runEmulationFrame())            {                startTransition(MODE_EMULATION, MODE_MENU);                g_current_mode = MODE_MENU;                stopEmulation();            }            break;        }        // Renderizar transi√ß√£o se ativa        if (g_transition.active)        {            updateTransition(delta_time, renderer);        }        // Controle de FPS para o menu e navegador de ROMs        if (g_current_mode != MODE_EMULATION)        {            uint32_t frame_time = SDL_GetTicks() - current_time;            if (frame_time < 16) // Aproximadamente 60 FPS            {                SDL_Delay(16 - frame_time);            }        }    }    // Cleanup    if (g_emulation_running)    {        stopEmulation();    }    // Finalizar renderer de texto    text_renderer_shutdown();    // Finalizar renderer de NES    nes_renderer_shutdown();    if (joystick)    {        SDL_JoystickClose(joystick);    }    SDL_DestroyRenderer(renderer);    SDL_DestroyWindow(window);    SDL_Quit();    // Cleanup sons do menu    cleanupMenuSounds();    // Finalizar o sistema    shutdown();    std::cout << "Mega_Emu finalizado com sucesso" << std::endl;    return 0;}